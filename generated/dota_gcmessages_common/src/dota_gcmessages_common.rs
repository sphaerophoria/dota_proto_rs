// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CSODOTAGameAccountClient {
    // message fields
    account_id: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    losses: ::std::option::Option<u32>,
    xp: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    initial_skill: ::std::option::Option<u32>,
    leaver_count: ::std::option::Option<u32>,
    secondary_leaver_count: ::std::option::Option<u32>,
    low_priority_until_date: ::std::option::Option<u32>,
    prevent_text_chat_until_date: ::std::option::Option<u32>,
    prevent_voice_until_date: ::std::option::Option<u32>,
    prevent_public_text_chat_until_date: ::std::option::Option<u32>,
    last_abandoned_game_date: ::std::option::Option<u32>,
    last_secondary_abandoned_game_date: ::std::option::Option<u32>,
    leaver_penalty_count: ::std::option::Option<u32>,
    completed_game_streak: ::std::option::Option<u32>,
    teaching: ::std::option::Option<u32>,
    leadership: ::std::option::Option<u32>,
    friendly: ::std::option::Option<u32>,
    forgiving: ::std::option::Option<u32>,
    account_disabled_until_date: ::std::option::Option<u32>,
    account_disabled_count: ::std::option::Option<u32>,
    showcase_hero_id: ::std::option::Option<u32>,
    match_disabled_until_date: ::std::option::Option<u32>,
    match_disabled_count: ::std::option::Option<u32>,
    partner_account_type: ::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType>,
    partner_account_state: ::std::option::Option<u32>,
    shutdownlawterminatetimestamp: ::std::option::Option<u32>,
    low_priority_games_remaining: ::std::option::Option<u32>,
    competitive_rank: ::std::option::Option<u32>,
    calibration_games_remaining: ::std::option::Option<u32>,
    solo_competitive_rank: ::std::option::Option<u32>,
    solo_calibration_games_remaining: ::std::option::Option<u32>,
    recruitment_level: ::std::option::Option<u32>,
    has_new_notifications: ::std::option::Option<bool>,
    is_league_admin: ::std::option::Option<bool>,
    casual_games_played: ::std::option::Option<u32>,
    solo_competitive_games_played: ::std::option::Option<u32>,
    party_competitive_games_played: ::std::option::Option<u32>,
    casual_1v1_games_played: ::std::option::Option<u32>,
    competitive_team_games_played: ::std::option::Option<u32>,
    curr_all_hero_challenge_id: ::std::option::Option<u32>,
    play_time_points: ::std::option::Option<u32>,
    account_flags: ::std::option::Option<u32>,
    play_time_level: ::std::option::Option<u32>,
    player_behavior_seq_num_last_report: ::std::option::Option<u32>,
    player_behavior_score_last_report: ::std::option::Option<u32>,
    player_behavior_report_old_data: ::std::option::Option<bool>,
    tourney_skill_level: ::std::option::Option<u32>,
    tourney_recent_participation_date: ::std::option::Option<u32>,
    favorite_team: ::std::option::Option<u32>,
    anchored_phone_number_id: ::std::option::Option<u64>,
    ranked_matchmaking_ban_until_date: ::std::option::Option<u32>,
    recent_game_time_1: ::std::option::Option<u32>,
    recent_game_time_2: ::std::option::Option<u32>,
    recent_game_time_3: ::std::option::Option<u32>,
    general_seasonal_ranked_rank: ::std::option::Option<u32>,
    general_seasonal_ranked_calibration_games_remaining: ::std::option::Option<u32>,
    general_seasonal_ranked_games_played: ::std::option::Option<u32>,
    general_seasonal_ranked_rank_peak: ::std::option::Option<u32>,
    general_seasonal_rank_transferred: ::std::option::Option<bool>,
    solo_seasonal_ranked_rank: ::std::option::Option<u32>,
    solo_seasonal_ranked_calibration_games_remaining: ::std::option::Option<u32>,
    solo_seasonal_ranked_games_played: ::std::option::Option<u32>,
    solo_seasonal_ranked_rank_peak: ::std::option::Option<u32>,
    solo_seasonal_rank_transferred: ::std::option::Option<bool>,
    favorite_team_packed: ::std::option::Option<u64>,
    recent_report_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSODOTAGameAccountClient {}

impl CSODOTAGameAccountClient {
    pub fn new() -> CSODOTAGameAccountClient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSODOTAGameAccountClient {
        static mut instance: ::protobuf::lazy::Lazy<CSODOTAGameAccountClient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSODOTAGameAccountClient,
        };
        unsafe {
            instance.get(CSODOTAGameAccountClient::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 wins = 3;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 losses = 4;

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    pub fn get_losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    fn get_losses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.losses
    }

    fn mut_losses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.losses
    }

    // optional uint32 xp = 12;

    pub fn clear_xp(&mut self) {
        self.xp = ::std::option::Option::None;
    }

    pub fn has_xp(&self) -> bool {
        self.xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp(&mut self, v: u32) {
        self.xp = ::std::option::Option::Some(v);
    }

    pub fn get_xp(&self) -> u32 {
        self.xp.unwrap_or(0)
    }

    fn get_xp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp
    }

    fn mut_xp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp
    }

    // optional uint32 level = 13;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional uint32 initial_skill = 14;

    pub fn clear_initial_skill(&mut self) {
        self.initial_skill = ::std::option::Option::None;
    }

    pub fn has_initial_skill(&self) -> bool {
        self.initial_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_skill(&mut self, v: u32) {
        self.initial_skill = ::std::option::Option::Some(v);
    }

    pub fn get_initial_skill(&self) -> u32 {
        self.initial_skill.unwrap_or(0)
    }

    fn get_initial_skill_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.initial_skill
    }

    fn mut_initial_skill_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.initial_skill
    }

    // optional uint32 leaver_count = 15;

    pub fn clear_leaver_count(&mut self) {
        self.leaver_count = ::std::option::Option::None;
    }

    pub fn has_leaver_count(&self) -> bool {
        self.leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_count(&mut self, v: u32) {
        self.leaver_count = ::std::option::Option::Some(v);
    }

    pub fn get_leaver_count(&self) -> u32 {
        self.leaver_count.unwrap_or(0)
    }

    fn get_leaver_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leaver_count
    }

    fn mut_leaver_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leaver_count
    }

    // optional uint32 secondary_leaver_count = 58;

    pub fn clear_secondary_leaver_count(&mut self) {
        self.secondary_leaver_count = ::std::option::Option::None;
    }

    pub fn has_secondary_leaver_count(&self) -> bool {
        self.secondary_leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_leaver_count(&mut self, v: u32) {
        self.secondary_leaver_count = ::std::option::Option::Some(v);
    }

    pub fn get_secondary_leaver_count(&self) -> u32 {
        self.secondary_leaver_count.unwrap_or(0)
    }

    fn get_secondary_leaver_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.secondary_leaver_count
    }

    fn mut_secondary_leaver_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.secondary_leaver_count
    }

    // optional uint32 low_priority_until_date = 18;

    pub fn clear_low_priority_until_date(&mut self) {
        self.low_priority_until_date = ::std::option::Option::None;
    }

    pub fn has_low_priority_until_date(&self) -> bool {
        self.low_priority_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_until_date(&mut self, v: u32) {
        self.low_priority_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority_until_date(&self) -> u32 {
        self.low_priority_until_date.unwrap_or(0)
    }

    fn get_low_priority_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.low_priority_until_date
    }

    fn mut_low_priority_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.low_priority_until_date
    }

    // optional uint32 prevent_text_chat_until_date = 20;

    pub fn clear_prevent_text_chat_until_date(&mut self) {
        self.prevent_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_text_chat_until_date(&self) -> bool {
        self.prevent_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_text_chat_until_date(&mut self, v: u32) {
        self.prevent_text_chat_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_text_chat_until_date(&self) -> u32 {
        self.prevent_text_chat_until_date.unwrap_or(0)
    }

    fn get_prevent_text_chat_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prevent_text_chat_until_date
    }

    fn mut_prevent_text_chat_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prevent_text_chat_until_date
    }

    // optional uint32 prevent_voice_until_date = 21;

    pub fn clear_prevent_voice_until_date(&mut self) {
        self.prevent_voice_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_voice_until_date(&self) -> bool {
        self.prevent_voice_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_voice_until_date(&mut self, v: u32) {
        self.prevent_voice_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_voice_until_date(&self) -> u32 {
        self.prevent_voice_until_date.unwrap_or(0)
    }

    fn get_prevent_voice_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prevent_voice_until_date
    }

    fn mut_prevent_voice_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prevent_voice_until_date
    }

    // optional uint32 prevent_public_text_chat_until_date = 86;

    pub fn clear_prevent_public_text_chat_until_date(&mut self) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_public_text_chat_until_date(&self) -> bool {
        self.prevent_public_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_public_text_chat_until_date(&mut self, v: u32) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_public_text_chat_until_date(&self) -> u32 {
        self.prevent_public_text_chat_until_date.unwrap_or(0)
    }

    fn get_prevent_public_text_chat_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prevent_public_text_chat_until_date
    }

    fn mut_prevent_public_text_chat_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prevent_public_text_chat_until_date
    }

    // optional uint32 last_abandoned_game_date = 22;

    pub fn clear_last_abandoned_game_date(&mut self) {
        self.last_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_abandoned_game_date(&self) -> bool {
        self.last_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_abandoned_game_date(&mut self, v: u32) {
        self.last_abandoned_game_date = ::std::option::Option::Some(v);
    }

    pub fn get_last_abandoned_game_date(&self) -> u32 {
        self.last_abandoned_game_date.unwrap_or(0)
    }

    fn get_last_abandoned_game_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_abandoned_game_date
    }

    fn mut_last_abandoned_game_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_abandoned_game_date
    }

    // optional uint32 last_secondary_abandoned_game_date = 59;

    pub fn clear_last_secondary_abandoned_game_date(&mut self) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_secondary_abandoned_game_date(&self) -> bool {
        self.last_secondary_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_secondary_abandoned_game_date(&mut self, v: u32) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::Some(v);
    }

    pub fn get_last_secondary_abandoned_game_date(&self) -> u32 {
        self.last_secondary_abandoned_game_date.unwrap_or(0)
    }

    fn get_last_secondary_abandoned_game_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_secondary_abandoned_game_date
    }

    fn mut_last_secondary_abandoned_game_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_secondary_abandoned_game_date
    }

    // optional uint32 leaver_penalty_count = 23;

    pub fn clear_leaver_penalty_count(&mut self) {
        self.leaver_penalty_count = ::std::option::Option::None;
    }

    pub fn has_leaver_penalty_count(&self) -> bool {
        self.leaver_penalty_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_penalty_count(&mut self, v: u32) {
        self.leaver_penalty_count = ::std::option::Option::Some(v);
    }

    pub fn get_leaver_penalty_count(&self) -> u32 {
        self.leaver_penalty_count.unwrap_or(0)
    }

    fn get_leaver_penalty_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leaver_penalty_count
    }

    fn mut_leaver_penalty_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leaver_penalty_count
    }

    // optional uint32 completed_game_streak = 24;

    pub fn clear_completed_game_streak(&mut self) {
        self.completed_game_streak = ::std::option::Option::None;
    }

    pub fn has_completed_game_streak(&self) -> bool {
        self.completed_game_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_game_streak(&mut self, v: u32) {
        self.completed_game_streak = ::std::option::Option::Some(v);
    }

    pub fn get_completed_game_streak(&self) -> u32 {
        self.completed_game_streak.unwrap_or(0)
    }

    fn get_completed_game_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.completed_game_streak
    }

    fn mut_completed_game_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.completed_game_streak
    }

    // optional uint32 teaching = 28;

    pub fn clear_teaching(&mut self) {
        self.teaching = ::std::option::Option::None;
    }

    pub fn has_teaching(&self) -> bool {
        self.teaching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teaching(&mut self, v: u32) {
        self.teaching = ::std::option::Option::Some(v);
    }

    pub fn get_teaching(&self) -> u32 {
        self.teaching.unwrap_or(0)
    }

    fn get_teaching_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teaching
    }

    fn mut_teaching_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teaching
    }

    // optional uint32 leadership = 29;

    pub fn clear_leadership(&mut self) {
        self.leadership = ::std::option::Option::None;
    }

    pub fn has_leadership(&self) -> bool {
        self.leadership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leadership(&mut self, v: u32) {
        self.leadership = ::std::option::Option::Some(v);
    }

    pub fn get_leadership(&self) -> u32 {
        self.leadership.unwrap_or(0)
    }

    fn get_leadership_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leadership
    }

    fn mut_leadership_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leadership
    }

    // optional uint32 friendly = 30;

    pub fn clear_friendly(&mut self) {
        self.friendly = ::std::option::Option::None;
    }

    pub fn has_friendly(&self) -> bool {
        self.friendly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly(&mut self, v: u32) {
        self.friendly = ::std::option::Option::Some(v);
    }

    pub fn get_friendly(&self) -> u32 {
        self.friendly.unwrap_or(0)
    }

    fn get_friendly_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.friendly
    }

    fn mut_friendly_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.friendly
    }

    // optional uint32 forgiving = 31;

    pub fn clear_forgiving(&mut self) {
        self.forgiving = ::std::option::Option::None;
    }

    pub fn has_forgiving(&self) -> bool {
        self.forgiving.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forgiving(&mut self, v: u32) {
        self.forgiving = ::std::option::Option::Some(v);
    }

    pub fn get_forgiving(&self) -> u32 {
        self.forgiving.unwrap_or(0)
    }

    fn get_forgiving_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.forgiving
    }

    fn mut_forgiving_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.forgiving
    }

    // optional uint32 account_disabled_until_date = 38;

    pub fn clear_account_disabled_until_date(&mut self) {
        self.account_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_account_disabled_until_date(&self) -> bool {
        self.account_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_until_date(&mut self, v: u32) {
        self.account_disabled_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_account_disabled_until_date(&self) -> u32 {
        self.account_disabled_until_date.unwrap_or(0)
    }

    fn get_account_disabled_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_disabled_until_date
    }

    fn mut_account_disabled_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_disabled_until_date
    }

    // optional uint32 account_disabled_count = 39;

    pub fn clear_account_disabled_count(&mut self) {
        self.account_disabled_count = ::std::option::Option::None;
    }

    pub fn has_account_disabled_count(&self) -> bool {
        self.account_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_count(&mut self, v: u32) {
        self.account_disabled_count = ::std::option::Option::Some(v);
    }

    pub fn get_account_disabled_count(&self) -> u32 {
        self.account_disabled_count.unwrap_or(0)
    }

    fn get_account_disabled_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_disabled_count
    }

    fn mut_account_disabled_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_disabled_count
    }

    // optional uint32 showcase_hero_id = 40;

    pub fn clear_showcase_hero_id(&mut self) {
        self.showcase_hero_id = ::std::option::Option::None;
    }

    pub fn has_showcase_hero_id(&self) -> bool {
        self.showcase_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_hero_id(&mut self, v: u32) {
        self.showcase_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_showcase_hero_id(&self) -> u32 {
        self.showcase_hero_id.unwrap_or(0)
    }

    fn get_showcase_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.showcase_hero_id
    }

    fn mut_showcase_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.showcase_hero_id
    }

    // optional uint32 match_disabled_until_date = 41;

    pub fn clear_match_disabled_until_date(&mut self) {
        self.match_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_match_disabled_until_date(&self) -> bool {
        self.match_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_until_date(&mut self, v: u32) {
        self.match_disabled_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_match_disabled_until_date(&self) -> u32 {
        self.match_disabled_until_date.unwrap_or(0)
    }

    fn get_match_disabled_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_disabled_until_date
    }

    fn mut_match_disabled_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_disabled_until_date
    }

    // optional uint32 match_disabled_count = 42;

    pub fn clear_match_disabled_count(&mut self) {
        self.match_disabled_count = ::std::option::Option::None;
    }

    pub fn has_match_disabled_count(&self) -> bool {
        self.match_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_count(&mut self, v: u32) {
        self.match_disabled_count = ::std::option::Option::Some(v);
    }

    pub fn get_match_disabled_count(&self) -> u32 {
        self.match_disabled_count.unwrap_or(0)
    }

    fn get_match_disabled_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_disabled_count
    }

    fn mut_match_disabled_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_disabled_count
    }

    // optional .PartnerAccountType partner_account_type = 44;

    pub fn clear_partner_account_type(&mut self) {
        self.partner_account_type = ::std::option::Option::None;
    }

    pub fn has_partner_account_type(&self) -> bool {
        self.partner_account_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_account_type(&mut self, v: super::gcsdk_gcmessages::PartnerAccountType) {
        self.partner_account_type = ::std::option::Option::Some(v);
    }

    pub fn get_partner_account_type(&self) -> super::gcsdk_gcmessages::PartnerAccountType {
        self.partner_account_type.unwrap_or(super::gcsdk_gcmessages::PartnerAccountType::PARTNER_NONE)
    }

    fn get_partner_account_type_for_reflect(&self) -> &::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType> {
        &self.partner_account_type
    }

    fn mut_partner_account_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType> {
        &mut self.partner_account_type
    }

    // optional uint32 partner_account_state = 45;

    pub fn clear_partner_account_state(&mut self) {
        self.partner_account_state = ::std::option::Option::None;
    }

    pub fn has_partner_account_state(&self) -> bool {
        self.partner_account_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_account_state(&mut self, v: u32) {
        self.partner_account_state = ::std::option::Option::Some(v);
    }

    pub fn get_partner_account_state(&self) -> u32 {
        self.partner_account_state.unwrap_or(0)
    }

    fn get_partner_account_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.partner_account_state
    }

    fn mut_partner_account_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.partner_account_state
    }

    // optional uint32 shutdownlawterminatetimestamp = 47;

    pub fn clear_shutdownlawterminatetimestamp(&mut self) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::None;
    }

    pub fn has_shutdownlawterminatetimestamp(&self) -> bool {
        self.shutdownlawterminatetimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdownlawterminatetimestamp(&mut self, v: u32) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::Some(v);
    }

    pub fn get_shutdownlawterminatetimestamp(&self) -> u32 {
        self.shutdownlawterminatetimestamp.unwrap_or(0)
    }

    fn get_shutdownlawterminatetimestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.shutdownlawterminatetimestamp
    }

    fn mut_shutdownlawterminatetimestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.shutdownlawterminatetimestamp
    }

    // optional uint32 low_priority_games_remaining = 48;

    pub fn clear_low_priority_games_remaining(&mut self) {
        self.low_priority_games_remaining = ::std::option::Option::None;
    }

    pub fn has_low_priority_games_remaining(&self) -> bool {
        self.low_priority_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_games_remaining(&mut self, v: u32) {
        self.low_priority_games_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority_games_remaining(&self) -> u32 {
        self.low_priority_games_remaining.unwrap_or(0)
    }

    fn get_low_priority_games_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.low_priority_games_remaining
    }

    fn mut_low_priority_games_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.low_priority_games_remaining
    }

    // optional uint32 competitive_rank = 49;

    pub fn clear_competitive_rank(&mut self) {
        self.competitive_rank = ::std::option::Option::None;
    }

    pub fn has_competitive_rank(&self) -> bool {
        self.competitive_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_rank(&mut self, v: u32) {
        self.competitive_rank = ::std::option::Option::Some(v);
    }

    pub fn get_competitive_rank(&self) -> u32 {
        self.competitive_rank.unwrap_or(0)
    }

    fn get_competitive_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.competitive_rank
    }

    fn mut_competitive_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.competitive_rank
    }

    // optional uint32 calibration_games_remaining = 51;

    pub fn clear_calibration_games_remaining(&mut self) {
        self.calibration_games_remaining = ::std::option::Option::None;
    }

    pub fn has_calibration_games_remaining(&self) -> bool {
        self.calibration_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calibration_games_remaining(&mut self, v: u32) {
        self.calibration_games_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_calibration_games_remaining(&self) -> u32 {
        self.calibration_games_remaining.unwrap_or(0)
    }

    fn get_calibration_games_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.calibration_games_remaining
    }

    fn mut_calibration_games_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.calibration_games_remaining
    }

    // optional uint32 solo_competitive_rank = 52;

    pub fn clear_solo_competitive_rank(&mut self) {
        self.solo_competitive_rank = ::std::option::Option::None;
    }

    pub fn has_solo_competitive_rank(&self) -> bool {
        self.solo_competitive_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_competitive_rank(&mut self, v: u32) {
        self.solo_competitive_rank = ::std::option::Option::Some(v);
    }

    pub fn get_solo_competitive_rank(&self) -> u32 {
        self.solo_competitive_rank.unwrap_or(0)
    }

    fn get_solo_competitive_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_competitive_rank
    }

    fn mut_solo_competitive_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_competitive_rank
    }

    // optional uint32 solo_calibration_games_remaining = 54;

    pub fn clear_solo_calibration_games_remaining(&mut self) {
        self.solo_calibration_games_remaining = ::std::option::Option::None;
    }

    pub fn has_solo_calibration_games_remaining(&self) -> bool {
        self.solo_calibration_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_calibration_games_remaining(&mut self, v: u32) {
        self.solo_calibration_games_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_solo_calibration_games_remaining(&self) -> u32 {
        self.solo_calibration_games_remaining.unwrap_or(0)
    }

    fn get_solo_calibration_games_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_calibration_games_remaining
    }

    fn mut_solo_calibration_games_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_calibration_games_remaining
    }

    // optional uint32 recruitment_level = 55;

    pub fn clear_recruitment_level(&mut self) {
        self.recruitment_level = ::std::option::Option::None;
    }

    pub fn has_recruitment_level(&self) -> bool {
        self.recruitment_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recruitment_level(&mut self, v: u32) {
        self.recruitment_level = ::std::option::Option::Some(v);
    }

    pub fn get_recruitment_level(&self) -> u32 {
        self.recruitment_level.unwrap_or(0)
    }

    fn get_recruitment_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recruitment_level
    }

    fn mut_recruitment_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recruitment_level
    }

    // optional bool has_new_notifications = 56;

    pub fn clear_has_new_notifications(&mut self) {
        self.has_new_notifications = ::std::option::Option::None;
    }

    pub fn has_has_new_notifications(&self) -> bool {
        self.has_new_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_new_notifications(&mut self, v: bool) {
        self.has_new_notifications = ::std::option::Option::Some(v);
    }

    pub fn get_has_new_notifications(&self) -> bool {
        self.has_new_notifications.unwrap_or(false)
    }

    fn get_has_new_notifications_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_new_notifications
    }

    fn mut_has_new_notifications_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_new_notifications
    }

    // optional bool is_league_admin = 57;

    pub fn clear_is_league_admin(&mut self) {
        self.is_league_admin = ::std::option::Option::None;
    }

    pub fn has_is_league_admin(&self) -> bool {
        self.is_league_admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_league_admin(&mut self, v: bool) {
        self.is_league_admin = ::std::option::Option::Some(v);
    }

    pub fn get_is_league_admin(&self) -> bool {
        self.is_league_admin.unwrap_or(false)
    }

    fn get_is_league_admin_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_league_admin
    }

    fn mut_is_league_admin_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_league_admin
    }

    // optional uint32 casual_games_played = 60;

    pub fn clear_casual_games_played(&mut self) {
        self.casual_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_games_played(&self) -> bool {
        self.casual_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_games_played(&mut self, v: u32) {
        self.casual_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_casual_games_played(&self) -> u32 {
        self.casual_games_played.unwrap_or(0)
    }

    fn get_casual_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.casual_games_played
    }

    fn mut_casual_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.casual_games_played
    }

    // optional uint32 solo_competitive_games_played = 61;

    pub fn clear_solo_competitive_games_played(&mut self) {
        self.solo_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_solo_competitive_games_played(&self) -> bool {
        self.solo_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_competitive_games_played(&mut self, v: u32) {
        self.solo_competitive_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_solo_competitive_games_played(&self) -> u32 {
        self.solo_competitive_games_played.unwrap_or(0)
    }

    fn get_solo_competitive_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_competitive_games_played
    }

    fn mut_solo_competitive_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_competitive_games_played
    }

    // optional uint32 party_competitive_games_played = 62;

    pub fn clear_party_competitive_games_played(&mut self) {
        self.party_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_party_competitive_games_played(&self) -> bool {
        self.party_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_competitive_games_played(&mut self, v: u32) {
        self.party_competitive_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_party_competitive_games_played(&self) -> u32 {
        self.party_competitive_games_played.unwrap_or(0)
    }

    fn get_party_competitive_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.party_competitive_games_played
    }

    fn mut_party_competitive_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.party_competitive_games_played
    }

    // optional uint32 casual_1v1_games_played = 65;

    pub fn clear_casual_1v1_games_played(&mut self) {
        self.casual_1v1_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_1v1_games_played(&self) -> bool {
        self.casual_1v1_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_1v1_games_played(&mut self, v: u32) {
        self.casual_1v1_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_casual_1v1_games_played(&self) -> u32 {
        self.casual_1v1_games_played.unwrap_or(0)
    }

    fn get_casual_1v1_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.casual_1v1_games_played
    }

    fn mut_casual_1v1_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.casual_1v1_games_played
    }

    // optional uint32 competitive_team_games_played = 66;

    pub fn clear_competitive_team_games_played(&mut self) {
        self.competitive_team_games_played = ::std::option::Option::None;
    }

    pub fn has_competitive_team_games_played(&self) -> bool {
        self.competitive_team_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_team_games_played(&mut self, v: u32) {
        self.competitive_team_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_competitive_team_games_played(&self) -> u32 {
        self.competitive_team_games_played.unwrap_or(0)
    }

    fn get_competitive_team_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.competitive_team_games_played
    }

    fn mut_competitive_team_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.competitive_team_games_played
    }

    // optional uint32 curr_all_hero_challenge_id = 67;

    pub fn clear_curr_all_hero_challenge_id(&mut self) {
        self.curr_all_hero_challenge_id = ::std::option::Option::None;
    }

    pub fn has_curr_all_hero_challenge_id(&self) -> bool {
        self.curr_all_hero_challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_all_hero_challenge_id(&mut self, v: u32) {
        self.curr_all_hero_challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_curr_all_hero_challenge_id(&self) -> u32 {
        self.curr_all_hero_challenge_id.unwrap_or(0)
    }

    fn get_curr_all_hero_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.curr_all_hero_challenge_id
    }

    fn mut_curr_all_hero_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.curr_all_hero_challenge_id
    }

    // optional uint32 play_time_points = 68;

    pub fn clear_play_time_points(&mut self) {
        self.play_time_points = ::std::option::Option::None;
    }

    pub fn has_play_time_points(&self) -> bool {
        self.play_time_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_points(&mut self, v: u32) {
        self.play_time_points = ::std::option::Option::Some(v);
    }

    pub fn get_play_time_points(&self) -> u32 {
        self.play_time_points.unwrap_or(0)
    }

    fn get_play_time_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.play_time_points
    }

    fn mut_play_time_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.play_time_points
    }

    // optional uint32 account_flags = 69;

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    pub fn get_account_flags(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    fn get_account_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_flags
    }

    fn mut_account_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_flags
    }

    // optional uint32 play_time_level = 70;

    pub fn clear_play_time_level(&mut self) {
        self.play_time_level = ::std::option::Option::None;
    }

    pub fn has_play_time_level(&self) -> bool {
        self.play_time_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_level(&mut self, v: u32) {
        self.play_time_level = ::std::option::Option::Some(v);
    }

    pub fn get_play_time_level(&self) -> u32 {
        self.play_time_level.unwrap_or(0)
    }

    fn get_play_time_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.play_time_level
    }

    fn mut_play_time_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.play_time_level
    }

    // optional uint32 player_behavior_seq_num_last_report = 71;

    pub fn clear_player_behavior_seq_num_last_report(&mut self) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_seq_num_last_report(&self) -> bool {
        self.player_behavior_seq_num_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_seq_num_last_report(&mut self, v: u32) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::Some(v);
    }

    pub fn get_player_behavior_seq_num_last_report(&self) -> u32 {
        self.player_behavior_seq_num_last_report.unwrap_or(0)
    }

    fn get_player_behavior_seq_num_last_report_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_behavior_seq_num_last_report
    }

    fn mut_player_behavior_seq_num_last_report_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_behavior_seq_num_last_report
    }

    // optional uint32 player_behavior_score_last_report = 72;

    pub fn clear_player_behavior_score_last_report(&mut self) {
        self.player_behavior_score_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_score_last_report(&self) -> bool {
        self.player_behavior_score_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_score_last_report(&mut self, v: u32) {
        self.player_behavior_score_last_report = ::std::option::Option::Some(v);
    }

    pub fn get_player_behavior_score_last_report(&self) -> u32 {
        self.player_behavior_score_last_report.unwrap_or(0)
    }

    fn get_player_behavior_score_last_report_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_behavior_score_last_report
    }

    fn mut_player_behavior_score_last_report_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_behavior_score_last_report
    }

    // optional bool player_behavior_report_old_data = 73;

    pub fn clear_player_behavior_report_old_data(&mut self) {
        self.player_behavior_report_old_data = ::std::option::Option::None;
    }

    pub fn has_player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_report_old_data(&mut self, v: bool) {
        self.player_behavior_report_old_data = ::std::option::Option::Some(v);
    }

    pub fn get_player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.unwrap_or(false)
    }

    fn get_player_behavior_report_old_data_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.player_behavior_report_old_data
    }

    fn mut_player_behavior_report_old_data_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.player_behavior_report_old_data
    }

    // optional uint32 tourney_skill_level = 74;

    pub fn clear_tourney_skill_level(&mut self) {
        self.tourney_skill_level = ::std::option::Option::None;
    }

    pub fn has_tourney_skill_level(&self) -> bool {
        self.tourney_skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_skill_level(&mut self, v: u32) {
        self.tourney_skill_level = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_skill_level(&self) -> u32 {
        self.tourney_skill_level.unwrap_or(0)
    }

    fn get_tourney_skill_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_skill_level
    }

    fn mut_tourney_skill_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_skill_level
    }

    // optional uint32 tourney_recent_participation_date = 85;

    pub fn clear_tourney_recent_participation_date(&mut self) {
        self.tourney_recent_participation_date = ::std::option::Option::None;
    }

    pub fn has_tourney_recent_participation_date(&self) -> bool {
        self.tourney_recent_participation_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_recent_participation_date(&mut self, v: u32) {
        self.tourney_recent_participation_date = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_recent_participation_date(&self) -> u32 {
        self.tourney_recent_participation_date.unwrap_or(0)
    }

    fn get_tourney_recent_participation_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_recent_participation_date
    }

    fn mut_tourney_recent_participation_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_recent_participation_date
    }

    // optional uint32 favorite_team = 87;

    pub fn clear_favorite_team(&mut self) {
        self.favorite_team = ::std::option::Option::None;
    }

    pub fn has_favorite_team(&self) -> bool {
        self.favorite_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team(&mut self, v: u32) {
        self.favorite_team = ::std::option::Option::Some(v);
    }

    pub fn get_favorite_team(&self) -> u32 {
        self.favorite_team.unwrap_or(0)
    }

    fn get_favorite_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.favorite_team
    }

    fn mut_favorite_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.favorite_team
    }

    // optional uint64 anchored_phone_number_id = 88;

    pub fn clear_anchored_phone_number_id(&mut self) {
        self.anchored_phone_number_id = ::std::option::Option::None;
    }

    pub fn has_anchored_phone_number_id(&self) -> bool {
        self.anchored_phone_number_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anchored_phone_number_id(&mut self, v: u64) {
        self.anchored_phone_number_id = ::std::option::Option::Some(v);
    }

    pub fn get_anchored_phone_number_id(&self) -> u64 {
        self.anchored_phone_number_id.unwrap_or(0)
    }

    fn get_anchored_phone_number_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.anchored_phone_number_id
    }

    fn mut_anchored_phone_number_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.anchored_phone_number_id
    }

    // optional uint32 ranked_matchmaking_ban_until_date = 89;

    pub fn clear_ranked_matchmaking_ban_until_date(&mut self) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::None;
    }

    pub fn has_ranked_matchmaking_ban_until_date(&self) -> bool {
        self.ranked_matchmaking_ban_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_matchmaking_ban_until_date(&mut self, v: u32) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(v);
    }

    pub fn get_ranked_matchmaking_ban_until_date(&self) -> u32 {
        self.ranked_matchmaking_ban_until_date.unwrap_or(0)
    }

    fn get_ranked_matchmaking_ban_until_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ranked_matchmaking_ban_until_date
    }

    fn mut_ranked_matchmaking_ban_until_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ranked_matchmaking_ban_until_date
    }

    // optional uint32 recent_game_time_1 = 90;

    pub fn clear_recent_game_time_1(&mut self) {
        self.recent_game_time_1 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_1(&self) -> bool {
        self.recent_game_time_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_1(&mut self, v: u32) {
        self.recent_game_time_1 = ::std::option::Option::Some(v);
    }

    pub fn get_recent_game_time_1(&self) -> u32 {
        self.recent_game_time_1.unwrap_or(0)
    }

    fn get_recent_game_time_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recent_game_time_1
    }

    fn mut_recent_game_time_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recent_game_time_1
    }

    // optional uint32 recent_game_time_2 = 91;

    pub fn clear_recent_game_time_2(&mut self) {
        self.recent_game_time_2 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_2(&self) -> bool {
        self.recent_game_time_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_2(&mut self, v: u32) {
        self.recent_game_time_2 = ::std::option::Option::Some(v);
    }

    pub fn get_recent_game_time_2(&self) -> u32 {
        self.recent_game_time_2.unwrap_or(0)
    }

    fn get_recent_game_time_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recent_game_time_2
    }

    fn mut_recent_game_time_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recent_game_time_2
    }

    // optional uint32 recent_game_time_3 = 92;

    pub fn clear_recent_game_time_3(&mut self) {
        self.recent_game_time_3 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_3(&self) -> bool {
        self.recent_game_time_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_3(&mut self, v: u32) {
        self.recent_game_time_3 = ::std::option::Option::Some(v);
    }

    pub fn get_recent_game_time_3(&self) -> u32 {
        self.recent_game_time_3.unwrap_or(0)
    }

    fn get_recent_game_time_3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recent_game_time_3
    }

    fn mut_recent_game_time_3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recent_game_time_3
    }

    // optional uint32 general_seasonal_ranked_rank = 93;

    pub fn clear_general_seasonal_ranked_rank(&mut self) {
        self.general_seasonal_ranked_rank = ::std::option::Option::None;
    }

    pub fn has_general_seasonal_ranked_rank(&self) -> bool {
        self.general_seasonal_ranked_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_general_seasonal_ranked_rank(&mut self, v: u32) {
        self.general_seasonal_ranked_rank = ::std::option::Option::Some(v);
    }

    pub fn get_general_seasonal_ranked_rank(&self) -> u32 {
        self.general_seasonal_ranked_rank.unwrap_or(0)
    }

    fn get_general_seasonal_ranked_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.general_seasonal_ranked_rank
    }

    fn mut_general_seasonal_ranked_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.general_seasonal_ranked_rank
    }

    // optional uint32 general_seasonal_ranked_calibration_games_remaining = 94;

    pub fn clear_general_seasonal_ranked_calibration_games_remaining(&mut self) {
        self.general_seasonal_ranked_calibration_games_remaining = ::std::option::Option::None;
    }

    pub fn has_general_seasonal_ranked_calibration_games_remaining(&self) -> bool {
        self.general_seasonal_ranked_calibration_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_general_seasonal_ranked_calibration_games_remaining(&mut self, v: u32) {
        self.general_seasonal_ranked_calibration_games_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_general_seasonal_ranked_calibration_games_remaining(&self) -> u32 {
        self.general_seasonal_ranked_calibration_games_remaining.unwrap_or(0)
    }

    fn get_general_seasonal_ranked_calibration_games_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.general_seasonal_ranked_calibration_games_remaining
    }

    fn mut_general_seasonal_ranked_calibration_games_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.general_seasonal_ranked_calibration_games_remaining
    }

    // optional uint32 general_seasonal_ranked_games_played = 95;

    pub fn clear_general_seasonal_ranked_games_played(&mut self) {
        self.general_seasonal_ranked_games_played = ::std::option::Option::None;
    }

    pub fn has_general_seasonal_ranked_games_played(&self) -> bool {
        self.general_seasonal_ranked_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_general_seasonal_ranked_games_played(&mut self, v: u32) {
        self.general_seasonal_ranked_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_general_seasonal_ranked_games_played(&self) -> u32 {
        self.general_seasonal_ranked_games_played.unwrap_or(0)
    }

    fn get_general_seasonal_ranked_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.general_seasonal_ranked_games_played
    }

    fn mut_general_seasonal_ranked_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.general_seasonal_ranked_games_played
    }

    // optional uint32 general_seasonal_ranked_rank_peak = 96;

    pub fn clear_general_seasonal_ranked_rank_peak(&mut self) {
        self.general_seasonal_ranked_rank_peak = ::std::option::Option::None;
    }

    pub fn has_general_seasonal_ranked_rank_peak(&self) -> bool {
        self.general_seasonal_ranked_rank_peak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_general_seasonal_ranked_rank_peak(&mut self, v: u32) {
        self.general_seasonal_ranked_rank_peak = ::std::option::Option::Some(v);
    }

    pub fn get_general_seasonal_ranked_rank_peak(&self) -> u32 {
        self.general_seasonal_ranked_rank_peak.unwrap_or(0)
    }

    fn get_general_seasonal_ranked_rank_peak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.general_seasonal_ranked_rank_peak
    }

    fn mut_general_seasonal_ranked_rank_peak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.general_seasonal_ranked_rank_peak
    }

    // optional bool general_seasonal_rank_transferred = 97;

    pub fn clear_general_seasonal_rank_transferred(&mut self) {
        self.general_seasonal_rank_transferred = ::std::option::Option::None;
    }

    pub fn has_general_seasonal_rank_transferred(&self) -> bool {
        self.general_seasonal_rank_transferred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_general_seasonal_rank_transferred(&mut self, v: bool) {
        self.general_seasonal_rank_transferred = ::std::option::Option::Some(v);
    }

    pub fn get_general_seasonal_rank_transferred(&self) -> bool {
        self.general_seasonal_rank_transferred.unwrap_or(false)
    }

    fn get_general_seasonal_rank_transferred_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.general_seasonal_rank_transferred
    }

    fn mut_general_seasonal_rank_transferred_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.general_seasonal_rank_transferred
    }

    // optional uint32 solo_seasonal_ranked_rank = 98;

    pub fn clear_solo_seasonal_ranked_rank(&mut self) {
        self.solo_seasonal_ranked_rank = ::std::option::Option::None;
    }

    pub fn has_solo_seasonal_ranked_rank(&self) -> bool {
        self.solo_seasonal_ranked_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_seasonal_ranked_rank(&mut self, v: u32) {
        self.solo_seasonal_ranked_rank = ::std::option::Option::Some(v);
    }

    pub fn get_solo_seasonal_ranked_rank(&self) -> u32 {
        self.solo_seasonal_ranked_rank.unwrap_or(0)
    }

    fn get_solo_seasonal_ranked_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_seasonal_ranked_rank
    }

    fn mut_solo_seasonal_ranked_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_seasonal_ranked_rank
    }

    // optional uint32 solo_seasonal_ranked_calibration_games_remaining = 99;

    pub fn clear_solo_seasonal_ranked_calibration_games_remaining(&mut self) {
        self.solo_seasonal_ranked_calibration_games_remaining = ::std::option::Option::None;
    }

    pub fn has_solo_seasonal_ranked_calibration_games_remaining(&self) -> bool {
        self.solo_seasonal_ranked_calibration_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_seasonal_ranked_calibration_games_remaining(&mut self, v: u32) {
        self.solo_seasonal_ranked_calibration_games_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_solo_seasonal_ranked_calibration_games_remaining(&self) -> u32 {
        self.solo_seasonal_ranked_calibration_games_remaining.unwrap_or(0)
    }

    fn get_solo_seasonal_ranked_calibration_games_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_seasonal_ranked_calibration_games_remaining
    }

    fn mut_solo_seasonal_ranked_calibration_games_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_seasonal_ranked_calibration_games_remaining
    }

    // optional uint32 solo_seasonal_ranked_games_played = 100;

    pub fn clear_solo_seasonal_ranked_games_played(&mut self) {
        self.solo_seasonal_ranked_games_played = ::std::option::Option::None;
    }

    pub fn has_solo_seasonal_ranked_games_played(&self) -> bool {
        self.solo_seasonal_ranked_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_seasonal_ranked_games_played(&mut self, v: u32) {
        self.solo_seasonal_ranked_games_played = ::std::option::Option::Some(v);
    }

    pub fn get_solo_seasonal_ranked_games_played(&self) -> u32 {
        self.solo_seasonal_ranked_games_played.unwrap_or(0)
    }

    fn get_solo_seasonal_ranked_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_seasonal_ranked_games_played
    }

    fn mut_solo_seasonal_ranked_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_seasonal_ranked_games_played
    }

    // optional uint32 solo_seasonal_ranked_rank_peak = 101;

    pub fn clear_solo_seasonal_ranked_rank_peak(&mut self) {
        self.solo_seasonal_ranked_rank_peak = ::std::option::Option::None;
    }

    pub fn has_solo_seasonal_ranked_rank_peak(&self) -> bool {
        self.solo_seasonal_ranked_rank_peak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_seasonal_ranked_rank_peak(&mut self, v: u32) {
        self.solo_seasonal_ranked_rank_peak = ::std::option::Option::Some(v);
    }

    pub fn get_solo_seasonal_ranked_rank_peak(&self) -> u32 {
        self.solo_seasonal_ranked_rank_peak.unwrap_or(0)
    }

    fn get_solo_seasonal_ranked_rank_peak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.solo_seasonal_ranked_rank_peak
    }

    fn mut_solo_seasonal_ranked_rank_peak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.solo_seasonal_ranked_rank_peak
    }

    // optional bool solo_seasonal_rank_transferred = 102;

    pub fn clear_solo_seasonal_rank_transferred(&mut self) {
        self.solo_seasonal_rank_transferred = ::std::option::Option::None;
    }

    pub fn has_solo_seasonal_rank_transferred(&self) -> bool {
        self.solo_seasonal_rank_transferred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_seasonal_rank_transferred(&mut self, v: bool) {
        self.solo_seasonal_rank_transferred = ::std::option::Option::Some(v);
    }

    pub fn get_solo_seasonal_rank_transferred(&self) -> bool {
        self.solo_seasonal_rank_transferred.unwrap_or(false)
    }

    fn get_solo_seasonal_rank_transferred_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.solo_seasonal_rank_transferred
    }

    fn mut_solo_seasonal_rank_transferred_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.solo_seasonal_rank_transferred
    }

    // optional uint64 favorite_team_packed = 103;

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    pub fn get_favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    fn get_favorite_team_packed_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.favorite_team_packed
    }

    fn mut_favorite_team_packed_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.favorite_team_packed
    }

    // optional uint32 recent_report_time = 104;

    pub fn clear_recent_report_time(&mut self) {
        self.recent_report_time = ::std::option::Option::None;
    }

    pub fn has_recent_report_time(&self) -> bool {
        self.recent_report_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_report_time(&mut self, v: u32) {
        self.recent_report_time = ::std::option::Option::Some(v);
    }

    pub fn get_recent_report_time(&self) -> u32 {
        self.recent_report_time.unwrap_or(0)
    }

    fn get_recent_report_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recent_report_time
    }

    fn mut_recent_report_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recent_report_time
    }
}

impl ::protobuf::Message for CSODOTAGameAccountClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.losses = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_skill = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leaver_count = ::std::option::Option::Some(tmp);
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondary_leaver_count = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.low_priority_until_date = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prevent_text_chat_until_date = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prevent_voice_until_date = ::std::option::Option::Some(tmp);
                },
                86 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prevent_public_text_chat_until_date = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_abandoned_game_date = ::std::option::Option::Some(tmp);
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_secondary_abandoned_game_date = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leaver_penalty_count = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed_game_streak = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teaching = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leadership = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friendly = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.forgiving = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_disabled_until_date = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_disabled_count = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.showcase_hero_id = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_disabled_until_date = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_disabled_count = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.partner_account_type = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partner_account_state = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shutdownlawterminatetimestamp = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.low_priority_games_remaining = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.competitive_rank = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.calibration_games_remaining = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_competitive_rank = ::std::option::Option::Some(tmp);
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_calibration_games_remaining = ::std::option::Option::Some(tmp);
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recruitment_level = ::std::option::Option::Some(tmp);
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_new_notifications = ::std::option::Option::Some(tmp);
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_league_admin = ::std::option::Option::Some(tmp);
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.casual_games_played = ::std::option::Option::Some(tmp);
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_competitive_games_played = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.party_competitive_games_played = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.casual_1v1_games_played = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.competitive_team_games_played = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.curr_all_hero_challenge_id = ::std::option::Option::Some(tmp);
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.play_time_points = ::std::option::Option::Some(tmp);
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_flags = ::std::option::Option::Some(tmp);
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.play_time_level = ::std::option::Option::Some(tmp);
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_behavior_seq_num_last_report = ::std::option::Option::Some(tmp);
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_behavior_score_last_report = ::std::option::Option::Some(tmp);
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_behavior_report_old_data = ::std::option::Option::Some(tmp);
                },
                74 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_skill_level = ::std::option::Option::Some(tmp);
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_recent_participation_date = ::std::option::Option::Some(tmp);
                },
                87 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.favorite_team = ::std::option::Option::Some(tmp);
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.anchored_phone_number_id = ::std::option::Option::Some(tmp);
                },
                89 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(tmp);
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recent_game_time_1 = ::std::option::Option::Some(tmp);
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recent_game_time_2 = ::std::option::Option::Some(tmp);
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recent_game_time_3 = ::std::option::Option::Some(tmp);
                },
                93 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.general_seasonal_ranked_rank = ::std::option::Option::Some(tmp);
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.general_seasonal_ranked_calibration_games_remaining = ::std::option::Option::Some(tmp);
                },
                95 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.general_seasonal_ranked_games_played = ::std::option::Option::Some(tmp);
                },
                96 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.general_seasonal_ranked_rank_peak = ::std::option::Option::Some(tmp);
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.general_seasonal_rank_transferred = ::std::option::Option::Some(tmp);
                },
                98 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_seasonal_ranked_rank = ::std::option::Option::Some(tmp);
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_seasonal_ranked_calibration_games_remaining = ::std::option::Option::Some(tmp);
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_seasonal_ranked_games_played = ::std::option::Option::Some(tmp);
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solo_seasonal_ranked_rank_peak = ::std::option::Option::Some(tmp);
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.solo_seasonal_rank_transferred = ::std::option::Option::Some(tmp);
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.favorite_team_packed = ::std::option::Option::Some(tmp);
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recent_report_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_skill {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaver_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.secondary_leaver_count {
            my_size += ::protobuf::rt::value_size(58, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.low_priority_until_date {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prevent_voice_until_date {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            my_size += ::protobuf::rt::value_size(86, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_abandoned_game_date {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            my_size += ::protobuf::rt::value_size(59, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaver_penalty_count {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completed_game_streak {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teaching {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leadership {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friendly {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forgiving {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_disabled_until_date {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_disabled_count {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.showcase_hero_id {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_disabled_until_date {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_disabled_count {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partner_account_type {
            my_size += ::protobuf::rt::enum_size(44, v);
        }
        if let Some(v) = self.partner_account_state {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.low_priority_games_remaining {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.competitive_rank {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.calibration_games_remaining {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_competitive_rank {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_calibration_games_remaining {
            my_size += ::protobuf::rt::value_size(54, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recruitment_level {
            my_size += ::protobuf::rt::value_size(55, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.has_new_notifications {
            my_size += 3;
        }
        if let Some(v) = self.is_league_admin {
            my_size += 3;
        }
        if let Some(v) = self.casual_games_played {
            my_size += ::protobuf::rt::value_size(60, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_competitive_games_played {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.party_competitive_games_played {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.casual_1v1_games_played {
            my_size += ::protobuf::rt::value_size(65, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.competitive_team_games_played {
            my_size += ::protobuf::rt::value_size(66, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            my_size += ::protobuf::rt::value_size(67, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.play_time_points {
            my_size += ::protobuf::rt::value_size(68, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_flags {
            my_size += ::protobuf::rt::value_size(69, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.play_time_level {
            my_size += ::protobuf::rt::value_size(70, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            my_size += ::protobuf::rt::value_size(71, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_behavior_score_last_report {
            my_size += ::protobuf::rt::value_size(72, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_behavior_report_old_data {
            my_size += 3;
        }
        if let Some(v) = self.tourney_skill_level {
            my_size += ::protobuf::rt::value_size(74, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tourney_recent_participation_date {
            my_size += ::protobuf::rt::value_size(85, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favorite_team {
            my_size += ::protobuf::rt::value_size(87, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.anchored_phone_number_id {
            my_size += ::protobuf::rt::value_size(88, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            my_size += ::protobuf::rt::value_size(89, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recent_game_time_1 {
            my_size += ::protobuf::rt::value_size(90, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recent_game_time_2 {
            my_size += ::protobuf::rt::value_size(91, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recent_game_time_3 {
            my_size += ::protobuf::rt::value_size(92, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.general_seasonal_ranked_rank {
            my_size += ::protobuf::rt::value_size(93, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.general_seasonal_ranked_calibration_games_remaining {
            my_size += ::protobuf::rt::value_size(94, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.general_seasonal_ranked_games_played {
            my_size += ::protobuf::rt::value_size(95, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.general_seasonal_ranked_rank_peak {
            my_size += ::protobuf::rt::value_size(96, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.general_seasonal_rank_transferred {
            my_size += 3;
        }
        if let Some(v) = self.solo_seasonal_ranked_rank {
            my_size += ::protobuf::rt::value_size(98, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_seasonal_ranked_calibration_games_remaining {
            my_size += ::protobuf::rt::value_size(99, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_seasonal_ranked_games_played {
            my_size += ::protobuf::rt::value_size(100, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_seasonal_ranked_rank_peak {
            my_size += ::protobuf::rt::value_size(101, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_seasonal_rank_transferred {
            my_size += 3;
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::protobuf::rt::value_size(103, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recent_report_time {
            my_size += ::protobuf::rt::value_size(104, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.xp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.initial_skill {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.leaver_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.secondary_leaver_count {
            os.write_uint32(58, v)?;
        }
        if let Some(v) = self.low_priority_until_date {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.prevent_voice_until_date {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.last_abandoned_game_date {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.leaver_penalty_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.completed_game_streak {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.teaching {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.leadership {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.friendly {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.forgiving {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.account_disabled_until_date {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.account_disabled_count {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.showcase_hero_id {
            os.write_uint32(40, v)?;
        }
        if let Some(v) = self.match_disabled_until_date {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_disabled_count {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.partner_account_type {
            os.write_enum(44, v.value())?;
        }
        if let Some(v) = self.partner_account_state {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.low_priority_games_remaining {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.competitive_rank {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.calibration_games_remaining {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.solo_competitive_rank {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.solo_calibration_games_remaining {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.recruitment_level {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.has_new_notifications {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.is_league_admin {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.casual_games_played {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.solo_competitive_games_played {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.party_competitive_games_played {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.casual_1v1_games_played {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.competitive_team_games_played {
            os.write_uint32(66, v)?;
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.play_time_points {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.account_flags {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.play_time_level {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.player_behavior_score_last_report {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.player_behavior_report_old_data {
            os.write_bool(73, v)?;
        }
        if let Some(v) = self.tourney_skill_level {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.tourney_recent_participation_date {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.favorite_team {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.anchored_phone_number_id {
            os.write_uint64(88, v)?;
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.recent_game_time_1 {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.recent_game_time_2 {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.recent_game_time_3 {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.general_seasonal_ranked_rank {
            os.write_uint32(93, v)?;
        }
        if let Some(v) = self.general_seasonal_ranked_calibration_games_remaining {
            os.write_uint32(94, v)?;
        }
        if let Some(v) = self.general_seasonal_ranked_games_played {
            os.write_uint32(95, v)?;
        }
        if let Some(v) = self.general_seasonal_ranked_rank_peak {
            os.write_uint32(96, v)?;
        }
        if let Some(v) = self.general_seasonal_rank_transferred {
            os.write_bool(97, v)?;
        }
        if let Some(v) = self.solo_seasonal_ranked_rank {
            os.write_uint32(98, v)?;
        }
        if let Some(v) = self.solo_seasonal_ranked_calibration_games_remaining {
            os.write_uint32(99, v)?;
        }
        if let Some(v) = self.solo_seasonal_ranked_games_played {
            os.write_uint32(100, v)?;
        }
        if let Some(v) = self.solo_seasonal_ranked_rank_peak {
            os.write_uint32(101, v)?;
        }
        if let Some(v) = self.solo_seasonal_rank_transferred {
            os.write_bool(102, v)?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(103, v)?;
        }
        if let Some(v) = self.recent_report_time {
            os.write_uint32(104, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSODOTAGameAccountClient {
    fn new() -> CSODOTAGameAccountClient {
        CSODOTAGameAccountClient::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSODOTAGameAccountClient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CSODOTAGameAccountClient::get_account_id_for_reflect,
                    CSODOTAGameAccountClient::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CSODOTAGameAccountClient::get_wins_for_reflect,
                    CSODOTAGameAccountClient::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "losses",
                    CSODOTAGameAccountClient::get_losses_for_reflect,
                    CSODOTAGameAccountClient::mut_losses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp",
                    CSODOTAGameAccountClient::get_xp_for_reflect,
                    CSODOTAGameAccountClient::mut_xp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CSODOTAGameAccountClient::get_level_for_reflect,
                    CSODOTAGameAccountClient::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "initial_skill",
                    CSODOTAGameAccountClient::get_initial_skill_for_reflect,
                    CSODOTAGameAccountClient::mut_initial_skill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leaver_count",
                    CSODOTAGameAccountClient::get_leaver_count_for_reflect,
                    CSODOTAGameAccountClient::mut_leaver_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "secondary_leaver_count",
                    CSODOTAGameAccountClient::get_secondary_leaver_count_for_reflect,
                    CSODOTAGameAccountClient::mut_secondary_leaver_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "low_priority_until_date",
                    CSODOTAGameAccountClient::get_low_priority_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_low_priority_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prevent_text_chat_until_date",
                    CSODOTAGameAccountClient::get_prevent_text_chat_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_prevent_text_chat_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prevent_voice_until_date",
                    CSODOTAGameAccountClient::get_prevent_voice_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_prevent_voice_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prevent_public_text_chat_until_date",
                    CSODOTAGameAccountClient::get_prevent_public_text_chat_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_prevent_public_text_chat_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_abandoned_game_date",
                    CSODOTAGameAccountClient::get_last_abandoned_game_date_for_reflect,
                    CSODOTAGameAccountClient::mut_last_abandoned_game_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_secondary_abandoned_game_date",
                    CSODOTAGameAccountClient::get_last_secondary_abandoned_game_date_for_reflect,
                    CSODOTAGameAccountClient::mut_last_secondary_abandoned_game_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leaver_penalty_count",
                    CSODOTAGameAccountClient::get_leaver_penalty_count_for_reflect,
                    CSODOTAGameAccountClient::mut_leaver_penalty_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "completed_game_streak",
                    CSODOTAGameAccountClient::get_completed_game_streak_for_reflect,
                    CSODOTAGameAccountClient::mut_completed_game_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teaching",
                    CSODOTAGameAccountClient::get_teaching_for_reflect,
                    CSODOTAGameAccountClient::mut_teaching_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leadership",
                    CSODOTAGameAccountClient::get_leadership_for_reflect,
                    CSODOTAGameAccountClient::mut_leadership_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friendly",
                    CSODOTAGameAccountClient::get_friendly_for_reflect,
                    CSODOTAGameAccountClient::mut_friendly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "forgiving",
                    CSODOTAGameAccountClient::get_forgiving_for_reflect,
                    CSODOTAGameAccountClient::mut_forgiving_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_disabled_until_date",
                    CSODOTAGameAccountClient::get_account_disabled_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_account_disabled_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_disabled_count",
                    CSODOTAGameAccountClient::get_account_disabled_count_for_reflect,
                    CSODOTAGameAccountClient::mut_account_disabled_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "showcase_hero_id",
                    CSODOTAGameAccountClient::get_showcase_hero_id_for_reflect,
                    CSODOTAGameAccountClient::mut_showcase_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_disabled_until_date",
                    CSODOTAGameAccountClient::get_match_disabled_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_match_disabled_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_disabled_count",
                    CSODOTAGameAccountClient::get_match_disabled_count_for_reflect,
                    CSODOTAGameAccountClient::mut_match_disabled_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::gcsdk_gcmessages::PartnerAccountType>>(
                    "partner_account_type",
                    CSODOTAGameAccountClient::get_partner_account_type_for_reflect,
                    CSODOTAGameAccountClient::mut_partner_account_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partner_account_state",
                    CSODOTAGameAccountClient::get_partner_account_state_for_reflect,
                    CSODOTAGameAccountClient::mut_partner_account_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shutdownlawterminatetimestamp",
                    CSODOTAGameAccountClient::get_shutdownlawterminatetimestamp_for_reflect,
                    CSODOTAGameAccountClient::mut_shutdownlawterminatetimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "low_priority_games_remaining",
                    CSODOTAGameAccountClient::get_low_priority_games_remaining_for_reflect,
                    CSODOTAGameAccountClient::mut_low_priority_games_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "competitive_rank",
                    CSODOTAGameAccountClient::get_competitive_rank_for_reflect,
                    CSODOTAGameAccountClient::mut_competitive_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "calibration_games_remaining",
                    CSODOTAGameAccountClient::get_calibration_games_remaining_for_reflect,
                    CSODOTAGameAccountClient::mut_calibration_games_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_competitive_rank",
                    CSODOTAGameAccountClient::get_solo_competitive_rank_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_competitive_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_calibration_games_remaining",
                    CSODOTAGameAccountClient::get_solo_calibration_games_remaining_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_calibration_games_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recruitment_level",
                    CSODOTAGameAccountClient::get_recruitment_level_for_reflect,
                    CSODOTAGameAccountClient::mut_recruitment_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_new_notifications",
                    CSODOTAGameAccountClient::get_has_new_notifications_for_reflect,
                    CSODOTAGameAccountClient::mut_has_new_notifications_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_league_admin",
                    CSODOTAGameAccountClient::get_is_league_admin_for_reflect,
                    CSODOTAGameAccountClient::mut_is_league_admin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "casual_games_played",
                    CSODOTAGameAccountClient::get_casual_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_casual_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_competitive_games_played",
                    CSODOTAGameAccountClient::get_solo_competitive_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_competitive_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "party_competitive_games_played",
                    CSODOTAGameAccountClient::get_party_competitive_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_party_competitive_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "casual_1v1_games_played",
                    CSODOTAGameAccountClient::get_casual_1v1_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_casual_1v1_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "competitive_team_games_played",
                    CSODOTAGameAccountClient::get_competitive_team_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_competitive_team_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "curr_all_hero_challenge_id",
                    CSODOTAGameAccountClient::get_curr_all_hero_challenge_id_for_reflect,
                    CSODOTAGameAccountClient::mut_curr_all_hero_challenge_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "play_time_points",
                    CSODOTAGameAccountClient::get_play_time_points_for_reflect,
                    CSODOTAGameAccountClient::mut_play_time_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_flags",
                    CSODOTAGameAccountClient::get_account_flags_for_reflect,
                    CSODOTAGameAccountClient::mut_account_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "play_time_level",
                    CSODOTAGameAccountClient::get_play_time_level_for_reflect,
                    CSODOTAGameAccountClient::mut_play_time_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_behavior_seq_num_last_report",
                    CSODOTAGameAccountClient::get_player_behavior_seq_num_last_report_for_reflect,
                    CSODOTAGameAccountClient::mut_player_behavior_seq_num_last_report_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_behavior_score_last_report",
                    CSODOTAGameAccountClient::get_player_behavior_score_last_report_for_reflect,
                    CSODOTAGameAccountClient::mut_player_behavior_score_last_report_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "player_behavior_report_old_data",
                    CSODOTAGameAccountClient::get_player_behavior_report_old_data_for_reflect,
                    CSODOTAGameAccountClient::mut_player_behavior_report_old_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_skill_level",
                    CSODOTAGameAccountClient::get_tourney_skill_level_for_reflect,
                    CSODOTAGameAccountClient::mut_tourney_skill_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_recent_participation_date",
                    CSODOTAGameAccountClient::get_tourney_recent_participation_date_for_reflect,
                    CSODOTAGameAccountClient::mut_tourney_recent_participation_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "favorite_team",
                    CSODOTAGameAccountClient::get_favorite_team_for_reflect,
                    CSODOTAGameAccountClient::mut_favorite_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "anchored_phone_number_id",
                    CSODOTAGameAccountClient::get_anchored_phone_number_id_for_reflect,
                    CSODOTAGameAccountClient::mut_anchored_phone_number_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ranked_matchmaking_ban_until_date",
                    CSODOTAGameAccountClient::get_ranked_matchmaking_ban_until_date_for_reflect,
                    CSODOTAGameAccountClient::mut_ranked_matchmaking_ban_until_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recent_game_time_1",
                    CSODOTAGameAccountClient::get_recent_game_time_1_for_reflect,
                    CSODOTAGameAccountClient::mut_recent_game_time_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recent_game_time_2",
                    CSODOTAGameAccountClient::get_recent_game_time_2_for_reflect,
                    CSODOTAGameAccountClient::mut_recent_game_time_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recent_game_time_3",
                    CSODOTAGameAccountClient::get_recent_game_time_3_for_reflect,
                    CSODOTAGameAccountClient::mut_recent_game_time_3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "general_seasonal_ranked_rank",
                    CSODOTAGameAccountClient::get_general_seasonal_ranked_rank_for_reflect,
                    CSODOTAGameAccountClient::mut_general_seasonal_ranked_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "general_seasonal_ranked_calibration_games_remaining",
                    CSODOTAGameAccountClient::get_general_seasonal_ranked_calibration_games_remaining_for_reflect,
                    CSODOTAGameAccountClient::mut_general_seasonal_ranked_calibration_games_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "general_seasonal_ranked_games_played",
                    CSODOTAGameAccountClient::get_general_seasonal_ranked_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_general_seasonal_ranked_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "general_seasonal_ranked_rank_peak",
                    CSODOTAGameAccountClient::get_general_seasonal_ranked_rank_peak_for_reflect,
                    CSODOTAGameAccountClient::mut_general_seasonal_ranked_rank_peak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "general_seasonal_rank_transferred",
                    CSODOTAGameAccountClient::get_general_seasonal_rank_transferred_for_reflect,
                    CSODOTAGameAccountClient::mut_general_seasonal_rank_transferred_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_seasonal_ranked_rank",
                    CSODOTAGameAccountClient::get_solo_seasonal_ranked_rank_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_seasonal_ranked_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_seasonal_ranked_calibration_games_remaining",
                    CSODOTAGameAccountClient::get_solo_seasonal_ranked_calibration_games_remaining_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_seasonal_ranked_calibration_games_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_seasonal_ranked_games_played",
                    CSODOTAGameAccountClient::get_solo_seasonal_ranked_games_played_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_seasonal_ranked_games_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "solo_seasonal_ranked_rank_peak",
                    CSODOTAGameAccountClient::get_solo_seasonal_ranked_rank_peak_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_seasonal_ranked_rank_peak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "solo_seasonal_rank_transferred",
                    CSODOTAGameAccountClient::get_solo_seasonal_rank_transferred_for_reflect,
                    CSODOTAGameAccountClient::mut_solo_seasonal_rank_transferred_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "favorite_team_packed",
                    CSODOTAGameAccountClient::get_favorite_team_packed_for_reflect,
                    CSODOTAGameAccountClient::mut_favorite_team_packed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recent_report_time",
                    CSODOTAGameAccountClient::get_recent_report_time_for_reflect,
                    CSODOTAGameAccountClient::mut_recent_report_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSODOTAGameAccountClient>(
                    "CSODOTAGameAccountClient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSODOTAGameAccountClient {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_wins();
        self.clear_losses();
        self.clear_xp();
        self.clear_level();
        self.clear_initial_skill();
        self.clear_leaver_count();
        self.clear_secondary_leaver_count();
        self.clear_low_priority_until_date();
        self.clear_prevent_text_chat_until_date();
        self.clear_prevent_voice_until_date();
        self.clear_prevent_public_text_chat_until_date();
        self.clear_last_abandoned_game_date();
        self.clear_last_secondary_abandoned_game_date();
        self.clear_leaver_penalty_count();
        self.clear_completed_game_streak();
        self.clear_teaching();
        self.clear_leadership();
        self.clear_friendly();
        self.clear_forgiving();
        self.clear_account_disabled_until_date();
        self.clear_account_disabled_count();
        self.clear_showcase_hero_id();
        self.clear_match_disabled_until_date();
        self.clear_match_disabled_count();
        self.clear_partner_account_type();
        self.clear_partner_account_state();
        self.clear_shutdownlawterminatetimestamp();
        self.clear_low_priority_games_remaining();
        self.clear_competitive_rank();
        self.clear_calibration_games_remaining();
        self.clear_solo_competitive_rank();
        self.clear_solo_calibration_games_remaining();
        self.clear_recruitment_level();
        self.clear_has_new_notifications();
        self.clear_is_league_admin();
        self.clear_casual_games_played();
        self.clear_solo_competitive_games_played();
        self.clear_party_competitive_games_played();
        self.clear_casual_1v1_games_played();
        self.clear_competitive_team_games_played();
        self.clear_curr_all_hero_challenge_id();
        self.clear_play_time_points();
        self.clear_account_flags();
        self.clear_play_time_level();
        self.clear_player_behavior_seq_num_last_report();
        self.clear_player_behavior_score_last_report();
        self.clear_player_behavior_report_old_data();
        self.clear_tourney_skill_level();
        self.clear_tourney_recent_participation_date();
        self.clear_favorite_team();
        self.clear_anchored_phone_number_id();
        self.clear_ranked_matchmaking_ban_until_date();
        self.clear_recent_game_time_1();
        self.clear_recent_game_time_2();
        self.clear_recent_game_time_3();
        self.clear_general_seasonal_ranked_rank();
        self.clear_general_seasonal_ranked_calibration_games_remaining();
        self.clear_general_seasonal_ranked_games_played();
        self.clear_general_seasonal_ranked_rank_peak();
        self.clear_general_seasonal_rank_transferred();
        self.clear_solo_seasonal_ranked_rank();
        self.clear_solo_seasonal_ranked_calibration_games_remaining();
        self.clear_solo_seasonal_ranked_games_played();
        self.clear_solo_seasonal_ranked_rank_peak();
        self.clear_solo_seasonal_rank_transferred();
        self.clear_favorite_team_packed();
        self.clear_recent_report_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSODOTAGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAGameAccountClient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLobbyEventPoints {
    // message fields
    event_id: ::std::option::Option<u32>,
    account_points: ::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLobbyEventPoints {}

impl CMsgLobbyEventPoints {
    pub fn new() -> CMsgLobbyEventPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLobbyEventPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLobbyEventPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLobbyEventPoints,
        };
        unsafe {
            instance.get(CMsgLobbyEventPoints::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated .CMsgLobbyEventPoints.AccountPoints account_points = 2;

    pub fn clear_account_points(&mut self) {
        self.account_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_points(&mut self, v: ::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints>) {
        self.account_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_points(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints> {
        &mut self.account_points
    }

    // Take field
    pub fn take_account_points(&mut self) -> ::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints> {
        ::std::mem::replace(&mut self.account_points, ::protobuf::RepeatedField::new())
    }

    pub fn get_account_points(&self) -> &[CMsgLobbyEventPoints_AccountPoints] {
        &self.account_points
    }

    fn get_account_points_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints> {
        &self.account_points
    }

    fn mut_account_points_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLobbyEventPoints_AccountPoints> {
        &mut self.account_points
    }
}

impl ::protobuf::Message for CMsgLobbyEventPoints {
    fn is_initialized(&self) -> bool {
        for v in &self.account_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_points {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLobbyEventPoints {
    fn new() -> CMsgLobbyEventPoints {
        CMsgLobbyEventPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLobbyEventPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgLobbyEventPoints::get_event_id_for_reflect,
                    CMsgLobbyEventPoints::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLobbyEventPoints_AccountPoints>>(
                    "account_points",
                    CMsgLobbyEventPoints::get_account_points_for_reflect,
                    CMsgLobbyEventPoints::mut_account_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLobbyEventPoints>(
                    "CMsgLobbyEventPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLobbyEventPoints {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_account_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLobbyEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyEventPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLobbyEventPoints_ChatWheelMessageRange {
    // message fields
    message_id_start: ::std::option::Option<u32>,
    message_id_end: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLobbyEventPoints_ChatWheelMessageRange {}

impl CMsgLobbyEventPoints_ChatWheelMessageRange {
    pub fn new() -> CMsgLobbyEventPoints_ChatWheelMessageRange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLobbyEventPoints_ChatWheelMessageRange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLobbyEventPoints_ChatWheelMessageRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLobbyEventPoints_ChatWheelMessageRange,
        };
        unsafe {
            instance.get(CMsgLobbyEventPoints_ChatWheelMessageRange::new)
        }
    }

    // optional uint32 message_id_start = 1;

    pub fn clear_message_id_start(&mut self) {
        self.message_id_start = ::std::option::Option::None;
    }

    pub fn has_message_id_start(&self) -> bool {
        self.message_id_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id_start(&mut self, v: u32) {
        self.message_id_start = ::std::option::Option::Some(v);
    }

    pub fn get_message_id_start(&self) -> u32 {
        self.message_id_start.unwrap_or(0)
    }

    fn get_message_id_start_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.message_id_start
    }

    fn mut_message_id_start_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.message_id_start
    }

    // optional uint32 message_id_end = 2;

    pub fn clear_message_id_end(&mut self) {
        self.message_id_end = ::std::option::Option::None;
    }

    pub fn has_message_id_end(&self) -> bool {
        self.message_id_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id_end(&mut self, v: u32) {
        self.message_id_end = ::std::option::Option::Some(v);
    }

    pub fn get_message_id_end(&self) -> u32 {
        self.message_id_end.unwrap_or(0)
    }

    fn get_message_id_end_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.message_id_end
    }

    fn mut_message_id_end_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.message_id_end
    }
}

impl ::protobuf::Message for CMsgLobbyEventPoints_ChatWheelMessageRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_id_start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_id_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message_id_start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message_id_end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message_id_start {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_id_end {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLobbyEventPoints_ChatWheelMessageRange {
    fn new() -> CMsgLobbyEventPoints_ChatWheelMessageRange {
        CMsgLobbyEventPoints_ChatWheelMessageRange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLobbyEventPoints_ChatWheelMessageRange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "message_id_start",
                    CMsgLobbyEventPoints_ChatWheelMessageRange::get_message_id_start_for_reflect,
                    CMsgLobbyEventPoints_ChatWheelMessageRange::mut_message_id_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "message_id_end",
                    CMsgLobbyEventPoints_ChatWheelMessageRange::get_message_id_end_for_reflect,
                    CMsgLobbyEventPoints_ChatWheelMessageRange::mut_message_id_end_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLobbyEventPoints_ChatWheelMessageRange>(
                    "CMsgLobbyEventPoints_ChatWheelMessageRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLobbyEventPoints_ChatWheelMessageRange {
    fn clear(&mut self) {
        self.clear_message_id_start();
        self.clear_message_id_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLobbyEventPoints_ChatWheelMessageRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyEventPoints_ChatWheelMessageRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLobbyEventPoints_AccountPoints {
    // message fields
    account_id: ::std::option::Option<u32>,
    normal_points: ::std::option::Option<u32>,
    premium_points: ::std::option::Option<u32>,
    owned: ::std::option::Option<bool>,
    favorite_team: ::std::option::Option<u32>,
    favorite_team_level: ::std::option::Option<u32>,
    points_held: ::std::option::Option<u32>,
    premium_points_held: ::std::option::Option<u32>,
    favorite_team_foil_level: ::std::option::Option<u32>,
    wager_tokens_remaining: ::std::option::Option<u32>,
    wager_tokens_max: ::std::option::Option<u32>,
    active_effects_mask: ::std::option::Option<u64>,
    unlocked_chat_wheel_message_ranges: ::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange>,
    rank_wager_tokens_remaining: ::std::option::Option<u32>,
    rank_wager_tokens_max: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLobbyEventPoints_AccountPoints {}

impl CMsgLobbyEventPoints_AccountPoints {
    pub fn new() -> CMsgLobbyEventPoints_AccountPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLobbyEventPoints_AccountPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLobbyEventPoints_AccountPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLobbyEventPoints_AccountPoints,
        };
        unsafe {
            instance.get(CMsgLobbyEventPoints_AccountPoints::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 normal_points = 2;

    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    pub fn get_normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }

    fn get_normal_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.normal_points
    }

    fn mut_normal_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.normal_points
    }

    // optional uint32 premium_points = 3;

    pub fn clear_premium_points(&mut self) {
        self.premium_points = ::std::option::Option::None;
    }

    pub fn has_premium_points(&self) -> bool {
        self.premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points(&mut self, v: u32) {
        self.premium_points = ::std::option::Option::Some(v);
    }

    pub fn get_premium_points(&self) -> u32 {
        self.premium_points.unwrap_or(0)
    }

    fn get_premium_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.premium_points
    }

    fn mut_premium_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.premium_points
    }

    // optional bool owned = 4;

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    pub fn get_owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    fn get_owned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.owned
    }

    fn mut_owned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.owned
    }

    // optional uint32 favorite_team = 5;

    pub fn clear_favorite_team(&mut self) {
        self.favorite_team = ::std::option::Option::None;
    }

    pub fn has_favorite_team(&self) -> bool {
        self.favorite_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team(&mut self, v: u32) {
        self.favorite_team = ::std::option::Option::Some(v);
    }

    pub fn get_favorite_team(&self) -> u32 {
        self.favorite_team.unwrap_or(0)
    }

    fn get_favorite_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.favorite_team
    }

    fn mut_favorite_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.favorite_team
    }

    // optional uint32 favorite_team_level = 6;

    pub fn clear_favorite_team_level(&mut self) {
        self.favorite_team_level = ::std::option::Option::None;
    }

    pub fn has_favorite_team_level(&self) -> bool {
        self.favorite_team_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_level(&mut self, v: u32) {
        self.favorite_team_level = ::std::option::Option::Some(v);
    }

    pub fn get_favorite_team_level(&self) -> u32 {
        self.favorite_team_level.unwrap_or(0)
    }

    fn get_favorite_team_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.favorite_team_level
    }

    fn mut_favorite_team_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.favorite_team_level
    }

    // optional uint32 points_held = 7;

    pub fn clear_points_held(&mut self) {
        self.points_held = ::std::option::Option::None;
    }

    pub fn has_points_held(&self) -> bool {
        self.points_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_held(&mut self, v: u32) {
        self.points_held = ::std::option::Option::Some(v);
    }

    pub fn get_points_held(&self) -> u32 {
        self.points_held.unwrap_or(0)
    }

    fn get_points_held_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_held
    }

    fn mut_points_held_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_held
    }

    // optional uint32 premium_points_held = 8;

    pub fn clear_premium_points_held(&mut self) {
        self.premium_points_held = ::std::option::Option::None;
    }

    pub fn has_premium_points_held(&self) -> bool {
        self.premium_points_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points_held(&mut self, v: u32) {
        self.premium_points_held = ::std::option::Option::Some(v);
    }

    pub fn get_premium_points_held(&self) -> u32 {
        self.premium_points_held.unwrap_or(0)
    }

    fn get_premium_points_held_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.premium_points_held
    }

    fn mut_premium_points_held_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.premium_points_held
    }

    // optional uint32 favorite_team_foil_level = 9;

    pub fn clear_favorite_team_foil_level(&mut self) {
        self.favorite_team_foil_level = ::std::option::Option::None;
    }

    pub fn has_favorite_team_foil_level(&self) -> bool {
        self.favorite_team_foil_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_foil_level(&mut self, v: u32) {
        self.favorite_team_foil_level = ::std::option::Option::Some(v);
    }

    pub fn get_favorite_team_foil_level(&self) -> u32 {
        self.favorite_team_foil_level.unwrap_or(0)
    }

    fn get_favorite_team_foil_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.favorite_team_foil_level
    }

    fn mut_favorite_team_foil_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.favorite_team_foil_level
    }

    // optional uint32 wager_tokens_remaining = 10;

    pub fn clear_wager_tokens_remaining(&mut self) {
        self.wager_tokens_remaining = ::std::option::Option::None;
    }

    pub fn has_wager_tokens_remaining(&self) -> bool {
        self.wager_tokens_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_tokens_remaining(&mut self, v: u32) {
        self.wager_tokens_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_wager_tokens_remaining(&self) -> u32 {
        self.wager_tokens_remaining.unwrap_or(0)
    }

    fn get_wager_tokens_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wager_tokens_remaining
    }

    fn mut_wager_tokens_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wager_tokens_remaining
    }

    // optional uint32 wager_tokens_max = 11;

    pub fn clear_wager_tokens_max(&mut self) {
        self.wager_tokens_max = ::std::option::Option::None;
    }

    pub fn has_wager_tokens_max(&self) -> bool {
        self.wager_tokens_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_tokens_max(&mut self, v: u32) {
        self.wager_tokens_max = ::std::option::Option::Some(v);
    }

    pub fn get_wager_tokens_max(&self) -> u32 {
        self.wager_tokens_max.unwrap_or(0)
    }

    fn get_wager_tokens_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wager_tokens_max
    }

    fn mut_wager_tokens_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wager_tokens_max
    }

    // optional uint64 active_effects_mask = 12;

    pub fn clear_active_effects_mask(&mut self) {
        self.active_effects_mask = ::std::option::Option::None;
    }

    pub fn has_active_effects_mask(&self) -> bool {
        self.active_effects_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_effects_mask(&mut self, v: u64) {
        self.active_effects_mask = ::std::option::Option::Some(v);
    }

    pub fn get_active_effects_mask(&self) -> u64 {
        self.active_effects_mask.unwrap_or(0)
    }

    fn get_active_effects_mask_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.active_effects_mask
    }

    fn mut_active_effects_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.active_effects_mask
    }

    // repeated .CMsgLobbyEventPoints.ChatWheelMessageRange unlocked_chat_wheel_message_ranges = 13;

    pub fn clear_unlocked_chat_wheel_message_ranges(&mut self) {
        self.unlocked_chat_wheel_message_ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_chat_wheel_message_ranges(&mut self, v: ::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange>) {
        self.unlocked_chat_wheel_message_ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_chat_wheel_message_ranges(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange> {
        &mut self.unlocked_chat_wheel_message_ranges
    }

    // Take field
    pub fn take_unlocked_chat_wheel_message_ranges(&mut self) -> ::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange> {
        ::std::mem::replace(&mut self.unlocked_chat_wheel_message_ranges, ::protobuf::RepeatedField::new())
    }

    pub fn get_unlocked_chat_wheel_message_ranges(&self) -> &[CMsgLobbyEventPoints_ChatWheelMessageRange] {
        &self.unlocked_chat_wheel_message_ranges
    }

    fn get_unlocked_chat_wheel_message_ranges_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange> {
        &self.unlocked_chat_wheel_message_ranges
    }

    fn mut_unlocked_chat_wheel_message_ranges_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLobbyEventPoints_ChatWheelMessageRange> {
        &mut self.unlocked_chat_wheel_message_ranges
    }

    // optional uint32 rank_wager_tokens_remaining = 14;

    pub fn clear_rank_wager_tokens_remaining(&mut self) {
        self.rank_wager_tokens_remaining = ::std::option::Option::None;
    }

    pub fn has_rank_wager_tokens_remaining(&self) -> bool {
        self.rank_wager_tokens_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wager_tokens_remaining(&mut self, v: u32) {
        self.rank_wager_tokens_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_rank_wager_tokens_remaining(&self) -> u32 {
        self.rank_wager_tokens_remaining.unwrap_or(0)
    }

    fn get_rank_wager_tokens_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_wager_tokens_remaining
    }

    fn mut_rank_wager_tokens_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_wager_tokens_remaining
    }

    // optional uint32 rank_wager_tokens_max = 15;

    pub fn clear_rank_wager_tokens_max(&mut self) {
        self.rank_wager_tokens_max = ::std::option::Option::None;
    }

    pub fn has_rank_wager_tokens_max(&self) -> bool {
        self.rank_wager_tokens_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wager_tokens_max(&mut self, v: u32) {
        self.rank_wager_tokens_max = ::std::option::Option::Some(v);
    }

    pub fn get_rank_wager_tokens_max(&self) -> u32 {
        self.rank_wager_tokens_max.unwrap_or(0)
    }

    fn get_rank_wager_tokens_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_wager_tokens_max
    }

    fn mut_rank_wager_tokens_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_wager_tokens_max
    }
}

impl ::protobuf::Message for CMsgLobbyEventPoints_AccountPoints {
    fn is_initialized(&self) -> bool {
        for v in &self.unlocked_chat_wheel_message_ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.normal_points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.premium_points = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owned = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.favorite_team = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.favorite_team_level = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_held = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.premium_points_held = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.favorite_team_foil_level = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wager_tokens_remaining = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wager_tokens_max = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.active_effects_mask = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_chat_wheel_message_ranges)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_wager_tokens_remaining = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_wager_tokens_max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owned {
            my_size += 2;
        }
        if let Some(v) = self.favorite_team {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favorite_team_level {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_held {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_points_held {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favorite_team_foil_level {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager_tokens_remaining {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager_tokens_max {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_effects_mask {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unlocked_chat_wheel_message_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.rank_wager_tokens_remaining {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_wager_tokens_max {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.favorite_team {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.favorite_team_level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_held {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.premium_points_held {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.favorite_team_foil_level {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.wager_tokens_remaining {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.wager_tokens_max {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.active_effects_mask {
            os.write_uint64(12, v)?;
        }
        for v in &self.unlocked_chat_wheel_message_ranges {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.rank_wager_tokens_remaining {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.rank_wager_tokens_max {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLobbyEventPoints_AccountPoints {
    fn new() -> CMsgLobbyEventPoints_AccountPoints {
        CMsgLobbyEventPoints_AccountPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLobbyEventPoints_AccountPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgLobbyEventPoints_AccountPoints::get_account_id_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "normal_points",
                    CMsgLobbyEventPoints_AccountPoints::get_normal_points_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_normal_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "premium_points",
                    CMsgLobbyEventPoints_AccountPoints::get_premium_points_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_premium_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "owned",
                    CMsgLobbyEventPoints_AccountPoints::get_owned_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_owned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "favorite_team",
                    CMsgLobbyEventPoints_AccountPoints::get_favorite_team_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_favorite_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "favorite_team_level",
                    CMsgLobbyEventPoints_AccountPoints::get_favorite_team_level_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_favorite_team_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_held",
                    CMsgLobbyEventPoints_AccountPoints::get_points_held_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_points_held_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "premium_points_held",
                    CMsgLobbyEventPoints_AccountPoints::get_premium_points_held_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_premium_points_held_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "favorite_team_foil_level",
                    CMsgLobbyEventPoints_AccountPoints::get_favorite_team_foil_level_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_favorite_team_foil_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wager_tokens_remaining",
                    CMsgLobbyEventPoints_AccountPoints::get_wager_tokens_remaining_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_wager_tokens_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wager_tokens_max",
                    CMsgLobbyEventPoints_AccountPoints::get_wager_tokens_max_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_wager_tokens_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "active_effects_mask",
                    CMsgLobbyEventPoints_AccountPoints::get_active_effects_mask_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_active_effects_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLobbyEventPoints_ChatWheelMessageRange>>(
                    "unlocked_chat_wheel_message_ranges",
                    CMsgLobbyEventPoints_AccountPoints::get_unlocked_chat_wheel_message_ranges_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_unlocked_chat_wheel_message_ranges_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_wager_tokens_remaining",
                    CMsgLobbyEventPoints_AccountPoints::get_rank_wager_tokens_remaining_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_rank_wager_tokens_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_wager_tokens_max",
                    CMsgLobbyEventPoints_AccountPoints::get_rank_wager_tokens_max_for_reflect,
                    CMsgLobbyEventPoints_AccountPoints::mut_rank_wager_tokens_max_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLobbyEventPoints_AccountPoints>(
                    "CMsgLobbyEventPoints_AccountPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLobbyEventPoints_AccountPoints {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_normal_points();
        self.clear_premium_points();
        self.clear_owned();
        self.clear_favorite_team();
        self.clear_favorite_team_level();
        self.clear_points_held();
        self.clear_premium_points_held();
        self.clear_favorite_team_foil_level();
        self.clear_wager_tokens_remaining();
        self.clear_wager_tokens_max();
        self.clear_active_effects_mask();
        self.clear_unlocked_chat_wheel_message_ranges();
        self.clear_rank_wager_tokens_remaining();
        self.clear_rank_wager_tokens_max();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLobbyEventPoints_AccountPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyEventPoints_AccountPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgBattleCupVictory {
    // message fields
    account_id: ::std::option::Option<u32>,
    win_date: ::std::option::Option<u32>,
    valid_until: ::std::option::Option<u32>,
    skill_level: ::std::option::Option<u32>,
    tournament_id: ::std::option::Option<u32>,
    division_id: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    streak: ::std::option::Option<u32>,
    trophy_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgBattleCupVictory {}

impl CMsgBattleCupVictory {
    pub fn new() -> CMsgBattleCupVictory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgBattleCupVictory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBattleCupVictory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBattleCupVictory,
        };
        unsafe {
            instance.get(CMsgBattleCupVictory::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 win_date = 2;

    pub fn clear_win_date(&mut self) {
        self.win_date = ::std::option::Option::None;
    }

    pub fn has_win_date(&self) -> bool {
        self.win_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_date(&mut self, v: u32) {
        self.win_date = ::std::option::Option::Some(v);
    }

    pub fn get_win_date(&self) -> u32 {
        self.win_date.unwrap_or(0)
    }

    fn get_win_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.win_date
    }

    fn mut_win_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.win_date
    }

    // optional uint32 valid_until = 3;

    pub fn clear_valid_until(&mut self) {
        self.valid_until = ::std::option::Option::None;
    }

    pub fn has_valid_until(&self) -> bool {
        self.valid_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid_until(&mut self, v: u32) {
        self.valid_until = ::std::option::Option::Some(v);
    }

    pub fn get_valid_until(&self) -> u32 {
        self.valid_until.unwrap_or(0)
    }

    fn get_valid_until_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.valid_until
    }

    fn mut_valid_until_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.valid_until
    }

    // optional uint32 skill_level = 4;

    pub fn clear_skill_level(&mut self) {
        self.skill_level = ::std::option::Option::None;
    }

    pub fn has_skill_level(&self) -> bool {
        self.skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_level(&mut self, v: u32) {
        self.skill_level = ::std::option::Option::Some(v);
    }

    pub fn get_skill_level(&self) -> u32 {
        self.skill_level.unwrap_or(0)
    }

    fn get_skill_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.skill_level
    }

    fn mut_skill_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.skill_level
    }

    // optional uint32 tournament_id = 5;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    fn get_tournament_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_id
    }

    fn mut_tournament_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_id
    }

    // optional uint32 division_id = 6;

    pub fn clear_division_id(&mut self) {
        self.division_id = ::std::option::Option::None;
    }

    pub fn has_division_id(&self) -> bool {
        self.division_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_division_id(&mut self, v: u32) {
        self.division_id = ::std::option::Option::Some(v);
    }

    pub fn get_division_id(&self) -> u32 {
        self.division_id.unwrap_or(0)
    }

    fn get_division_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.division_id
    }

    fn mut_division_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.division_id
    }

    // optional uint32 team_id = 7;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional uint32 streak = 8;

    pub fn clear_streak(&mut self) {
        self.streak = ::std::option::Option::None;
    }

    pub fn has_streak(&self) -> bool {
        self.streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streak(&mut self, v: u32) {
        self.streak = ::std::option::Option::Some(v);
    }

    pub fn get_streak(&self) -> u32 {
        self.streak.unwrap_or(0)
    }

    fn get_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.streak
    }

    fn mut_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.streak
    }

    // optional uint32 trophy_id = 9;

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    fn get_trophy_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_id
    }

    fn mut_trophy_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_id
    }
}

impl ::protobuf::Message for CMsgBattleCupVictory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.win_date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.valid_until = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skill_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.division_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.streak = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.win_date {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.valid_until {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skill_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.division_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.streak {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trophy_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.win_date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.valid_until {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.skill_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.division_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.streak {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.trophy_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgBattleCupVictory {
    fn new() -> CMsgBattleCupVictory {
        CMsgBattleCupVictory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgBattleCupVictory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgBattleCupVictory::get_account_id_for_reflect,
                    CMsgBattleCupVictory::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "win_date",
                    CMsgBattleCupVictory::get_win_date_for_reflect,
                    CMsgBattleCupVictory::mut_win_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "valid_until",
                    CMsgBattleCupVictory::get_valid_until_for_reflect,
                    CMsgBattleCupVictory::mut_valid_until_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "skill_level",
                    CMsgBattleCupVictory::get_skill_level_for_reflect,
                    CMsgBattleCupVictory::mut_skill_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_id",
                    CMsgBattleCupVictory::get_tournament_id_for_reflect,
                    CMsgBattleCupVictory::mut_tournament_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "division_id",
                    CMsgBattleCupVictory::get_division_id_for_reflect,
                    CMsgBattleCupVictory::mut_division_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgBattleCupVictory::get_team_id_for_reflect,
                    CMsgBattleCupVictory::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "streak",
                    CMsgBattleCupVictory::get_streak_for_reflect,
                    CMsgBattleCupVictory::mut_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_id",
                    CMsgBattleCupVictory::get_trophy_id_for_reflect,
                    CMsgBattleCupVictory::mut_trophy_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBattleCupVictory>(
                    "CMsgBattleCupVictory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgBattleCupVictory {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_win_date();
        self.clear_valid_until();
        self.clear_skill_level();
        self.clear_tournament_id();
        self.clear_division_id();
        self.clear_team_id();
        self.clear_streak();
        self.clear_trophy_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBattleCupVictory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBattleCupVictory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLobbyBattleCupVictoryList {
    // message fields
    winners: ::protobuf::RepeatedField<CMsgBattleCupVictory>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLobbyBattleCupVictoryList {}

impl CMsgLobbyBattleCupVictoryList {
    pub fn new() -> CMsgLobbyBattleCupVictoryList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLobbyBattleCupVictoryList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLobbyBattleCupVictoryList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLobbyBattleCupVictoryList,
        };
        unsafe {
            instance.get(CMsgLobbyBattleCupVictoryList::new)
        }
    }

    // repeated .CMsgBattleCupVictory winners = 1;

    pub fn clear_winners(&mut self) {
        self.winners.clear();
    }

    // Param is passed by value, moved
    pub fn set_winners(&mut self, v: ::protobuf::RepeatedField<CMsgBattleCupVictory>) {
        self.winners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_winners(&mut self) -> &mut ::protobuf::RepeatedField<CMsgBattleCupVictory> {
        &mut self.winners
    }

    // Take field
    pub fn take_winners(&mut self) -> ::protobuf::RepeatedField<CMsgBattleCupVictory> {
        ::std::mem::replace(&mut self.winners, ::protobuf::RepeatedField::new())
    }

    pub fn get_winners(&self) -> &[CMsgBattleCupVictory] {
        &self.winners
    }

    fn get_winners_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgBattleCupVictory> {
        &self.winners
    }

    fn mut_winners_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgBattleCupVictory> {
        &mut self.winners
    }
}

impl ::protobuf::Message for CMsgLobbyBattleCupVictoryList {
    fn is_initialized(&self) -> bool {
        for v in &self.winners {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.winners)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.winners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.winners {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLobbyBattleCupVictoryList {
    fn new() -> CMsgLobbyBattleCupVictoryList {
        CMsgLobbyBattleCupVictoryList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLobbyBattleCupVictoryList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgBattleCupVictory>>(
                    "winners",
                    CMsgLobbyBattleCupVictoryList::get_winners_for_reflect,
                    CMsgLobbyBattleCupVictoryList::mut_winners_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLobbyBattleCupVictoryList>(
                    "CMsgLobbyBattleCupVictoryList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLobbyBattleCupVictoryList {
    fn clear(&mut self) {
        self.clear_winners();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLobbyBattleCupVictoryList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLobbyBattleCupVictoryList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTABroadcastNotification {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTABroadcastNotification {}

impl CMsgDOTABroadcastNotification {
    pub fn new() -> CMsgDOTABroadcastNotification {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTABroadcastNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTABroadcastNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTABroadcastNotification,
        };
        unsafe {
            instance.get(CMsgDOTABroadcastNotification::new)
        }
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for CMsgDOTABroadcastNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTABroadcastNotification {
    fn new() -> CMsgDOTABroadcastNotification {
        CMsgDOTABroadcastNotification::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTABroadcastNotification>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CMsgDOTABroadcastNotification::get_message_for_reflect,
                    CMsgDOTABroadcastNotification::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTABroadcastNotification>(
                    "CMsgDOTABroadcastNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTABroadcastNotification {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTABroadcastNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABroadcastNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemHeroStatue {
    // message fields
    hero_id: ::std::option::Option<u32>,
    status_effect_index: ::std::option::Option<u32>,
    sequence_name: ::protobuf::SingularField<::std::string::String>,
    cycle: ::std::option::Option<f32>,
    wearable: ::std::vec::Vec<u32>,
    inscription: ::protobuf::SingularField<::std::string::String>,
    style: ::std::vec::Vec<u32>,
    tournament_drop: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemHeroStatue {}

impl CProtoItemHeroStatue {
    pub fn new() -> CProtoItemHeroStatue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemHeroStatue {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemHeroStatue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemHeroStatue,
        };
        unsafe {
            instance.get(CProtoItemHeroStatue::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 status_effect_index = 2;

    pub fn clear_status_effect_index(&mut self) {
        self.status_effect_index = ::std::option::Option::None;
    }

    pub fn has_status_effect_index(&self) -> bool {
        self.status_effect_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_effect_index(&mut self, v: u32) {
        self.status_effect_index = ::std::option::Option::Some(v);
    }

    pub fn get_status_effect_index(&self) -> u32 {
        self.status_effect_index.unwrap_or(0)
    }

    fn get_status_effect_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.status_effect_index
    }

    fn mut_status_effect_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.status_effect_index
    }

    // optional string sequence_name = 3;

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name.clear();
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name.set_default();
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sequence_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sequence_name
    }

    fn mut_sequence_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sequence_name
    }

    // optional float cycle = 4;

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    pub fn get_cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    fn get_cycle_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cycle
    }

    fn mut_cycle_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cycle
    }

    // repeated uint32 wearable = 5;

    pub fn clear_wearable(&mut self) {
        self.wearable.clear();
    }

    // Param is passed by value, moved
    pub fn set_wearable(&mut self, v: ::std::vec::Vec<u32>) {
        self.wearable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wearable(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearable
    }

    // Take field
    pub fn take_wearable(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.wearable, ::std::vec::Vec::new())
    }

    pub fn get_wearable(&self) -> &[u32] {
        &self.wearable
    }

    fn get_wearable_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.wearable
    }

    fn mut_wearable_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearable
    }

    // optional string inscription = 6;

    pub fn clear_inscription(&mut self) {
        self.inscription.clear();
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription.set_default();
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_inscription_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.inscription
    }

    fn mut_inscription_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.inscription
    }

    // repeated uint32 style = 7;

    pub fn clear_style(&mut self) {
        self.style.clear();
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: ::std::vec::Vec<u32>) {
        self.style = v;
    }

    // Mutable pointer to the field.
    pub fn mut_style(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.style
    }

    // Take field
    pub fn take_style(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.style, ::std::vec::Vec::new())
    }

    pub fn get_style(&self) -> &[u32] {
        &self.style
    }

    fn get_style_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.style
    }

    fn mut_style_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.style
    }

    // optional bool tournament_drop = 8;

    pub fn clear_tournament_drop(&mut self) {
        self.tournament_drop = ::std::option::Option::None;
    }

    pub fn has_tournament_drop(&self) -> bool {
        self.tournament_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_drop(&mut self, v: bool) {
        self.tournament_drop = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_drop(&self) -> bool {
        self.tournament_drop.unwrap_or(false)
    }

    fn get_tournament_drop_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tournament_drop
    }

    fn mut_tournament_drop_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tournament_drop
    }
}

impl ::protobuf::Message for CProtoItemHeroStatue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_effect_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequence_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cycle = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.wearable)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inscription)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.style)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tournament_drop = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status_effect_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 5;
        }
        for value in &self.wearable {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.inscription.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.style {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.tournament_drop {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status_effect_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(4, v)?;
        }
        for v in &self.wearable {
            os.write_uint32(5, *v)?;
        };
        if let Some(ref v) = self.inscription.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.style {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.tournament_drop {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemHeroStatue {
    fn new() -> CProtoItemHeroStatue {
        CProtoItemHeroStatue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemHeroStatue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CProtoItemHeroStatue::get_hero_id_for_reflect,
                    CProtoItemHeroStatue::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status_effect_index",
                    CProtoItemHeroStatue::get_status_effect_index_for_reflect,
                    CProtoItemHeroStatue::mut_status_effect_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sequence_name",
                    CProtoItemHeroStatue::get_sequence_name_for_reflect,
                    CProtoItemHeroStatue::mut_sequence_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cycle",
                    CProtoItemHeroStatue::get_cycle_for_reflect,
                    CProtoItemHeroStatue::mut_cycle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wearable",
                    CProtoItemHeroStatue::get_wearable_for_reflect,
                    CProtoItemHeroStatue::mut_wearable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "inscription",
                    CProtoItemHeroStatue::get_inscription_for_reflect,
                    CProtoItemHeroStatue::mut_inscription_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style",
                    CProtoItemHeroStatue::get_style_for_reflect,
                    CProtoItemHeroStatue::mut_style_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tournament_drop",
                    CProtoItemHeroStatue::get_tournament_drop_for_reflect,
                    CProtoItemHeroStatue::mut_tournament_drop_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemHeroStatue>(
                    "CProtoItemHeroStatue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemHeroStatue {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_status_effect_index();
        self.clear_sequence_name();
        self.clear_cycle();
        self.clear_wearable();
        self.clear_inscription();
        self.clear_style();
        self.clear_tournament_drop();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemHeroStatue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemHeroStatue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemTeamShowcase {
    // message fields
    hero_id: ::std::option::Option<u32>,
    status_effect_index: ::std::option::Option<u32>,
    sequence_name: ::protobuf::SingularField<::std::string::String>,
    cycle: ::std::option::Option<f32>,
    wearable: ::std::vec::Vec<u32>,
    inscription: ::protobuf::SingularField<::std::string::String>,
    style: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemTeamShowcase {}

impl CProtoItemTeamShowcase {
    pub fn new() -> CProtoItemTeamShowcase {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemTeamShowcase {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemTeamShowcase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemTeamShowcase,
        };
        unsafe {
            instance.get(CProtoItemTeamShowcase::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 status_effect_index = 2;

    pub fn clear_status_effect_index(&mut self) {
        self.status_effect_index = ::std::option::Option::None;
    }

    pub fn has_status_effect_index(&self) -> bool {
        self.status_effect_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_effect_index(&mut self, v: u32) {
        self.status_effect_index = ::std::option::Option::Some(v);
    }

    pub fn get_status_effect_index(&self) -> u32 {
        self.status_effect_index.unwrap_or(0)
    }

    fn get_status_effect_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.status_effect_index
    }

    fn mut_status_effect_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.status_effect_index
    }

    // optional string sequence_name = 3;

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name.clear();
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name.set_default();
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sequence_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sequence_name
    }

    fn mut_sequence_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sequence_name
    }

    // optional float cycle = 4;

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    pub fn get_cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    fn get_cycle_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cycle
    }

    fn mut_cycle_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cycle
    }

    // repeated uint32 wearable = 5;

    pub fn clear_wearable(&mut self) {
        self.wearable.clear();
    }

    // Param is passed by value, moved
    pub fn set_wearable(&mut self, v: ::std::vec::Vec<u32>) {
        self.wearable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wearable(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearable
    }

    // Take field
    pub fn take_wearable(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.wearable, ::std::vec::Vec::new())
    }

    pub fn get_wearable(&self) -> &[u32] {
        &self.wearable
    }

    fn get_wearable_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.wearable
    }

    fn mut_wearable_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearable
    }

    // optional string inscription = 6;

    pub fn clear_inscription(&mut self) {
        self.inscription.clear();
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription.set_default();
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_inscription_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.inscription
    }

    fn mut_inscription_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.inscription
    }

    // repeated uint32 style = 7;

    pub fn clear_style(&mut self) {
        self.style.clear();
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: ::std::vec::Vec<u32>) {
        self.style = v;
    }

    // Mutable pointer to the field.
    pub fn mut_style(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.style
    }

    // Take field
    pub fn take_style(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.style, ::std::vec::Vec::new())
    }

    pub fn get_style(&self) -> &[u32] {
        &self.style
    }

    fn get_style_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.style
    }

    fn mut_style_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.style
    }
}

impl ::protobuf::Message for CProtoItemTeamShowcase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_effect_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequence_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cycle = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.wearable)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inscription)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.style)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status_effect_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 5;
        }
        for value in &self.wearable {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.inscription.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.style {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status_effect_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(4, v)?;
        }
        for v in &self.wearable {
            os.write_uint32(5, *v)?;
        };
        if let Some(ref v) = self.inscription.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.style {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemTeamShowcase {
    fn new() -> CProtoItemTeamShowcase {
        CProtoItemTeamShowcase::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemTeamShowcase>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CProtoItemTeamShowcase::get_hero_id_for_reflect,
                    CProtoItemTeamShowcase::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status_effect_index",
                    CProtoItemTeamShowcase::get_status_effect_index_for_reflect,
                    CProtoItemTeamShowcase::mut_status_effect_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sequence_name",
                    CProtoItemTeamShowcase::get_sequence_name_for_reflect,
                    CProtoItemTeamShowcase::mut_sequence_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cycle",
                    CProtoItemTeamShowcase::get_cycle_for_reflect,
                    CProtoItemTeamShowcase::mut_cycle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wearable",
                    CProtoItemTeamShowcase::get_wearable_for_reflect,
                    CProtoItemTeamShowcase::mut_wearable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "inscription",
                    CProtoItemTeamShowcase::get_inscription_for_reflect,
                    CProtoItemTeamShowcase::mut_inscription_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style",
                    CProtoItemTeamShowcase::get_style_for_reflect,
                    CProtoItemTeamShowcase::mut_style_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemTeamShowcase>(
                    "CProtoItemTeamShowcase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemTeamShowcase {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_status_effect_index();
        self.clear_sequence_name();
        self.clear_cycle();
        self.clear_wearable();
        self.clear_inscription();
        self.clear_style();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemTeamShowcase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemTeamShowcase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMatchPlayerAbilityUpgrade {
    // message fields
    ability: ::std::option::Option<u32>,
    time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMatchPlayerAbilityUpgrade {}

impl CMatchPlayerAbilityUpgrade {
    pub fn new() -> CMatchPlayerAbilityUpgrade {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMatchPlayerAbilityUpgrade {
        static mut instance: ::protobuf::lazy::Lazy<CMatchPlayerAbilityUpgrade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMatchPlayerAbilityUpgrade,
        };
        unsafe {
            instance.get(CMatchPlayerAbilityUpgrade::new)
        }
    }

    // optional uint32 ability = 1;

    pub fn clear_ability(&mut self) {
        self.ability = ::std::option::Option::None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: u32) {
        self.ability = ::std::option::Option::Some(v);
    }

    pub fn get_ability(&self) -> u32 {
        self.ability.unwrap_or(0)
    }

    fn get_ability_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability
    }

    fn mut_ability_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability
    }

    // optional uint32 time = 2;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time
    }
}

impl ::protobuf::Message for CMatchPlayerAbilityUpgrade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMatchPlayerAbilityUpgrade {
    fn new() -> CMatchPlayerAbilityUpgrade {
        CMatchPlayerAbilityUpgrade::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMatchPlayerAbilityUpgrade>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability",
                    CMatchPlayerAbilityUpgrade::get_ability_for_reflect,
                    CMatchPlayerAbilityUpgrade::mut_ability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time",
                    CMatchPlayerAbilityUpgrade::get_time_for_reflect,
                    CMatchPlayerAbilityUpgrade::mut_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMatchPlayerAbilityUpgrade>(
                    "CMatchPlayerAbilityUpgrade",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMatchPlayerAbilityUpgrade {
    fn clear(&mut self) {
        self.clear_ability();
        self.clear_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMatchPlayerAbilityUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerAbilityUpgrade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMatchAdditionalUnitInventory {
    // message fields
    unit_name: ::protobuf::SingularField<::std::string::String>,
    items: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMatchAdditionalUnitInventory {}

impl CMatchAdditionalUnitInventory {
    pub fn new() -> CMatchAdditionalUnitInventory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMatchAdditionalUnitInventory {
        static mut instance: ::protobuf::lazy::Lazy<CMatchAdditionalUnitInventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMatchAdditionalUnitInventory,
        };
        unsafe {
            instance.get(CMatchAdditionalUnitInventory::new)
        }
    }

    // optional string unit_name = 1;

    pub fn clear_unit_name(&mut self) {
        self.unit_name.clear();
    }

    pub fn has_unit_name(&self) -> bool {
        self.unit_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_name(&mut self, v: ::std::string::String) {
        self.unit_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
        if self.unit_name.is_none() {
            self.unit_name.set_default();
        }
        self.unit_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_name(&mut self) -> ::std::string::String {
        self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_unit_name(&self) -> &str {
        match self.unit_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_unit_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.unit_name
    }

    fn mut_unit_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.unit_name
    }

    // repeated uint32 items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<u32>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    pub fn get_items(&self) -> &[u32] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.items
    }
}

impl ::protobuf::Message for CMatchAdditionalUnitInventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unit_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.items {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMatchAdditionalUnitInventory {
    fn new() -> CMatchAdditionalUnitInventory {
        CMatchAdditionalUnitInventory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMatchAdditionalUnitInventory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unit_name",
                    CMatchAdditionalUnitInventory::get_unit_name_for_reflect,
                    CMatchAdditionalUnitInventory::mut_unit_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "items",
                    CMatchAdditionalUnitInventory::get_items_for_reflect,
                    CMatchAdditionalUnitInventory::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMatchAdditionalUnitInventory>(
                    "CMatchAdditionalUnitInventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMatchAdditionalUnitInventory {
    fn clear(&mut self) {
        self.clear_unit_name();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMatchAdditionalUnitInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchAdditionalUnitInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMatchPlayerPermanentBuff {
    // message fields
    permanent_buff: ::std::option::Option<u32>,
    stack_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMatchPlayerPermanentBuff {}

impl CMatchPlayerPermanentBuff {
    pub fn new() -> CMatchPlayerPermanentBuff {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMatchPlayerPermanentBuff {
        static mut instance: ::protobuf::lazy::Lazy<CMatchPlayerPermanentBuff> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMatchPlayerPermanentBuff,
        };
        unsafe {
            instance.get(CMatchPlayerPermanentBuff::new)
        }
    }

    // optional uint32 permanent_buff = 1;

    pub fn clear_permanent_buff(&mut self) {
        self.permanent_buff = ::std::option::Option::None;
    }

    pub fn has_permanent_buff(&self) -> bool {
        self.permanent_buff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent_buff(&mut self, v: u32) {
        self.permanent_buff = ::std::option::Option::Some(v);
    }

    pub fn get_permanent_buff(&self) -> u32 {
        self.permanent_buff.unwrap_or(0)
    }

    fn get_permanent_buff_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.permanent_buff
    }

    fn mut_permanent_buff_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.permanent_buff
    }

    // optional uint32 stack_count = 2;

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    pub fn get_stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    fn get_stack_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stack_count
    }

    fn mut_stack_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stack_count
    }
}

impl ::protobuf::Message for CMatchPlayerPermanentBuff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.permanent_buff = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stack_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permanent_buff {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permanent_buff {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMatchPlayerPermanentBuff {
    fn new() -> CMatchPlayerPermanentBuff {
        CMatchPlayerPermanentBuff::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMatchPlayerPermanentBuff>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "permanent_buff",
                    CMatchPlayerPermanentBuff::get_permanent_buff_for_reflect,
                    CMatchPlayerPermanentBuff::mut_permanent_buff_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stack_count",
                    CMatchPlayerPermanentBuff::get_stack_count_for_reflect,
                    CMatchPlayerPermanentBuff::mut_stack_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMatchPlayerPermanentBuff>(
                    "CMatchPlayerPermanentBuff",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMatchPlayerPermanentBuff {
    fn clear(&mut self) {
        self.clear_permanent_buff();
        self.clear_stack_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMatchPlayerPermanentBuff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchPlayerPermanentBuff {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMatchHeroSelectEvent {
    // message fields
    is_pick: ::std::option::Option<bool>,
    team: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMatchHeroSelectEvent {}

impl CMatchHeroSelectEvent {
    pub fn new() -> CMatchHeroSelectEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMatchHeroSelectEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMatchHeroSelectEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMatchHeroSelectEvent,
        };
        unsafe {
            instance.get(CMatchHeroSelectEvent::new)
        }
    }

    // optional bool is_pick = 1;

    pub fn clear_is_pick(&mut self) {
        self.is_pick = ::std::option::Option::None;
    }

    pub fn has_is_pick(&self) -> bool {
        self.is_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pick(&mut self, v: bool) {
        self.is_pick = ::std::option::Option::Some(v);
    }

    pub fn get_is_pick(&self) -> bool {
        self.is_pick.unwrap_or(false)
    }

    fn get_is_pick_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_pick
    }

    fn mut_is_pick_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_pick
    }

    // optional uint32 team = 2;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMatchHeroSelectEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_pick = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_pick {
            my_size += 2;
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_pick {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMatchHeroSelectEvent {
    fn new() -> CMatchHeroSelectEvent {
        CMatchHeroSelectEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMatchHeroSelectEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_pick",
                    CMatchHeroSelectEvent::get_is_pick_for_reflect,
                    CMatchHeroSelectEvent::mut_is_pick_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMatchHeroSelectEvent::get_team_for_reflect,
                    CMatchHeroSelectEvent::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMatchHeroSelectEvent::get_hero_id_for_reflect,
                    CMatchHeroSelectEvent::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMatchHeroSelectEvent>(
                    "CMatchHeroSelectEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMatchHeroSelectEvent {
    fn clear(&mut self) {
        self.clear_is_pick();
        self.clear_team();
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMatchHeroSelectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMatchHeroSelectEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProcessFantasyScheduledEvent {
    // message fields
    event: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    fantasy_league_id: ::std::option::Option<u32>,
    season: ::std::option::Option<u32>,
    reference_data: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProcessFantasyScheduledEvent {}

impl CMsgDOTAProcessFantasyScheduledEvent {
    pub fn new() -> CMsgDOTAProcessFantasyScheduledEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProcessFantasyScheduledEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProcessFantasyScheduledEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProcessFantasyScheduledEvent,
        };
        unsafe {
            instance.get(CMsgDOTAProcessFantasyScheduledEvent::new)
        }
    }

    // optional uint32 event = 1;

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: u32) {
        self.event = ::std::option::Option::Some(v);
    }

    pub fn get_event(&self) -> u32 {
        self.event.unwrap_or(0)
    }

    fn get_event_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event
    }

    fn mut_event_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event
    }

    // optional uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 fantasy_league_id = 3;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 season = 4;

    pub fn clear_season(&mut self) {
        self.season = ::std::option::Option::None;
    }

    pub fn has_season(&self) -> bool {
        self.season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season(&mut self, v: u32) {
        self.season = ::std::option::Option::Some(v);
    }

    pub fn get_season(&self) -> u32 {
        self.season.unwrap_or(0)
    }

    fn get_season_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.season
    }

    fn mut_season_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.season
    }

    // optional uint32 reference_data = 5;

    pub fn clear_reference_data(&mut self) {
        self.reference_data = ::std::option::Option::None;
    }

    pub fn has_reference_data(&self) -> bool {
        self.reference_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_data(&mut self, v: u32) {
        self.reference_data = ::std::option::Option::Some(v);
    }

    pub fn get_reference_data(&self) -> u32 {
        self.reference_data.unwrap_or(0)
    }

    fn get_reference_data_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reference_data
    }

    fn mut_reference_data_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reference_data
    }
}

impl ::protobuf::Message for CMsgDOTAProcessFantasyScheduledEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reference_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reference_data {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.season {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reference_data {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProcessFantasyScheduledEvent {
    fn new() -> CMsgDOTAProcessFantasyScheduledEvent {
        CMsgDOTAProcessFantasyScheduledEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProcessFantasyScheduledEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event",
                    CMsgDOTAProcessFantasyScheduledEvent::get_event_for_reflect,
                    CMsgDOTAProcessFantasyScheduledEvent::mut_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAProcessFantasyScheduledEvent::get_timestamp_for_reflect,
                    CMsgDOTAProcessFantasyScheduledEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAProcessFantasyScheduledEvent::get_fantasy_league_id_for_reflect,
                    CMsgDOTAProcessFantasyScheduledEvent::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "season",
                    CMsgDOTAProcessFantasyScheduledEvent::get_season_for_reflect,
                    CMsgDOTAProcessFantasyScheduledEvent::mut_season_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reference_data",
                    CMsgDOTAProcessFantasyScheduledEvent::get_reference_data_for_reflect,
                    CMsgDOTAProcessFantasyScheduledEvent::mut_reference_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProcessFantasyScheduledEvent>(
                    "CMsgDOTAProcessFantasyScheduledEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProcessFantasyScheduledEvent {
    fn clear(&mut self) {
        self.clear_event();
        self.clear_timestamp();
        self.clear_fantasy_league_id();
        self.clear_season();
        self.clear_reference_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProcessFantasyScheduledEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProcessFantasyScheduledEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHasItemQuery {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHasItemQuery {}

impl CMsgDOTAHasItemQuery {
    pub fn new() -> CMsgDOTAHasItemQuery {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHasItemQuery {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHasItemQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHasItemQuery,
        };
        unsafe {
            instance.get(CMsgDOTAHasItemQuery::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHasItemQuery {
    fn new() -> CMsgDOTAHasItemQuery {
        CMsgDOTAHasItemQuery::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHasItemQuery>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAHasItemQuery::get_account_id_for_reflect,
                    CMsgDOTAHasItemQuery::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgDOTAHasItemQuery::get_item_id_for_reflect,
                    CMsgDOTAHasItemQuery::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHasItemQuery>(
                    "CMsgDOTAHasItemQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHasItemQuery {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHasItemQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHasItemResponse {
    // message fields
    has_item: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHasItemResponse {}

impl CMsgDOTAHasItemResponse {
    pub fn new() -> CMsgDOTAHasItemResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHasItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHasItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHasItemResponse,
        };
        unsafe {
            instance.get(CMsgDOTAHasItemResponse::new)
        }
    }

    // optional bool has_item = 1;

    pub fn clear_has_item(&mut self) {
        self.has_item = ::std::option::Option::None;
    }

    pub fn has_has_item(&self) -> bool {
        self.has_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_item(&mut self, v: bool) {
        self.has_item = ::std::option::Option::Some(v);
    }

    pub fn get_has_item(&self) -> bool {
        self.has_item.unwrap_or(false)
    }

    fn get_has_item_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_item
    }

    fn mut_has_item_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_item
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_item = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has_item {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_item {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHasItemResponse {
    fn new() -> CMsgDOTAHasItemResponse {
        CMsgDOTAHasItemResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHasItemResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_item",
                    CMsgDOTAHasItemResponse::get_has_item_for_reflect,
                    CMsgDOTAHasItemResponse::mut_has_item_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHasItemResponse>(
                    "CMsgDOTAHasItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHasItemResponse {
    fn clear(&mut self) {
        self.clear_has_item();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHasItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCIsProQuery {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCIsProQuery {}

impl CMsgGCIsProQuery {
    pub fn new() -> CMsgGCIsProQuery {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCIsProQuery {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCIsProQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCIsProQuery,
        };
        unsafe {
            instance.get(CMsgGCIsProQuery::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCIsProQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCIsProQuery {
    fn new() -> CMsgGCIsProQuery {
        CMsgGCIsProQuery::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCIsProQuery>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCIsProQuery::get_account_id_for_reflect,
                    CMsgGCIsProQuery::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCIsProQuery>(
                    "CMsgGCIsProQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCIsProQuery {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCIsProQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIsProQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCIsProResponse {
    // message fields
    is_pro: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCIsProResponse {}

impl CMsgGCIsProResponse {
    pub fn new() -> CMsgGCIsProResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCIsProResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCIsProResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCIsProResponse,
        };
        unsafe {
            instance.get(CMsgGCIsProResponse::new)
        }
    }

    // optional bool is_pro = 1;

    pub fn clear_is_pro(&mut self) {
        self.is_pro = ::std::option::Option::None;
    }

    pub fn has_is_pro(&self) -> bool {
        self.is_pro.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pro(&mut self, v: bool) {
        self.is_pro = ::std::option::Option::Some(v);
    }

    pub fn get_is_pro(&self) -> bool {
        self.is_pro.unwrap_or(false)
    }

    fn get_is_pro_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_pro
    }

    fn mut_is_pro_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_pro
    }
}

impl ::protobuf::Message for CMsgGCIsProResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_pro = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_pro {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_pro {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCIsProResponse {
    fn new() -> CMsgGCIsProResponse {
        CMsgGCIsProResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCIsProResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_pro",
                    CMsgGCIsProResponse::get_is_pro_for_reflect,
                    CMsgGCIsProResponse::mut_is_pro_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCIsProResponse>(
                    "CMsgGCIsProResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCIsProResponse {
    fn clear(&mut self) {
        self.clear_is_pro();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCIsProResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIsProResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHasItemDefsQuery {
    // message fields
    account_id: ::std::option::Option<u32>,
    itemdef_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHasItemDefsQuery {}

impl CMsgDOTAHasItemDefsQuery {
    pub fn new() -> CMsgDOTAHasItemDefsQuery {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHasItemDefsQuery {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHasItemDefsQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHasItemDefsQuery,
        };
        unsafe {
            instance.get(CMsgDOTAHasItemDefsQuery::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated uint32 itemdef_ids = 2;

    pub fn clear_itemdef_ids(&mut self) {
        self.itemdef_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_itemdef_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.itemdef_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_itemdef_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.itemdef_ids
    }

    // Take field
    pub fn take_itemdef_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.itemdef_ids, ::std::vec::Vec::new())
    }

    pub fn get_itemdef_ids(&self) -> &[u32] {
        &self.itemdef_ids
    }

    fn get_itemdef_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.itemdef_ids
    }

    fn mut_itemdef_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.itemdef_ids
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemDefsQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.itemdef_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.itemdef_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.itemdef_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHasItemDefsQuery {
    fn new() -> CMsgDOTAHasItemDefsQuery {
        CMsgDOTAHasItemDefsQuery::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHasItemDefsQuery>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAHasItemDefsQuery::get_account_id_for_reflect,
                    CMsgDOTAHasItemDefsQuery::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "itemdef_ids",
                    CMsgDOTAHasItemDefsQuery::get_itemdef_ids_for_reflect,
                    CMsgDOTAHasItemDefsQuery::mut_itemdef_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHasItemDefsQuery>(
                    "CMsgDOTAHasItemDefsQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHasItemDefsQuery {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_itemdef_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHasItemDefsQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemDefsQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHasItemDefsResponse {
    // message fields
    has_items: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHasItemDefsResponse {}

impl CMsgDOTAHasItemDefsResponse {
    pub fn new() -> CMsgDOTAHasItemDefsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHasItemDefsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHasItemDefsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHasItemDefsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAHasItemDefsResponse::new)
        }
    }

    // optional bool has_items = 1;

    pub fn clear_has_items(&mut self) {
        self.has_items = ::std::option::Option::None;
    }

    pub fn has_has_items(&self) -> bool {
        self.has_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_items(&mut self, v: bool) {
        self.has_items = ::std::option::Option::Some(v);
    }

    pub fn get_has_items(&self) -> bool {
        self.has_items.unwrap_or(false)
    }

    fn get_has_items_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_items
    }

    fn mut_has_items_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_items
    }
}

impl ::protobuf::Message for CMsgDOTAHasItemDefsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_items = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has_items {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_items {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHasItemDefsResponse {
    fn new() -> CMsgDOTAHasItemDefsResponse {
        CMsgDOTAHasItemDefsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHasItemDefsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_items",
                    CMsgDOTAHasItemDefsResponse::get_has_items_for_reflect,
                    CMsgDOTAHasItemDefsResponse::mut_has_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHasItemDefsResponse>(
                    "CMsgDOTAHasItemDefsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHasItemDefsResponse {
    fn clear(&mut self) {
        self.clear_has_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHasItemDefsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHasItemDefsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetPlayerCardItemInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    player_card_item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetPlayerCardItemInfo {}

impl CMsgGCGetPlayerCardItemInfo {
    pub fn new() -> CMsgGCGetPlayerCardItemInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetPlayerCardItemInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetPlayerCardItemInfo,
        };
        unsafe {
            instance.get(CMsgGCGetPlayerCardItemInfo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated uint64 player_card_item_ids = 2;

    pub fn clear_player_card_item_ids(&mut self) {
        self.player_card_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.player_card_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }

    // Take field
    pub fn take_player_card_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.player_card_item_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_card_item_ids(&self) -> &[u64] {
        &self.player_card_item_ids
    }

    fn get_player_card_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.player_card_item_ids
    }

    fn mut_player_card_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }
}

impl ::protobuf::Message for CMsgGCGetPlayerCardItemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.player_card_item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_card_item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_card_item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetPlayerCardItemInfo {
    fn new() -> CMsgGCGetPlayerCardItemInfo {
        CMsgGCGetPlayerCardItemInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetPlayerCardItemInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCGetPlayerCardItemInfo::get_account_id_for_reflect,
                    CMsgGCGetPlayerCardItemInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_ids",
                    CMsgGCGetPlayerCardItemInfo::get_player_card_item_ids_for_reflect,
                    CMsgGCGetPlayerCardItemInfo::mut_player_card_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetPlayerCardItemInfo>(
                    "CMsgGCGetPlayerCardItemInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetPlayerCardItemInfo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_player_card_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetPlayerCardItemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetPlayerCardItemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetPlayerCardItemInfoResponse {
    // message fields
    player_card_infos: ::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetPlayerCardItemInfoResponse {}

impl CMsgGCGetPlayerCardItemInfoResponse {
    pub fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetPlayerCardItemInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetPlayerCardItemInfoResponse,
        };
        unsafe {
            instance.get(CMsgGCGetPlayerCardItemInfoResponse::new)
        }
    }

    // repeated .CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo player_card_infos = 1;

    pub fn clear_player_card_infos(&mut self) {
        self.player_card_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_infos(&mut self, v: ::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>) {
        self.player_card_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_infos(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo> {
        &mut self.player_card_infos
    }

    // Take field
    pub fn take_player_card_infos(&mut self) -> ::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo> {
        ::std::mem::replace(&mut self.player_card_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_card_infos(&self) -> &[CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo] {
        &self.player_card_infos
    }

    fn get_player_card_infos_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo> {
        &self.player_card_infos
    }

    fn mut_player_card_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo> {
        &mut self.player_card_infos
    }
}

impl ::protobuf::Message for CMsgGCGetPlayerCardItemInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.player_card_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_card_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_card_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_card_infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetPlayerCardItemInfoResponse {
    fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        CMsgGCGetPlayerCardItemInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetPlayerCardItemInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>>(
                    "player_card_infos",
                    CMsgGCGetPlayerCardItemInfoResponse::get_player_card_infos_for_reflect,
                    CMsgGCGetPlayerCardItemInfoResponse::mut_player_card_infos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetPlayerCardItemInfoResponse>(
                    "CMsgGCGetPlayerCardItemInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetPlayerCardItemInfoResponse {
    fn clear(&mut self) {
        self.clear_player_card_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetPlayerCardItemInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetPlayerCardItemInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    // message fields
    player_card_item_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    packed_bonuses: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {}

impl CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    pub fn new() -> CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo,
        };
        unsafe {
            instance.get(CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::new)
        }
    }

    // optional uint64 player_card_item_id = 1;

    pub fn clear_player_card_item_id(&mut self) {
        self.player_card_item_id = ::std::option::Option::None;
    }

    pub fn has_player_card_item_id(&self) -> bool {
        self.player_card_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_id(&mut self, v: u64) {
        self.player_card_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_card_item_id(&self) -> u64 {
        self.player_card_item_id.unwrap_or(0)
    }

    fn get_player_card_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.player_card_item_id
    }

    fn mut_player_card_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.player_card_item_id
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 packed_bonuses = 3;

    pub fn clear_packed_bonuses(&mut self) {
        self.packed_bonuses = ::std::option::Option::None;
    }

    pub fn has_packed_bonuses(&self) -> bool {
        self.packed_bonuses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_bonuses(&mut self, v: u64) {
        self.packed_bonuses = ::std::option::Option::Some(v);
    }

    pub fn get_packed_bonuses(&self) -> u64 {
        self.packed_bonuses.unwrap_or(0)
    }

    fn get_packed_bonuses_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.packed_bonuses
    }

    fn mut_packed_bonuses_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.packed_bonuses
    }
}

impl ::protobuf::Message for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.player_card_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packed_bonuses = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_card_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packed_bonuses {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_card_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.packed_bonuses {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    fn new() -> CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
        CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_id",
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::get_player_card_item_id_for_reflect,
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::mut_player_card_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::get_account_id_for_reflect,
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "packed_bonuses",
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::get_packed_bonuses_for_reflect,
                    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::mut_packed_bonuses_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>(
                    "CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    fn clear(&mut self) {
        self.clear_player_card_item_id();
        self.clear_account_id();
        self.clear_packed_bonuses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCFantasySetMatchLeague {
    // message fields
    match_id: ::std::option::Option<u64>,
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCFantasySetMatchLeague {}

impl CMsgGCToGCFantasySetMatchLeague {
    pub fn new() -> CMsgGCToGCFantasySetMatchLeague {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCFantasySetMatchLeague {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCFantasySetMatchLeague> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCFantasySetMatchLeague,
        };
        unsafe {
            instance.get(CMsgGCToGCFantasySetMatchLeague::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 league_id = 2;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgGCToGCFantasySetMatchLeague {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCFantasySetMatchLeague {
    fn new() -> CMsgGCToGCFantasySetMatchLeague {
        CMsgGCToGCFantasySetMatchLeague::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCFantasySetMatchLeague>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCToGCFantasySetMatchLeague::get_match_id_for_reflect,
                    CMsgGCToGCFantasySetMatchLeague::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgGCToGCFantasySetMatchLeague::get_league_id_for_reflect,
                    CMsgGCToGCFantasySetMatchLeague::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCFantasySetMatchLeague>(
                    "CMsgGCToGCFantasySetMatchLeague",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCFantasySetMatchLeague {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCFantasySetMatchLeague {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCFantasySetMatchLeague {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSODOTAMapLocationState {
    // message fields
    account_id: ::std::option::Option<u32>,
    location_id: ::std::option::Option<i32>,
    completed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSODOTAMapLocationState {}

impl CSODOTAMapLocationState {
    pub fn new() -> CSODOTAMapLocationState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSODOTAMapLocationState {
        static mut instance: ::protobuf::lazy::Lazy<CSODOTAMapLocationState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSODOTAMapLocationState,
        };
        unsafe {
            instance.get(CSODOTAMapLocationState::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional int32 location_id = 2;

    pub fn clear_location_id(&mut self) {
        self.location_id = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        self.location_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: i32) {
        self.location_id = ::std::option::Option::Some(v);
    }

    pub fn get_location_id(&self) -> i32 {
        self.location_id.unwrap_or(0)
    }

    fn get_location_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.location_id
    }

    fn mut_location_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.location_id
    }

    // optional bool completed = 3;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.completed
    }
}

impl ::protobuf::Message for CSODOTAMapLocationState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.location_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.location_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.location_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSODOTAMapLocationState {
    fn new() -> CSODOTAMapLocationState {
        CSODOTAMapLocationState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSODOTAMapLocationState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CSODOTAMapLocationState::get_account_id_for_reflect,
                    CSODOTAMapLocationState::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "location_id",
                    CSODOTAMapLocationState::get_location_id_for_reflect,
                    CSODOTAMapLocationState::mut_location_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "completed",
                    CSODOTAMapLocationState::get_completed_for_reflect,
                    CSODOTAMapLocationState::mut_completed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSODOTAMapLocationState>(
                    "CSODOTAMapLocationState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSODOTAMapLocationState {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_location_id();
        self.clear_completed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSODOTAMapLocationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAMapLocationState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeagueAdminList {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeagueAdminList {}

impl CMsgLeagueAdminList {
    pub fn new() -> CMsgLeagueAdminList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeagueAdminList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeagueAdminList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeagueAdminList,
        };
        unsafe {
            instance.get(CMsgLeagueAdminList::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgLeagueAdminList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeagueAdminList {
    fn new() -> CMsgLeagueAdminList {
        CMsgLeagueAdminList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeagueAdminList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgLeagueAdminList::get_account_ids_for_reflect,
                    CMsgLeagueAdminList::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeagueAdminList>(
                    "CMsgLeagueAdminList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeagueAdminList {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeagueAdminList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeagueAdminList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCompendiumTimestampedData {
    // message fields
    game_time: ::std::option::Option<u32>,
    gpm: ::std::option::Option<u32>,
    xpm: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    item_purchases: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CCompendiumTimestampedData {}

impl CCompendiumTimestampedData {
    pub fn new() -> CCompendiumTimestampedData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCompendiumTimestampedData {
        static mut instance: ::protobuf::lazy::Lazy<CCompendiumTimestampedData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCompendiumTimestampedData,
        };
        unsafe {
            instance.get(CCompendiumTimestampedData::new)
        }
    }

    // optional uint32 game_time = 1;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: u32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> u32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_time
    }

    // optional uint32 gpm = 2;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gpm
    }

    // optional uint32 xpm = 3;

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    pub fn get_xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    fn get_xpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xpm
    }

    fn mut_xpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xpm
    }

    // optional uint32 kills = 4;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 5;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // repeated uint32 item_purchases = 6;

    pub fn clear_item_purchases(&mut self) {
        self.item_purchases.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_purchases(&mut self, v: ::std::vec::Vec<u32>) {
        self.item_purchases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_purchases(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_purchases
    }

    // Take field
    pub fn take_item_purchases(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.item_purchases, ::std::vec::Vec::new())
    }

    pub fn get_item_purchases(&self) -> &[u32] {
        &self.item_purchases
    }

    fn get_item_purchases_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.item_purchases
    }

    fn mut_item_purchases_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_purchases
    }
}

impl ::protobuf::Message for CCompendiumTimestampedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xpm = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.item_purchases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_purchases {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(5, v)?;
        }
        for v in &self.item_purchases {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CCompendiumTimestampedData {
    fn new() -> CCompendiumTimestampedData {
        CCompendiumTimestampedData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CCompendiumTimestampedData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_time",
                    CCompendiumTimestampedData::get_game_time_for_reflect,
                    CCompendiumTimestampedData::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gpm",
                    CCompendiumTimestampedData::get_gpm_for_reflect,
                    CCompendiumTimestampedData::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xpm",
                    CCompendiumTimestampedData::get_xpm_for_reflect,
                    CCompendiumTimestampedData::mut_xpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CCompendiumTimestampedData::get_kills_for_reflect,
                    CCompendiumTimestampedData::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CCompendiumTimestampedData::get_deaths_for_reflect,
                    CCompendiumTimestampedData::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_purchases",
                    CCompendiumTimestampedData::get_item_purchases_for_reflect,
                    CCompendiumTimestampedData::mut_item_purchases_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCompendiumTimestampedData>(
                    "CCompendiumTimestampedData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CCompendiumTimestampedData {
    fn clear(&mut self) {
        self.clear_game_time();
        self.clear_gpm();
        self.clear_xpm();
        self.clear_kills();
        self.clear_deaths();
        self.clear_item_purchases();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCompendiumTimestampedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCompendiumTimestampedData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCompendiumGameTimeline {
    // message fields
    data: ::protobuf::RepeatedField<CCompendiumTimestampedData>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CCompendiumGameTimeline {}

impl CCompendiumGameTimeline {
    pub fn new() -> CCompendiumGameTimeline {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCompendiumGameTimeline {
        static mut instance: ::protobuf::lazy::Lazy<CCompendiumGameTimeline> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCompendiumGameTimeline,
        };
        unsafe {
            instance.get(CCompendiumGameTimeline::new)
        }
    }

    // repeated .CCompendiumTimestampedData data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<CCompendiumTimestampedData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<CCompendiumTimestampedData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<CCompendiumTimestampedData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[CCompendiumTimestampedData] {
        &self.data
    }

    fn get_data_for_reflect(&self) -> &::protobuf::RepeatedField<CCompendiumTimestampedData> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CCompendiumTimestampedData> {
        &mut self.data
    }

    // repeated string tags = 2;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }

    fn get_tags_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.tags
    }

    fn mut_tags_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }
}

impl ::protobuf::Message for CCompendiumGameTimeline {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tags {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CCompendiumGameTimeline {
    fn new() -> CCompendiumGameTimeline {
        CCompendiumGameTimeline::new()
    }

    fn descriptor_static(_: ::std::option::Option<CCompendiumGameTimeline>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCompendiumTimestampedData>>(
                    "data",
                    CCompendiumGameTimeline::get_data_for_reflect,
                    CCompendiumGameTimeline::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    CCompendiumGameTimeline::get_tags_for_reflect,
                    CCompendiumGameTimeline::mut_tags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCompendiumGameTimeline>(
                    "CCompendiumGameTimeline",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CCompendiumGameTimeline {
    fn clear(&mut self) {
        self.clear_data();
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCompendiumGameTimeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCompendiumGameTimeline {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCompendiumGameList {
    // message fields
    games: ::protobuf::RepeatedField<CCompendiumGameTimeline>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CCompendiumGameList {}

impl CCompendiumGameList {
    pub fn new() -> CCompendiumGameList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CCompendiumGameList {
        static mut instance: ::protobuf::lazy::Lazy<CCompendiumGameList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCompendiumGameList,
        };
        unsafe {
            instance.get(CCompendiumGameList::new)
        }
    }

    // repeated .CCompendiumGameTimeline games = 1;

    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CCompendiumGameTimeline>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CCompendiumGameTimeline> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CCompendiumGameTimeline> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }

    pub fn get_games(&self) -> &[CCompendiumGameTimeline] {
        &self.games
    }

    fn get_games_for_reflect(&self) -> &::protobuf::RepeatedField<CCompendiumGameTimeline> {
        &self.games
    }

    fn mut_games_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CCompendiumGameTimeline> {
        &mut self.games
    }
}

impl ::protobuf::Message for CCompendiumGameList {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CCompendiumGameList {
    fn new() -> CCompendiumGameList {
        CCompendiumGameList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CCompendiumGameList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCompendiumGameTimeline>>(
                    "games",
                    CCompendiumGameList::get_games_for_reflect,
                    CCompendiumGameList::mut_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCompendiumGameList>(
                    "CCompendiumGameList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CCompendiumGameList {
    fn clear(&mut self) {
        self.clear_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCompendiumGameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCompendiumGameList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAdditionalEquipSlot {
    // message fields
    class_id: ::std::option::Option<u32>,
    slot_id: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAdditionalEquipSlot {}

impl CAdditionalEquipSlot {
    pub fn new() -> CAdditionalEquipSlot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAdditionalEquipSlot {
        static mut instance: ::protobuf::lazy::Lazy<CAdditionalEquipSlot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAdditionalEquipSlot,
        };
        unsafe {
            instance.get(CAdditionalEquipSlot::new)
        }
    }

    // optional uint32 class_id = 1;

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    fn get_class_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.class_id
    }

    fn mut_class_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.class_id
    }

    // optional uint32 slot_id = 2;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional uint32 def_index = 3;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }
}

impl ::protobuf::Message for CAdditionalEquipSlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAdditionalEquipSlot {
    fn new() -> CAdditionalEquipSlot {
        CAdditionalEquipSlot::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAdditionalEquipSlot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "class_id",
                    CAdditionalEquipSlot::get_class_id_for_reflect,
                    CAdditionalEquipSlot::mut_class_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CAdditionalEquipSlot::get_slot_id_for_reflect,
                    CAdditionalEquipSlot::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CAdditionalEquipSlot::get_def_index_for_reflect,
                    CAdditionalEquipSlot::mut_def_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAdditionalEquipSlot>(
                    "CAdditionalEquipSlot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAdditionalEquipSlot {
    fn clear(&mut self) {
        self.clear_class_id();
        self.clear_slot_id();
        self.clear_def_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAdditionalEquipSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAdditionalEquipSlot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACombatLogEntry {
    // message fields
    field_type: ::std::option::Option<DOTA_COMBATLOG_TYPES>,
    target_name: ::std::option::Option<u32>,
    target_source_name: ::std::option::Option<u32>,
    attacker_name: ::std::option::Option<u32>,
    damage_source_name: ::std::option::Option<u32>,
    inflictor_name: ::std::option::Option<u32>,
    is_attacker_illusion: ::std::option::Option<bool>,
    is_attacker_hero: ::std::option::Option<bool>,
    is_target_illusion: ::std::option::Option<bool>,
    is_target_hero: ::std::option::Option<bool>,
    is_visible_radiant: ::std::option::Option<bool>,
    is_visible_dire: ::std::option::Option<bool>,
    value: ::std::option::Option<u32>,
    health: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<f32>,
    stun_duration: ::std::option::Option<f32>,
    slow_duration: ::std::option::Option<f32>,
    is_ability_toggle_on: ::std::option::Option<bool>,
    is_ability_toggle_off: ::std::option::Option<bool>,
    ability_level: ::std::option::Option<u32>,
    location_x: ::std::option::Option<f32>,
    location_y: ::std::option::Option<f32>,
    gold_reason: ::std::option::Option<u32>,
    timestamp_raw: ::std::option::Option<f32>,
    modifier_duration: ::std::option::Option<f32>,
    xp_reason: ::std::option::Option<u32>,
    last_hits: ::std::option::Option<u32>,
    attacker_team: ::std::option::Option<u32>,
    target_team: ::std::option::Option<u32>,
    obs_wards_placed: ::std::option::Option<u32>,
    assist_player0: ::std::option::Option<u32>,
    assist_player1: ::std::option::Option<u32>,
    assist_player2: ::std::option::Option<u32>,
    assist_player3: ::std::option::Option<u32>,
    stack_count: ::std::option::Option<u32>,
    hidden_modifier: ::std::option::Option<bool>,
    is_target_building: ::std::option::Option<bool>,
    neutral_camp_type: ::std::option::Option<u32>,
    rune_type: ::std::option::Option<u32>,
    assist_players: ::std::vec::Vec<u32>,
    is_heal_save: ::std::option::Option<bool>,
    is_ultimate_ability: ::std::option::Option<bool>,
    attacker_hero_level: ::std::option::Option<u32>,
    target_hero_level: ::std::option::Option<u32>,
    xpm: ::std::option::Option<u32>,
    gpm: ::std::option::Option<u32>,
    event_location: ::std::option::Option<u32>,
    target_is_self: ::std::option::Option<bool>,
    damage_type: ::std::option::Option<u32>,
    invisibility_modifier: ::std::option::Option<bool>,
    damage_category: ::std::option::Option<u32>,
    networth: ::std::option::Option<u32>,
    building_type: ::std::option::Option<u32>,
    modifier_elapsed_duration: ::std::option::Option<f32>,
    silence_modifier: ::std::option::Option<bool>,
    heal_from_lifesteal: ::std::option::Option<bool>,
    modifier_purged: ::std::option::Option<bool>,
    spell_evaded: ::std::option::Option<bool>,
    motion_controller_modifier: ::std::option::Option<bool>,
    long_range_kill: ::std::option::Option<bool>,
    modifier_purge_ability: ::std::option::Option<u32>,
    modifier_purge_npc: ::std::option::Option<u32>,
    root_modifier: ::std::option::Option<bool>,
    total_unit_death_count: ::std::option::Option<u32>,
    aura_modifier: ::std::option::Option<bool>,
    armor_debuff_modifier: ::std::option::Option<bool>,
    no_physical_damage_modifier: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACombatLogEntry {}

impl CMsgDOTACombatLogEntry {
    pub fn new() -> CMsgDOTACombatLogEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACombatLogEntry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACombatLogEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACombatLogEntry,
        };
        unsafe {
            instance.get(CMsgDOTACombatLogEntry::new)
        }
    }

    // optional .DOTA_COMBATLOG_TYPES type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_COMBATLOG_TYPES) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DOTA_COMBATLOG_TYPES {
        self.field_type.unwrap_or(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DOTA_COMBATLOG_TYPES> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        &mut self.field_type
    }

    // optional uint32 target_name = 2;

    pub fn clear_target_name(&mut self) {
        self.target_name = ::std::option::Option::None;
    }

    pub fn has_target_name(&self) -> bool {
        self.target_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_name(&mut self, v: u32) {
        self.target_name = ::std::option::Option::Some(v);
    }

    pub fn get_target_name(&self) -> u32 {
        self.target_name.unwrap_or(0)
    }

    fn get_target_name_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_name
    }

    fn mut_target_name_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_name
    }

    // optional uint32 target_source_name = 3;

    pub fn clear_target_source_name(&mut self) {
        self.target_source_name = ::std::option::Option::None;
    }

    pub fn has_target_source_name(&self) -> bool {
        self.target_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_source_name(&mut self, v: u32) {
        self.target_source_name = ::std::option::Option::Some(v);
    }

    pub fn get_target_source_name(&self) -> u32 {
        self.target_source_name.unwrap_or(0)
    }

    fn get_target_source_name_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_source_name
    }

    fn mut_target_source_name_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_source_name
    }

    // optional uint32 attacker_name = 4;

    pub fn clear_attacker_name(&mut self) {
        self.attacker_name = ::std::option::Option::None;
    }

    pub fn has_attacker_name(&self) -> bool {
        self.attacker_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_name(&mut self, v: u32) {
        self.attacker_name = ::std::option::Option::Some(v);
    }

    pub fn get_attacker_name(&self) -> u32 {
        self.attacker_name.unwrap_or(0)
    }

    fn get_attacker_name_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attacker_name
    }

    fn mut_attacker_name_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attacker_name
    }

    // optional uint32 damage_source_name = 5;

    pub fn clear_damage_source_name(&mut self) {
        self.damage_source_name = ::std::option::Option::None;
    }

    pub fn has_damage_source_name(&self) -> bool {
        self.damage_source_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_source_name(&mut self, v: u32) {
        self.damage_source_name = ::std::option::Option::Some(v);
    }

    pub fn get_damage_source_name(&self) -> u32 {
        self.damage_source_name.unwrap_or(0)
    }

    fn get_damage_source_name_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage_source_name
    }

    fn mut_damage_source_name_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage_source_name
    }

    // optional uint32 inflictor_name = 6;

    pub fn clear_inflictor_name(&mut self) {
        self.inflictor_name = ::std::option::Option::None;
    }

    pub fn has_inflictor_name(&self) -> bool {
        self.inflictor_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_name(&mut self, v: u32) {
        self.inflictor_name = ::std::option::Option::Some(v);
    }

    pub fn get_inflictor_name(&self) -> u32 {
        self.inflictor_name.unwrap_or(0)
    }

    fn get_inflictor_name_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.inflictor_name
    }

    fn mut_inflictor_name_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.inflictor_name
    }

    // optional bool is_attacker_illusion = 7;

    pub fn clear_is_attacker_illusion(&mut self) {
        self.is_attacker_illusion = ::std::option::Option::None;
    }

    pub fn has_is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_illusion(&mut self, v: bool) {
        self.is_attacker_illusion = ::std::option::Option::Some(v);
    }

    pub fn get_is_attacker_illusion(&self) -> bool {
        self.is_attacker_illusion.unwrap_or(false)
    }

    fn get_is_attacker_illusion_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_attacker_illusion
    }

    fn mut_is_attacker_illusion_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_attacker_illusion
    }

    // optional bool is_attacker_hero = 8;

    pub fn clear_is_attacker_hero(&mut self) {
        self.is_attacker_hero = ::std::option::Option::None;
    }

    pub fn has_is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attacker_hero(&mut self, v: bool) {
        self.is_attacker_hero = ::std::option::Option::Some(v);
    }

    pub fn get_is_attacker_hero(&self) -> bool {
        self.is_attacker_hero.unwrap_or(false)
    }

    fn get_is_attacker_hero_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_attacker_hero
    }

    fn mut_is_attacker_hero_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_attacker_hero
    }

    // optional bool is_target_illusion = 9;

    pub fn clear_is_target_illusion(&mut self) {
        self.is_target_illusion = ::std::option::Option::None;
    }

    pub fn has_is_target_illusion(&self) -> bool {
        self.is_target_illusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_illusion(&mut self, v: bool) {
        self.is_target_illusion = ::std::option::Option::Some(v);
    }

    pub fn get_is_target_illusion(&self) -> bool {
        self.is_target_illusion.unwrap_or(false)
    }

    fn get_is_target_illusion_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_target_illusion
    }

    fn mut_is_target_illusion_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_target_illusion
    }

    // optional bool is_target_hero = 10;

    pub fn clear_is_target_hero(&mut self) {
        self.is_target_hero = ::std::option::Option::None;
    }

    pub fn has_is_target_hero(&self) -> bool {
        self.is_target_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_hero(&mut self, v: bool) {
        self.is_target_hero = ::std::option::Option::Some(v);
    }

    pub fn get_is_target_hero(&self) -> bool {
        self.is_target_hero.unwrap_or(false)
    }

    fn get_is_target_hero_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_target_hero
    }

    fn mut_is_target_hero_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_target_hero
    }

    // optional bool is_visible_radiant = 11;

    pub fn clear_is_visible_radiant(&mut self) {
        self.is_visible_radiant = ::std::option::Option::None;
    }

    pub fn has_is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_radiant(&mut self, v: bool) {
        self.is_visible_radiant = ::std::option::Option::Some(v);
    }

    pub fn get_is_visible_radiant(&self) -> bool {
        self.is_visible_radiant.unwrap_or(false)
    }

    fn get_is_visible_radiant_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_visible_radiant
    }

    fn mut_is_visible_radiant_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_visible_radiant
    }

    // optional bool is_visible_dire = 12;

    pub fn clear_is_visible_dire(&mut self) {
        self.is_visible_dire = ::std::option::Option::None;
    }

    pub fn has_is_visible_dire(&self) -> bool {
        self.is_visible_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_dire(&mut self, v: bool) {
        self.is_visible_dire = ::std::option::Option::Some(v);
    }

    pub fn get_is_visible_dire(&self) -> bool {
        self.is_visible_dire.unwrap_or(false)
    }

    fn get_is_visible_dire_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_visible_dire
    }

    fn mut_is_visible_dire_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_visible_dire
    }

    // optional uint32 value = 13;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }

    // optional int32 health = 14;

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    pub fn get_health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    fn get_health_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.health
    }

    fn mut_health_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.health
    }

    // optional float timestamp = 15;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.timestamp
    }

    // optional float stun_duration = 16;

    pub fn clear_stun_duration(&mut self) {
        self.stun_duration = ::std::option::Option::None;
    }

    pub fn has_stun_duration(&self) -> bool {
        self.stun_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_duration(&mut self, v: f32) {
        self.stun_duration = ::std::option::Option::Some(v);
    }

    pub fn get_stun_duration(&self) -> f32 {
        self.stun_duration.unwrap_or(0.)
    }

    fn get_stun_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.stun_duration
    }

    fn mut_stun_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.stun_duration
    }

    // optional float slow_duration = 17;

    pub fn clear_slow_duration(&mut self) {
        self.slow_duration = ::std::option::Option::None;
    }

    pub fn has_slow_duration(&self) -> bool {
        self.slow_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slow_duration(&mut self, v: f32) {
        self.slow_duration = ::std::option::Option::Some(v);
    }

    pub fn get_slow_duration(&self) -> f32 {
        self.slow_duration.unwrap_or(0.)
    }

    fn get_slow_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.slow_duration
    }

    fn mut_slow_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.slow_duration
    }

    // optional bool is_ability_toggle_on = 18;

    pub fn clear_is_ability_toggle_on(&mut self) {
        self.is_ability_toggle_on = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_on(&mut self, v: bool) {
        self.is_ability_toggle_on = ::std::option::Option::Some(v);
    }

    pub fn get_is_ability_toggle_on(&self) -> bool {
        self.is_ability_toggle_on.unwrap_or(false)
    }

    fn get_is_ability_toggle_on_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_ability_toggle_on
    }

    fn mut_is_ability_toggle_on_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_ability_toggle_on
    }

    // optional bool is_ability_toggle_off = 19;

    pub fn clear_is_ability_toggle_off(&mut self) {
        self.is_ability_toggle_off = ::std::option::Option::None;
    }

    pub fn has_is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ability_toggle_off(&mut self, v: bool) {
        self.is_ability_toggle_off = ::std::option::Option::Some(v);
    }

    pub fn get_is_ability_toggle_off(&self) -> bool {
        self.is_ability_toggle_off.unwrap_or(false)
    }

    fn get_is_ability_toggle_off_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_ability_toggle_off
    }

    fn mut_is_ability_toggle_off_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_ability_toggle_off
    }

    // optional uint32 ability_level = 20;

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    pub fn get_ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    fn get_ability_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_level
    }

    fn mut_ability_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_level
    }

    // optional float location_x = 21;

    pub fn clear_location_x(&mut self) {
        self.location_x = ::std::option::Option::None;
    }

    pub fn has_location_x(&self) -> bool {
        self.location_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_x(&mut self, v: f32) {
        self.location_x = ::std::option::Option::Some(v);
    }

    pub fn get_location_x(&self) -> f32 {
        self.location_x.unwrap_or(0.)
    }

    fn get_location_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.location_x
    }

    fn mut_location_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.location_x
    }

    // optional float location_y = 22;

    pub fn clear_location_y(&mut self) {
        self.location_y = ::std::option::Option::None;
    }

    pub fn has_location_y(&self) -> bool {
        self.location_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_y(&mut self, v: f32) {
        self.location_y = ::std::option::Option::Some(v);
    }

    pub fn get_location_y(&self) -> f32 {
        self.location_y.unwrap_or(0.)
    }

    fn get_location_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.location_y
    }

    fn mut_location_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.location_y
    }

    // optional uint32 gold_reason = 23;

    pub fn clear_gold_reason(&mut self) {
        self.gold_reason = ::std::option::Option::None;
    }

    pub fn has_gold_reason(&self) -> bool {
        self.gold_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_reason(&mut self, v: u32) {
        self.gold_reason = ::std::option::Option::Some(v);
    }

    pub fn get_gold_reason(&self) -> u32 {
        self.gold_reason.unwrap_or(0)
    }

    fn get_gold_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_reason
    }

    fn mut_gold_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_reason
    }

    // optional float timestamp_raw = 24;

    pub fn clear_timestamp_raw(&mut self) {
        self.timestamp_raw = ::std::option::Option::None;
    }

    pub fn has_timestamp_raw(&self) -> bool {
        self.timestamp_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_raw(&mut self, v: f32) {
        self.timestamp_raw = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp_raw(&self) -> f32 {
        self.timestamp_raw.unwrap_or(0.)
    }

    fn get_timestamp_raw_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.timestamp_raw
    }

    fn mut_timestamp_raw_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.timestamp_raw
    }

    // optional float modifier_duration = 25;

    pub fn clear_modifier_duration(&mut self) {
        self.modifier_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_duration(&self) -> bool {
        self.modifier_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_duration(&mut self, v: f32) {
        self.modifier_duration = ::std::option::Option::Some(v);
    }

    pub fn get_modifier_duration(&self) -> f32 {
        self.modifier_duration.unwrap_or(0.)
    }

    fn get_modifier_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.modifier_duration
    }

    fn mut_modifier_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.modifier_duration
    }

    // optional uint32 xp_reason = 26;

    pub fn clear_xp_reason(&mut self) {
        self.xp_reason = ::std::option::Option::None;
    }

    pub fn has_xp_reason(&self) -> bool {
        self.xp_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_reason(&mut self, v: u32) {
        self.xp_reason = ::std::option::Option::Some(v);
    }

    pub fn get_xp_reason(&self) -> u32 {
        self.xp_reason.unwrap_or(0)
    }

    fn get_xp_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_reason
    }

    fn mut_xp_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_reason
    }

    // optional uint32 last_hits = 27;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 attacker_team = 28;

    pub fn clear_attacker_team(&mut self) {
        self.attacker_team = ::std::option::Option::None;
    }

    pub fn has_attacker_team(&self) -> bool {
        self.attacker_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_team(&mut self, v: u32) {
        self.attacker_team = ::std::option::Option::Some(v);
    }

    pub fn get_attacker_team(&self) -> u32 {
        self.attacker_team.unwrap_or(0)
    }

    fn get_attacker_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attacker_team
    }

    fn mut_attacker_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attacker_team
    }

    // optional uint32 target_team = 29;

    pub fn clear_target_team(&mut self) {
        self.target_team = ::std::option::Option::None;
    }

    pub fn has_target_team(&self) -> bool {
        self.target_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_team(&mut self, v: u32) {
        self.target_team = ::std::option::Option::Some(v);
    }

    pub fn get_target_team(&self) -> u32 {
        self.target_team.unwrap_or(0)
    }

    fn get_target_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_team
    }

    fn mut_target_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_team
    }

    // optional uint32 obs_wards_placed = 30;

    pub fn clear_obs_wards_placed(&mut self) {
        self.obs_wards_placed = ::std::option::Option::None;
    }

    pub fn has_obs_wards_placed(&self) -> bool {
        self.obs_wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_wards_placed(&mut self, v: u32) {
        self.obs_wards_placed = ::std::option::Option::Some(v);
    }

    pub fn get_obs_wards_placed(&self) -> u32 {
        self.obs_wards_placed.unwrap_or(0)
    }

    fn get_obs_wards_placed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.obs_wards_placed
    }

    fn mut_obs_wards_placed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.obs_wards_placed
    }

    // optional uint32 assist_player0 = 31;

    pub fn clear_assist_player0(&mut self) {
        self.assist_player0 = ::std::option::Option::None;
    }

    pub fn has_assist_player0(&self) -> bool {
        self.assist_player0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player0(&mut self, v: u32) {
        self.assist_player0 = ::std::option::Option::Some(v);
    }

    pub fn get_assist_player0(&self) -> u32 {
        self.assist_player0.unwrap_or(0)
    }

    fn get_assist_player0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assist_player0
    }

    fn mut_assist_player0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assist_player0
    }

    // optional uint32 assist_player1 = 32;

    pub fn clear_assist_player1(&mut self) {
        self.assist_player1 = ::std::option::Option::None;
    }

    pub fn has_assist_player1(&self) -> bool {
        self.assist_player1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player1(&mut self, v: u32) {
        self.assist_player1 = ::std::option::Option::Some(v);
    }

    pub fn get_assist_player1(&self) -> u32 {
        self.assist_player1.unwrap_or(0)
    }

    fn get_assist_player1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assist_player1
    }

    fn mut_assist_player1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assist_player1
    }

    // optional uint32 assist_player2 = 33;

    pub fn clear_assist_player2(&mut self) {
        self.assist_player2 = ::std::option::Option::None;
    }

    pub fn has_assist_player2(&self) -> bool {
        self.assist_player2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player2(&mut self, v: u32) {
        self.assist_player2 = ::std::option::Option::Some(v);
    }

    pub fn get_assist_player2(&self) -> u32 {
        self.assist_player2.unwrap_or(0)
    }

    fn get_assist_player2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assist_player2
    }

    fn mut_assist_player2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assist_player2
    }

    // optional uint32 assist_player3 = 34;

    pub fn clear_assist_player3(&mut self) {
        self.assist_player3 = ::std::option::Option::None;
    }

    pub fn has_assist_player3(&self) -> bool {
        self.assist_player3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assist_player3(&mut self, v: u32) {
        self.assist_player3 = ::std::option::Option::Some(v);
    }

    pub fn get_assist_player3(&self) -> u32 {
        self.assist_player3.unwrap_or(0)
    }

    fn get_assist_player3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assist_player3
    }

    fn mut_assist_player3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assist_player3
    }

    // optional uint32 stack_count = 35;

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    pub fn get_stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    fn get_stack_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stack_count
    }

    fn mut_stack_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stack_count
    }

    // optional bool hidden_modifier = 36;

    pub fn clear_hidden_modifier(&mut self) {
        self.hidden_modifier = ::std::option::Option::None;
    }

    pub fn has_hidden_modifier(&self) -> bool {
        self.hidden_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_modifier(&mut self, v: bool) {
        self.hidden_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_hidden_modifier(&self) -> bool {
        self.hidden_modifier.unwrap_or(false)
    }

    fn get_hidden_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hidden_modifier
    }

    fn mut_hidden_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hidden_modifier
    }

    // optional bool is_target_building = 37;

    pub fn clear_is_target_building(&mut self) {
        self.is_target_building = ::std::option::Option::None;
    }

    pub fn has_is_target_building(&self) -> bool {
        self.is_target_building.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_target_building(&mut self, v: bool) {
        self.is_target_building = ::std::option::Option::Some(v);
    }

    pub fn get_is_target_building(&self) -> bool {
        self.is_target_building.unwrap_or(false)
    }

    fn get_is_target_building_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_target_building
    }

    fn mut_is_target_building_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_target_building
    }

    // optional uint32 neutral_camp_type = 38;

    pub fn clear_neutral_camp_type(&mut self) {
        self.neutral_camp_type = ::std::option::Option::None;
    }

    pub fn has_neutral_camp_type(&self) -> bool {
        self.neutral_camp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_camp_type(&mut self, v: u32) {
        self.neutral_camp_type = ::std::option::Option::Some(v);
    }

    pub fn get_neutral_camp_type(&self) -> u32 {
        self.neutral_camp_type.unwrap_or(0)
    }

    fn get_neutral_camp_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.neutral_camp_type
    }

    fn mut_neutral_camp_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.neutral_camp_type
    }

    // optional uint32 rune_type = 39;

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: u32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    pub fn get_rune_type(&self) -> u32 {
        self.rune_type.unwrap_or(0)
    }

    fn get_rune_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rune_type
    }

    fn mut_rune_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rune_type
    }

    // repeated uint32 assist_players = 40;

    pub fn clear_assist_players(&mut self) {
        self.assist_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_assist_players(&mut self, v: ::std::vec::Vec<u32>) {
        self.assist_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assist_players(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.assist_players
    }

    // Take field
    pub fn take_assist_players(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.assist_players, ::std::vec::Vec::new())
    }

    pub fn get_assist_players(&self) -> &[u32] {
        &self.assist_players
    }

    fn get_assist_players_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.assist_players
    }

    fn mut_assist_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.assist_players
    }

    // optional bool is_heal_save = 41;

    pub fn clear_is_heal_save(&mut self) {
        self.is_heal_save = ::std::option::Option::None;
    }

    pub fn has_is_heal_save(&self) -> bool {
        self.is_heal_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_heal_save(&mut self, v: bool) {
        self.is_heal_save = ::std::option::Option::Some(v);
    }

    pub fn get_is_heal_save(&self) -> bool {
        self.is_heal_save.unwrap_or(false)
    }

    fn get_is_heal_save_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_heal_save
    }

    fn mut_is_heal_save_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_heal_save
    }

    // optional bool is_ultimate_ability = 42;

    pub fn clear_is_ultimate_ability(&mut self) {
        self.is_ultimate_ability = ::std::option::Option::None;
    }

    pub fn has_is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ultimate_ability(&mut self, v: bool) {
        self.is_ultimate_ability = ::std::option::Option::Some(v);
    }

    pub fn get_is_ultimate_ability(&self) -> bool {
        self.is_ultimate_ability.unwrap_or(false)
    }

    fn get_is_ultimate_ability_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_ultimate_ability
    }

    fn mut_is_ultimate_ability_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_ultimate_ability
    }

    // optional uint32 attacker_hero_level = 43;

    pub fn clear_attacker_hero_level(&mut self) {
        self.attacker_hero_level = ::std::option::Option::None;
    }

    pub fn has_attacker_hero_level(&self) -> bool {
        self.attacker_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_hero_level(&mut self, v: u32) {
        self.attacker_hero_level = ::std::option::Option::Some(v);
    }

    pub fn get_attacker_hero_level(&self) -> u32 {
        self.attacker_hero_level.unwrap_or(0)
    }

    fn get_attacker_hero_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attacker_hero_level
    }

    fn mut_attacker_hero_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attacker_hero_level
    }

    // optional uint32 target_hero_level = 44;

    pub fn clear_target_hero_level(&mut self) {
        self.target_hero_level = ::std::option::Option::None;
    }

    pub fn has_target_hero_level(&self) -> bool {
        self.target_hero_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_level(&mut self, v: u32) {
        self.target_hero_level = ::std::option::Option::Some(v);
    }

    pub fn get_target_hero_level(&self) -> u32 {
        self.target_hero_level.unwrap_or(0)
    }

    fn get_target_hero_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_hero_level
    }

    fn mut_target_hero_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_hero_level
    }

    // optional uint32 xpm = 45;

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    pub fn get_xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    fn get_xpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xpm
    }

    fn mut_xpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xpm
    }

    // optional uint32 gpm = 46;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gpm
    }

    // optional uint32 event_location = 47;

    pub fn clear_event_location(&mut self) {
        self.event_location = ::std::option::Option::None;
    }

    pub fn has_event_location(&self) -> bool {
        self.event_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_location(&mut self, v: u32) {
        self.event_location = ::std::option::Option::Some(v);
    }

    pub fn get_event_location(&self) -> u32 {
        self.event_location.unwrap_or(0)
    }

    fn get_event_location_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_location
    }

    fn mut_event_location_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_location
    }

    // optional bool target_is_self = 48;

    pub fn clear_target_is_self(&mut self) {
        self.target_is_self = ::std::option::Option::None;
    }

    pub fn has_target_is_self(&self) -> bool {
        self.target_is_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_is_self(&mut self, v: bool) {
        self.target_is_self = ::std::option::Option::Some(v);
    }

    pub fn get_target_is_self(&self) -> bool {
        self.target_is_self.unwrap_or(false)
    }

    fn get_target_is_self_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.target_is_self
    }

    fn mut_target_is_self_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.target_is_self
    }

    // optional uint32 damage_type = 49;

    pub fn clear_damage_type(&mut self) {
        self.damage_type = ::std::option::Option::None;
    }

    pub fn has_damage_type(&self) -> bool {
        self.damage_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_type(&mut self, v: u32) {
        self.damage_type = ::std::option::Option::Some(v);
    }

    pub fn get_damage_type(&self) -> u32 {
        self.damage_type.unwrap_or(0)
    }

    fn get_damage_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage_type
    }

    fn mut_damage_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage_type
    }

    // optional bool invisibility_modifier = 50;

    pub fn clear_invisibility_modifier(&mut self) {
        self.invisibility_modifier = ::std::option::Option::None;
    }

    pub fn has_invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invisibility_modifier(&mut self, v: bool) {
        self.invisibility_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_invisibility_modifier(&self) -> bool {
        self.invisibility_modifier.unwrap_or(false)
    }

    fn get_invisibility_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.invisibility_modifier
    }

    fn mut_invisibility_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.invisibility_modifier
    }

    // optional uint32 damage_category = 51;

    pub fn clear_damage_category(&mut self) {
        self.damage_category = ::std::option::Option::None;
    }

    pub fn has_damage_category(&self) -> bool {
        self.damage_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_category(&mut self, v: u32) {
        self.damage_category = ::std::option::Option::Some(v);
    }

    pub fn get_damage_category(&self) -> u32 {
        self.damage_category.unwrap_or(0)
    }

    fn get_damage_category_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage_category
    }

    fn mut_damage_category_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage_category
    }

    // optional uint32 networth = 52;

    pub fn clear_networth(&mut self) {
        self.networth = ::std::option::Option::None;
    }

    pub fn has_networth(&self) -> bool {
        self.networth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networth(&mut self, v: u32) {
        self.networth = ::std::option::Option::Some(v);
    }

    pub fn get_networth(&self) -> u32 {
        self.networth.unwrap_or(0)
    }

    fn get_networth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.networth
    }

    fn mut_networth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.networth
    }

    // optional uint32 building_type = 53;

    pub fn clear_building_type(&mut self) {
        self.building_type = ::std::option::Option::None;
    }

    pub fn has_building_type(&self) -> bool {
        self.building_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_type(&mut self, v: u32) {
        self.building_type = ::std::option::Option::Some(v);
    }

    pub fn get_building_type(&self) -> u32 {
        self.building_type.unwrap_or(0)
    }

    fn get_building_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.building_type
    }

    fn mut_building_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.building_type
    }

    // optional float modifier_elapsed_duration = 54;

    pub fn clear_modifier_elapsed_duration(&mut self) {
        self.modifier_elapsed_duration = ::std::option::Option::None;
    }

    pub fn has_modifier_elapsed_duration(&self) -> bool {
        self.modifier_elapsed_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_elapsed_duration(&mut self, v: f32) {
        self.modifier_elapsed_duration = ::std::option::Option::Some(v);
    }

    pub fn get_modifier_elapsed_duration(&self) -> f32 {
        self.modifier_elapsed_duration.unwrap_or(0.)
    }

    fn get_modifier_elapsed_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.modifier_elapsed_duration
    }

    fn mut_modifier_elapsed_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.modifier_elapsed_duration
    }

    // optional bool silence_modifier = 55;

    pub fn clear_silence_modifier(&mut self) {
        self.silence_modifier = ::std::option::Option::None;
    }

    pub fn has_silence_modifier(&self) -> bool {
        self.silence_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_silence_modifier(&mut self, v: bool) {
        self.silence_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_silence_modifier(&self) -> bool {
        self.silence_modifier.unwrap_or(false)
    }

    fn get_silence_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.silence_modifier
    }

    fn mut_silence_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.silence_modifier
    }

    // optional bool heal_from_lifesteal = 56;

    pub fn clear_heal_from_lifesteal(&mut self) {
        self.heal_from_lifesteal = ::std::option::Option::None;
    }

    pub fn has_heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heal_from_lifesteal(&mut self, v: bool) {
        self.heal_from_lifesteal = ::std::option::Option::Some(v);
    }

    pub fn get_heal_from_lifesteal(&self) -> bool {
        self.heal_from_lifesteal.unwrap_or(false)
    }

    fn get_heal_from_lifesteal_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.heal_from_lifesteal
    }

    fn mut_heal_from_lifesteal_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.heal_from_lifesteal
    }

    // optional bool modifier_purged = 57;

    pub fn clear_modifier_purged(&mut self) {
        self.modifier_purged = ::std::option::Option::None;
    }

    pub fn has_modifier_purged(&self) -> bool {
        self.modifier_purged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purged(&mut self, v: bool) {
        self.modifier_purged = ::std::option::Option::Some(v);
    }

    pub fn get_modifier_purged(&self) -> bool {
        self.modifier_purged.unwrap_or(false)
    }

    fn get_modifier_purged_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.modifier_purged
    }

    fn mut_modifier_purged_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.modifier_purged
    }

    // optional bool spell_evaded = 58;

    pub fn clear_spell_evaded(&mut self) {
        self.spell_evaded = ::std::option::Option::None;
    }

    pub fn has_spell_evaded(&self) -> bool {
        self.spell_evaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spell_evaded(&mut self, v: bool) {
        self.spell_evaded = ::std::option::Option::Some(v);
    }

    pub fn get_spell_evaded(&self) -> bool {
        self.spell_evaded.unwrap_or(false)
    }

    fn get_spell_evaded_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.spell_evaded
    }

    fn mut_spell_evaded_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.spell_evaded
    }

    // optional bool motion_controller_modifier = 59;

    pub fn clear_motion_controller_modifier(&mut self) {
        self.motion_controller_modifier = ::std::option::Option::None;
    }

    pub fn has_motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motion_controller_modifier(&mut self, v: bool) {
        self.motion_controller_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_motion_controller_modifier(&self) -> bool {
        self.motion_controller_modifier.unwrap_or(false)
    }

    fn get_motion_controller_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.motion_controller_modifier
    }

    fn mut_motion_controller_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.motion_controller_modifier
    }

    // optional bool long_range_kill = 60;

    pub fn clear_long_range_kill(&mut self) {
        self.long_range_kill = ::std::option::Option::None;
    }

    pub fn has_long_range_kill(&self) -> bool {
        self.long_range_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_range_kill(&mut self, v: bool) {
        self.long_range_kill = ::std::option::Option::Some(v);
    }

    pub fn get_long_range_kill(&self) -> bool {
        self.long_range_kill.unwrap_or(false)
    }

    fn get_long_range_kill_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.long_range_kill
    }

    fn mut_long_range_kill_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.long_range_kill
    }

    // optional uint32 modifier_purge_ability = 61;

    pub fn clear_modifier_purge_ability(&mut self) {
        self.modifier_purge_ability = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_ability(&self) -> bool {
        self.modifier_purge_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_ability(&mut self, v: u32) {
        self.modifier_purge_ability = ::std::option::Option::Some(v);
    }

    pub fn get_modifier_purge_ability(&self) -> u32 {
        self.modifier_purge_ability.unwrap_or(0)
    }

    fn get_modifier_purge_ability_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.modifier_purge_ability
    }

    fn mut_modifier_purge_ability_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.modifier_purge_ability
    }

    // optional uint32 modifier_purge_npc = 62;

    pub fn clear_modifier_purge_npc(&mut self) {
        self.modifier_purge_npc = ::std::option::Option::None;
    }

    pub fn has_modifier_purge_npc(&self) -> bool {
        self.modifier_purge_npc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_purge_npc(&mut self, v: u32) {
        self.modifier_purge_npc = ::std::option::Option::Some(v);
    }

    pub fn get_modifier_purge_npc(&self) -> u32 {
        self.modifier_purge_npc.unwrap_or(0)
    }

    fn get_modifier_purge_npc_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.modifier_purge_npc
    }

    fn mut_modifier_purge_npc_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.modifier_purge_npc
    }

    // optional bool root_modifier = 63;

    pub fn clear_root_modifier(&mut self) {
        self.root_modifier = ::std::option::Option::None;
    }

    pub fn has_root_modifier(&self) -> bool {
        self.root_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_modifier(&mut self, v: bool) {
        self.root_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_root_modifier(&self) -> bool {
        self.root_modifier.unwrap_or(false)
    }

    fn get_root_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.root_modifier
    }

    fn mut_root_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.root_modifier
    }

    // optional uint32 total_unit_death_count = 64;

    pub fn clear_total_unit_death_count(&mut self) {
        self.total_unit_death_count = ::std::option::Option::None;
    }

    pub fn has_total_unit_death_count(&self) -> bool {
        self.total_unit_death_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_unit_death_count(&mut self, v: u32) {
        self.total_unit_death_count = ::std::option::Option::Some(v);
    }

    pub fn get_total_unit_death_count(&self) -> u32 {
        self.total_unit_death_count.unwrap_or(0)
    }

    fn get_total_unit_death_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_unit_death_count
    }

    fn mut_total_unit_death_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_unit_death_count
    }

    // optional bool aura_modifier = 65;

    pub fn clear_aura_modifier(&mut self) {
        self.aura_modifier = ::std::option::Option::None;
    }

    pub fn has_aura_modifier(&self) -> bool {
        self.aura_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aura_modifier(&mut self, v: bool) {
        self.aura_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_aura_modifier(&self) -> bool {
        self.aura_modifier.unwrap_or(false)
    }

    fn get_aura_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.aura_modifier
    }

    fn mut_aura_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.aura_modifier
    }

    // optional bool armor_debuff_modifier = 66;

    pub fn clear_armor_debuff_modifier(&mut self) {
        self.armor_debuff_modifier = ::std::option::Option::None;
    }

    pub fn has_armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_debuff_modifier(&mut self, v: bool) {
        self.armor_debuff_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_armor_debuff_modifier(&self) -> bool {
        self.armor_debuff_modifier.unwrap_or(false)
    }

    fn get_armor_debuff_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.armor_debuff_modifier
    }

    fn mut_armor_debuff_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.armor_debuff_modifier
    }

    // optional bool no_physical_damage_modifier = 67;

    pub fn clear_no_physical_damage_modifier(&mut self) {
        self.no_physical_damage_modifier = ::std::option::Option::None;
    }

    pub fn has_no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_physical_damage_modifier(&mut self, v: bool) {
        self.no_physical_damage_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_no_physical_damage_modifier(&self) -> bool {
        self.no_physical_damage_modifier.unwrap_or(false)
    }

    fn get_no_physical_damage_modifier_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.no_physical_damage_modifier
    }

    fn mut_no_physical_damage_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.no_physical_damage_modifier
    }
}

impl ::protobuf::Message for CMsgDOTACombatLogEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_name = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_source_name = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attacker_name = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_source_name = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inflictor_name = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_attacker_illusion = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_attacker_hero = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_target_illusion = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_target_hero = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_visible_radiant = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_visible_dire = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.health = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stun_duration = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.slow_duration = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ability_toggle_on = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ability_toggle_off = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_level = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.location_x = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.location_y = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_reason = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp_raw = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.modifier_duration = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_reason = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attacker_team = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_team = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.obs_wards_placed = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assist_player0 = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assist_player1 = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assist_player2 = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assist_player3 = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stack_count = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden_modifier = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_target_building = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.neutral_camp_type = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rune_type = ::std::option::Option::Some(tmp);
                },
                40 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.assist_players)?;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_heal_save = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ultimate_ability = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attacker_hero_level = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_hero_level = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xpm = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_location = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.target_is_self = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_type = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invisibility_modifier = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_category = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.networth = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.building_type = ::std::option::Option::Some(tmp);
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.modifier_elapsed_duration = ::std::option::Option::Some(tmp);
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.silence_modifier = ::std::option::Option::Some(tmp);
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.heal_from_lifesteal = ::std::option::Option::Some(tmp);
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.modifier_purged = ::std::option::Option::Some(tmp);
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spell_evaded = ::std::option::Option::Some(tmp);
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.motion_controller_modifier = ::std::option::Option::Some(tmp);
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.long_range_kill = ::std::option::Option::Some(tmp);
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifier_purge_ability = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifier_purge_npc = ::std::option::Option::Some(tmp);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.root_modifier = ::std::option::Option::Some(tmp);
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_unit_death_count = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aura_modifier = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armor_debuff_modifier = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_physical_damage_modifier = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.target_name {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_source_name {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attacker_name {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_source_name {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inflictor_name {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_attacker_illusion {
            my_size += 2;
        }
        if let Some(v) = self.is_attacker_hero {
            my_size += 2;
        }
        if let Some(v) = self.is_target_illusion {
            my_size += 2;
        }
        if let Some(v) = self.is_target_hero {
            my_size += 2;
        }
        if let Some(v) = self.is_visible_radiant {
            my_size += 2;
        }
        if let Some(v) = self.is_visible_dire {
            my_size += 2;
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.stun_duration {
            my_size += 6;
        }
        if let Some(v) = self.slow_duration {
            my_size += 6;
        }
        if let Some(v) = self.is_ability_toggle_on {
            my_size += 3;
        }
        if let Some(v) = self.is_ability_toggle_off {
            my_size += 3;
        }
        if let Some(v) = self.ability_level {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.location_x {
            my_size += 6;
        }
        if let Some(v) = self.location_y {
            my_size += 6;
        }
        if let Some(v) = self.gold_reason {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp_raw {
            my_size += 6;
        }
        if let Some(v) = self.modifier_duration {
            my_size += 6;
        }
        if let Some(v) = self.xp_reason {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attacker_team {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_team {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.obs_wards_placed {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assist_player0 {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assist_player1 {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assist_player2 {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assist_player3 {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hidden_modifier {
            my_size += 3;
        }
        if let Some(v) = self.is_target_building {
            my_size += 3;
        }
        if let Some(v) = self.neutral_camp_type {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rune_type {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.assist_players {
            my_size += ::protobuf::rt::value_size(40, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.is_heal_save {
            my_size += 3;
        }
        if let Some(v) = self.is_ultimate_ability {
            my_size += 3;
        }
        if let Some(v) = self.attacker_hero_level {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_hero_level {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_location {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_is_self {
            my_size += 3;
        }
        if let Some(v) = self.damage_type {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.invisibility_modifier {
            my_size += 3;
        }
        if let Some(v) = self.damage_category {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.networth {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.building_type {
            my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifier_elapsed_duration {
            my_size += 6;
        }
        if let Some(v) = self.silence_modifier {
            my_size += 3;
        }
        if let Some(v) = self.heal_from_lifesteal {
            my_size += 3;
        }
        if let Some(v) = self.modifier_purged {
            my_size += 3;
        }
        if let Some(v) = self.spell_evaded {
            my_size += 3;
        }
        if let Some(v) = self.motion_controller_modifier {
            my_size += 3;
        }
        if let Some(v) = self.long_range_kill {
            my_size += 3;
        }
        if let Some(v) = self.modifier_purge_ability {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifier_purge_npc {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.root_modifier {
            my_size += 3;
        }
        if let Some(v) = self.total_unit_death_count {
            my_size += ::protobuf::rt::value_size(64, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aura_modifier {
            my_size += 3;
        }
        if let Some(v) = self.armor_debuff_modifier {
            my_size += 3;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.target_name {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.target_source_name {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attacker_name {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.damage_source_name {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.inflictor_name {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_attacker_illusion {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_attacker_hero {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_target_illusion {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_target_hero {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.is_visible_radiant {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_visible_dire {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.health {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.stun_duration {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.slow_duration {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.is_ability_toggle_on {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.is_ability_toggle_off {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.location_x {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.location_y {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.gold_reason {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.timestamp_raw {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.modifier_duration {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.xp_reason {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.attacker_team {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.target_team {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.obs_wards_placed {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.assist_player0 {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.assist_player1 {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.assist_player2 {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.assist_player3 {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.hidden_modifier {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.is_target_building {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.neutral_camp_type {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_uint32(39, v)?;
        }
        for v in &self.assist_players {
            os.write_uint32(40, *v)?;
        };
        if let Some(v) = self.is_heal_save {
            os.write_bool(41, v)?;
        }
        if let Some(v) = self.is_ultimate_ability {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.attacker_hero_level {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.target_hero_level {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.event_location {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.target_is_self {
            os.write_bool(48, v)?;
        }
        if let Some(v) = self.damage_type {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.invisibility_modifier {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.damage_category {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.networth {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.building_type {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.modifier_elapsed_duration {
            os.write_float(54, v)?;
        }
        if let Some(v) = self.silence_modifier {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.heal_from_lifesteal {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.modifier_purged {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.spell_evaded {
            os.write_bool(58, v)?;
        }
        if let Some(v) = self.motion_controller_modifier {
            os.write_bool(59, v)?;
        }
        if let Some(v) = self.long_range_kill {
            os.write_bool(60, v)?;
        }
        if let Some(v) = self.modifier_purge_ability {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.modifier_purge_npc {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.root_modifier {
            os.write_bool(63, v)?;
        }
        if let Some(v) = self.total_unit_death_count {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.aura_modifier {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.armor_debuff_modifier {
            os.write_bool(66, v)?;
        }
        if let Some(v) = self.no_physical_damage_modifier {
            os.write_bool(67, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACombatLogEntry {
    fn new() -> CMsgDOTACombatLogEntry {
        CMsgDOTACombatLogEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACombatLogEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_COMBATLOG_TYPES>>(
                    "type",
                    CMsgDOTACombatLogEntry::get_field_type_for_reflect,
                    CMsgDOTACombatLogEntry::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_name",
                    CMsgDOTACombatLogEntry::get_target_name_for_reflect,
                    CMsgDOTACombatLogEntry::mut_target_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_source_name",
                    CMsgDOTACombatLogEntry::get_target_source_name_for_reflect,
                    CMsgDOTACombatLogEntry::mut_target_source_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attacker_name",
                    CMsgDOTACombatLogEntry::get_attacker_name_for_reflect,
                    CMsgDOTACombatLogEntry::mut_attacker_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_source_name",
                    CMsgDOTACombatLogEntry::get_damage_source_name_for_reflect,
                    CMsgDOTACombatLogEntry::mut_damage_source_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "inflictor_name",
                    CMsgDOTACombatLogEntry::get_inflictor_name_for_reflect,
                    CMsgDOTACombatLogEntry::mut_inflictor_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_attacker_illusion",
                    CMsgDOTACombatLogEntry::get_is_attacker_illusion_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_attacker_illusion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_attacker_hero",
                    CMsgDOTACombatLogEntry::get_is_attacker_hero_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_attacker_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_target_illusion",
                    CMsgDOTACombatLogEntry::get_is_target_illusion_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_target_illusion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_target_hero",
                    CMsgDOTACombatLogEntry::get_is_target_hero_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_target_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_visible_radiant",
                    CMsgDOTACombatLogEntry::get_is_visible_radiant_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_visible_radiant_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_visible_dire",
                    CMsgDOTACombatLogEntry::get_is_visible_dire_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_visible_dire_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CMsgDOTACombatLogEntry::get_value_for_reflect,
                    CMsgDOTACombatLogEntry::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "health",
                    CMsgDOTACombatLogEntry::get_health_for_reflect,
                    CMsgDOTACombatLogEntry::mut_health_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "timestamp",
                    CMsgDOTACombatLogEntry::get_timestamp_for_reflect,
                    CMsgDOTACombatLogEntry::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stun_duration",
                    CMsgDOTACombatLogEntry::get_stun_duration_for_reflect,
                    CMsgDOTACombatLogEntry::mut_stun_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "slow_duration",
                    CMsgDOTACombatLogEntry::get_slow_duration_for_reflect,
                    CMsgDOTACombatLogEntry::mut_slow_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_ability_toggle_on",
                    CMsgDOTACombatLogEntry::get_is_ability_toggle_on_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_ability_toggle_on_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_ability_toggle_off",
                    CMsgDOTACombatLogEntry::get_is_ability_toggle_off_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_ability_toggle_off_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_level",
                    CMsgDOTACombatLogEntry::get_ability_level_for_reflect,
                    CMsgDOTACombatLogEntry::mut_ability_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "location_x",
                    CMsgDOTACombatLogEntry::get_location_x_for_reflect,
                    CMsgDOTACombatLogEntry::mut_location_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "location_y",
                    CMsgDOTACombatLogEntry::get_location_y_for_reflect,
                    CMsgDOTACombatLogEntry::mut_location_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_reason",
                    CMsgDOTACombatLogEntry::get_gold_reason_for_reflect,
                    CMsgDOTACombatLogEntry::mut_gold_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "timestamp_raw",
                    CMsgDOTACombatLogEntry::get_timestamp_raw_for_reflect,
                    CMsgDOTACombatLogEntry::mut_timestamp_raw_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "modifier_duration",
                    CMsgDOTACombatLogEntry::get_modifier_duration_for_reflect,
                    CMsgDOTACombatLogEntry::mut_modifier_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_reason",
                    CMsgDOTACombatLogEntry::get_xp_reason_for_reflect,
                    CMsgDOTACombatLogEntry::mut_xp_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CMsgDOTACombatLogEntry::get_last_hits_for_reflect,
                    CMsgDOTACombatLogEntry::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attacker_team",
                    CMsgDOTACombatLogEntry::get_attacker_team_for_reflect,
                    CMsgDOTACombatLogEntry::mut_attacker_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_team",
                    CMsgDOTACombatLogEntry::get_target_team_for_reflect,
                    CMsgDOTACombatLogEntry::mut_target_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "obs_wards_placed",
                    CMsgDOTACombatLogEntry::get_obs_wards_placed_for_reflect,
                    CMsgDOTACombatLogEntry::mut_obs_wards_placed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assist_player0",
                    CMsgDOTACombatLogEntry::get_assist_player0_for_reflect,
                    CMsgDOTACombatLogEntry::mut_assist_player0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assist_player1",
                    CMsgDOTACombatLogEntry::get_assist_player1_for_reflect,
                    CMsgDOTACombatLogEntry::mut_assist_player1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assist_player2",
                    CMsgDOTACombatLogEntry::get_assist_player2_for_reflect,
                    CMsgDOTACombatLogEntry::mut_assist_player2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assist_player3",
                    CMsgDOTACombatLogEntry::get_assist_player3_for_reflect,
                    CMsgDOTACombatLogEntry::mut_assist_player3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stack_count",
                    CMsgDOTACombatLogEntry::get_stack_count_for_reflect,
                    CMsgDOTACombatLogEntry::mut_stack_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hidden_modifier",
                    CMsgDOTACombatLogEntry::get_hidden_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_hidden_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_target_building",
                    CMsgDOTACombatLogEntry::get_is_target_building_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_target_building_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "neutral_camp_type",
                    CMsgDOTACombatLogEntry::get_neutral_camp_type_for_reflect,
                    CMsgDOTACombatLogEntry::mut_neutral_camp_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rune_type",
                    CMsgDOTACombatLogEntry::get_rune_type_for_reflect,
                    CMsgDOTACombatLogEntry::mut_rune_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assist_players",
                    CMsgDOTACombatLogEntry::get_assist_players_for_reflect,
                    CMsgDOTACombatLogEntry::mut_assist_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_heal_save",
                    CMsgDOTACombatLogEntry::get_is_heal_save_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_heal_save_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_ultimate_ability",
                    CMsgDOTACombatLogEntry::get_is_ultimate_ability_for_reflect,
                    CMsgDOTACombatLogEntry::mut_is_ultimate_ability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attacker_hero_level",
                    CMsgDOTACombatLogEntry::get_attacker_hero_level_for_reflect,
                    CMsgDOTACombatLogEntry::mut_attacker_hero_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_hero_level",
                    CMsgDOTACombatLogEntry::get_target_hero_level_for_reflect,
                    CMsgDOTACombatLogEntry::mut_target_hero_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xpm",
                    CMsgDOTACombatLogEntry::get_xpm_for_reflect,
                    CMsgDOTACombatLogEntry::mut_xpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gpm",
                    CMsgDOTACombatLogEntry::get_gpm_for_reflect,
                    CMsgDOTACombatLogEntry::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_location",
                    CMsgDOTACombatLogEntry::get_event_location_for_reflect,
                    CMsgDOTACombatLogEntry::mut_event_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "target_is_self",
                    CMsgDOTACombatLogEntry::get_target_is_self_for_reflect,
                    CMsgDOTACombatLogEntry::mut_target_is_self_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_type",
                    CMsgDOTACombatLogEntry::get_damage_type_for_reflect,
                    CMsgDOTACombatLogEntry::mut_damage_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "invisibility_modifier",
                    CMsgDOTACombatLogEntry::get_invisibility_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_invisibility_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_category",
                    CMsgDOTACombatLogEntry::get_damage_category_for_reflect,
                    CMsgDOTACombatLogEntry::mut_damage_category_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "networth",
                    CMsgDOTACombatLogEntry::get_networth_for_reflect,
                    CMsgDOTACombatLogEntry::mut_networth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "building_type",
                    CMsgDOTACombatLogEntry::get_building_type_for_reflect,
                    CMsgDOTACombatLogEntry::mut_building_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "modifier_elapsed_duration",
                    CMsgDOTACombatLogEntry::get_modifier_elapsed_duration_for_reflect,
                    CMsgDOTACombatLogEntry::mut_modifier_elapsed_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "silence_modifier",
                    CMsgDOTACombatLogEntry::get_silence_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_silence_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "heal_from_lifesteal",
                    CMsgDOTACombatLogEntry::get_heal_from_lifesteal_for_reflect,
                    CMsgDOTACombatLogEntry::mut_heal_from_lifesteal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "modifier_purged",
                    CMsgDOTACombatLogEntry::get_modifier_purged_for_reflect,
                    CMsgDOTACombatLogEntry::mut_modifier_purged_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spell_evaded",
                    CMsgDOTACombatLogEntry::get_spell_evaded_for_reflect,
                    CMsgDOTACombatLogEntry::mut_spell_evaded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "motion_controller_modifier",
                    CMsgDOTACombatLogEntry::get_motion_controller_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_motion_controller_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "long_range_kill",
                    CMsgDOTACombatLogEntry::get_long_range_kill_for_reflect,
                    CMsgDOTACombatLogEntry::mut_long_range_kill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifier_purge_ability",
                    CMsgDOTACombatLogEntry::get_modifier_purge_ability_for_reflect,
                    CMsgDOTACombatLogEntry::mut_modifier_purge_ability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifier_purge_npc",
                    CMsgDOTACombatLogEntry::get_modifier_purge_npc_for_reflect,
                    CMsgDOTACombatLogEntry::mut_modifier_purge_npc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "root_modifier",
                    CMsgDOTACombatLogEntry::get_root_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_root_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_unit_death_count",
                    CMsgDOTACombatLogEntry::get_total_unit_death_count_for_reflect,
                    CMsgDOTACombatLogEntry::mut_total_unit_death_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "aura_modifier",
                    CMsgDOTACombatLogEntry::get_aura_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_aura_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "armor_debuff_modifier",
                    CMsgDOTACombatLogEntry::get_armor_debuff_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_armor_debuff_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_physical_damage_modifier",
                    CMsgDOTACombatLogEntry::get_no_physical_damage_modifier_for_reflect,
                    CMsgDOTACombatLogEntry::mut_no_physical_damage_modifier_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACombatLogEntry>(
                    "CMsgDOTACombatLogEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACombatLogEntry {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_target_name();
        self.clear_target_source_name();
        self.clear_attacker_name();
        self.clear_damage_source_name();
        self.clear_inflictor_name();
        self.clear_is_attacker_illusion();
        self.clear_is_attacker_hero();
        self.clear_is_target_illusion();
        self.clear_is_target_hero();
        self.clear_is_visible_radiant();
        self.clear_is_visible_dire();
        self.clear_value();
        self.clear_health();
        self.clear_timestamp();
        self.clear_stun_duration();
        self.clear_slow_duration();
        self.clear_is_ability_toggle_on();
        self.clear_is_ability_toggle_off();
        self.clear_ability_level();
        self.clear_location_x();
        self.clear_location_y();
        self.clear_gold_reason();
        self.clear_timestamp_raw();
        self.clear_modifier_duration();
        self.clear_xp_reason();
        self.clear_last_hits();
        self.clear_attacker_team();
        self.clear_target_team();
        self.clear_obs_wards_placed();
        self.clear_assist_player0();
        self.clear_assist_player1();
        self.clear_assist_player2();
        self.clear_assist_player3();
        self.clear_stack_count();
        self.clear_hidden_modifier();
        self.clear_is_target_building();
        self.clear_neutral_camp_type();
        self.clear_rune_type();
        self.clear_assist_players();
        self.clear_is_heal_save();
        self.clear_is_ultimate_ability();
        self.clear_attacker_hero_level();
        self.clear_target_hero_level();
        self.clear_xpm();
        self.clear_gpm();
        self.clear_event_location();
        self.clear_target_is_self();
        self.clear_damage_type();
        self.clear_invisibility_modifier();
        self.clear_damage_category();
        self.clear_networth();
        self.clear_building_type();
        self.clear_modifier_elapsed_duration();
        self.clear_silence_modifier();
        self.clear_heal_from_lifesteal();
        self.clear_modifier_purged();
        self.clear_spell_evaded();
        self.clear_motion_controller_modifier();
        self.clear_long_range_kill();
        self.clear_modifier_purge_ability();
        self.clear_modifier_purge_npc();
        self.clear_root_modifier();
        self.clear_total_unit_death_count();
        self.clear_aura_modifier();
        self.clear_armor_debuff_modifier();
        self.clear_no_physical_damage_modifier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACombatLogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACombatLogEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    background_def_index: ::std::option::Option<u32>,
    slots: ::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot>,
    badge_points: ::std::option::Option<u32>,
    event_points: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    recent_battle_cup_victory: ::protobuf::SingularPtrField<CMsgBattleCupVictory>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard {}

impl CMsgDOTAProfileCard {
    pub fn new() -> CMsgDOTAProfileCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 background_def_index = 2;

    pub fn clear_background_def_index(&mut self) {
        self.background_def_index = ::std::option::Option::None;
    }

    pub fn has_background_def_index(&self) -> bool {
        self.background_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_def_index(&mut self, v: u32) {
        self.background_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_background_def_index(&self) -> u32 {
        self.background_def_index.unwrap_or(0)
    }

    fn get_background_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.background_def_index
    }

    fn mut_background_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.background_def_index
    }

    // repeated .CMsgDOTAProfileCard.Slot slots = 3;

    pub fn clear_slots(&mut self) {
        self.slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot>) {
        self.slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slots(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot> {
        &mut self.slots
    }

    // Take field
    pub fn take_slots(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot> {
        ::std::mem::replace(&mut self.slots, ::protobuf::RepeatedField::new())
    }

    pub fn get_slots(&self) -> &[CMsgDOTAProfileCard_Slot] {
        &self.slots
    }

    fn get_slots_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot> {
        &self.slots
    }

    fn mut_slots_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileCard_Slot> {
        &mut self.slots
    }

    // optional uint32 badge_points = 4;

    pub fn clear_badge_points(&mut self) {
        self.badge_points = ::std::option::Option::None;
    }

    pub fn has_badge_points(&self) -> bool {
        self.badge_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_points(&mut self, v: u32) {
        self.badge_points = ::std::option::Option::Some(v);
    }

    pub fn get_badge_points(&self) -> u32 {
        self.badge_points.unwrap_or(0)
    }

    fn get_badge_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.badge_points
    }

    fn mut_badge_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.badge_points
    }

    // optional uint32 event_points = 5;

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: u32) {
        self.event_points = ::std::option::Option::Some(v);
    }

    pub fn get_event_points(&self) -> u32 {
        self.event_points.unwrap_or(0)
    }

    fn get_event_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_points
    }

    fn mut_event_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_points
    }

    // optional uint32 event_id = 6;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional .CMsgBattleCupVictory recent_battle_cup_victory = 7;

    pub fn clear_recent_battle_cup_victory(&mut self) {
        self.recent_battle_cup_victory.clear();
    }

    pub fn has_recent_battle_cup_victory(&self) -> bool {
        self.recent_battle_cup_victory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_battle_cup_victory(&mut self, v: CMsgBattleCupVictory) {
        self.recent_battle_cup_victory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recent_battle_cup_victory(&mut self) -> &mut CMsgBattleCupVictory {
        if self.recent_battle_cup_victory.is_none() {
            self.recent_battle_cup_victory.set_default();
        }
        self.recent_battle_cup_victory.as_mut().unwrap()
    }

    // Take field
    pub fn take_recent_battle_cup_victory(&mut self) -> CMsgBattleCupVictory {
        self.recent_battle_cup_victory.take().unwrap_or_else(|| CMsgBattleCupVictory::new())
    }

    pub fn get_recent_battle_cup_victory(&self) -> &CMsgBattleCupVictory {
        self.recent_battle_cup_victory.as_ref().unwrap_or_else(|| CMsgBattleCupVictory::default_instance())
    }

    fn get_recent_battle_cup_victory_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgBattleCupVictory> {
        &self.recent_battle_cup_victory
    }

    fn mut_recent_battle_cup_victory_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgBattleCupVictory> {
        &mut self.recent_battle_cup_victory
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard {
    fn is_initialized(&self) -> bool {
        for v in &self.slots {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recent_battle_cup_victory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.background_def_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slots)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_points = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_points = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recent_battle_cup_victory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.background_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.badge_points {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_points {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.recent_battle_cup_victory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.background_def_index {
            os.write_uint32(2, v)?;
        }
        for v in &self.slots {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.badge_points {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_points {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.recent_battle_cup_victory.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard {
    fn new() -> CMsgDOTAProfileCard {
        CMsgDOTAProfileCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAProfileCard::get_account_id_for_reflect,
                    CMsgDOTAProfileCard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "background_def_index",
                    CMsgDOTAProfileCard::get_background_def_index_for_reflect,
                    CMsgDOTAProfileCard::mut_background_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot>>(
                    "slots",
                    CMsgDOTAProfileCard::get_slots_for_reflect,
                    CMsgDOTAProfileCard::mut_slots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "badge_points",
                    CMsgDOTAProfileCard::get_badge_points_for_reflect,
                    CMsgDOTAProfileCard::mut_badge_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_points",
                    CMsgDOTAProfileCard::get_event_points_for_reflect,
                    CMsgDOTAProfileCard::mut_event_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAProfileCard::get_event_id_for_reflect,
                    CMsgDOTAProfileCard::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgBattleCupVictory>>(
                    "recent_battle_cup_victory",
                    CMsgDOTAProfileCard::get_recent_battle_cup_victory_for_reflect,
                    CMsgDOTAProfileCard::mut_recent_battle_cup_victory_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard>(
                    "CMsgDOTAProfileCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_background_def_index();
        self.clear_slots();
        self.clear_badge_points();
        self.clear_event_points();
        self.clear_event_id();
        self.clear_recent_battle_cup_victory();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot {
    // message fields
    slot_id: ::std::option::Option<u32>,
    trophy: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Trophy>,
    stat: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Stat>,
    item: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Item>,
    hero: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Hero>,
    emoticon: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Emoticon>,
    team: ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Team>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot {}

impl CMsgDOTAProfileCard_Slot {
    pub fn new() -> CMsgDOTAProfileCard_Slot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot::new)
        }
    }

    // optional uint32 slot_id = 1;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional .CMsgDOTAProfileCard.Slot.Trophy trophy = 2;

    pub fn clear_trophy(&mut self) {
        self.trophy.clear();
    }

    pub fn has_trophy(&self) -> bool {
        self.trophy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy(&mut self, v: CMsgDOTAProfileCard_Slot_Trophy) {
        self.trophy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trophy(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Trophy {
        if self.trophy.is_none() {
            self.trophy.set_default();
        }
        self.trophy.as_mut().unwrap()
    }

    // Take field
    pub fn take_trophy(&mut self) -> CMsgDOTAProfileCard_Slot_Trophy {
        self.trophy.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Trophy::new())
    }

    pub fn get_trophy(&self) -> &CMsgDOTAProfileCard_Slot_Trophy {
        self.trophy.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Trophy::default_instance())
    }

    fn get_trophy_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Trophy> {
        &self.trophy
    }

    fn mut_trophy_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Trophy> {
        &mut self.trophy
    }

    // optional .CMsgDOTAProfileCard.Slot.Stat stat = 3;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: CMsgDOTAProfileCard_Slot_Stat) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Stat {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> CMsgDOTAProfileCard_Slot_Stat {
        self.stat.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Stat::new())
    }

    pub fn get_stat(&self) -> &CMsgDOTAProfileCard_Slot_Stat {
        self.stat.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Stat::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Stat> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Stat> {
        &mut self.stat
    }

    // optional .CMsgDOTAProfileCard.Slot.Item item = 4;

    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: CMsgDOTAProfileCard_Slot_Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> CMsgDOTAProfileCard_Slot_Item {
        self.item.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Item::new())
    }

    pub fn get_item(&self) -> &CMsgDOTAProfileCard_Slot_Item {
        self.item.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Item::default_instance())
    }

    fn get_item_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Item> {
        &self.item
    }

    fn mut_item_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Item> {
        &mut self.item
    }

    // optional .CMsgDOTAProfileCard.Slot.Hero hero = 5;

    pub fn clear_hero(&mut self) {
        self.hero.clear();
    }

    pub fn has_hero(&self) -> bool {
        self.hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero(&mut self, v: CMsgDOTAProfileCard_Slot_Hero) {
        self.hero = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Hero {
        if self.hero.is_none() {
            self.hero.set_default();
        }
        self.hero.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero(&mut self) -> CMsgDOTAProfileCard_Slot_Hero {
        self.hero.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Hero::new())
    }

    pub fn get_hero(&self) -> &CMsgDOTAProfileCard_Slot_Hero {
        self.hero.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Hero::default_instance())
    }

    fn get_hero_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Hero> {
        &self.hero
    }

    fn mut_hero_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Hero> {
        &mut self.hero
    }

    // optional .CMsgDOTAProfileCard.Slot.Emoticon emoticon = 6;

    pub fn clear_emoticon(&mut self) {
        self.emoticon.clear();
    }

    pub fn has_emoticon(&self) -> bool {
        self.emoticon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon(&mut self, v: CMsgDOTAProfileCard_Slot_Emoticon) {
        self.emoticon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoticon(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Emoticon {
        if self.emoticon.is_none() {
            self.emoticon.set_default();
        }
        self.emoticon.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoticon(&mut self) -> CMsgDOTAProfileCard_Slot_Emoticon {
        self.emoticon.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Emoticon::new())
    }

    pub fn get_emoticon(&self) -> &CMsgDOTAProfileCard_Slot_Emoticon {
        self.emoticon.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Emoticon::default_instance())
    }

    fn get_emoticon_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Emoticon> {
        &self.emoticon
    }

    fn mut_emoticon_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Emoticon> {
        &mut self.emoticon
    }

    // optional .CMsgDOTAProfileCard.Slot.Team team = 7;

    pub fn clear_team(&mut self) {
        self.team.clear();
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: CMsgDOTAProfileCard_Slot_Team) {
        self.team = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team(&mut self) -> &mut CMsgDOTAProfileCard_Slot_Team {
        if self.team.is_none() {
            self.team.set_default();
        }
        self.team.as_mut().unwrap()
    }

    // Take field
    pub fn take_team(&mut self) -> CMsgDOTAProfileCard_Slot_Team {
        self.team.take().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Team::new())
    }

    pub fn get_team(&self) -> &CMsgDOTAProfileCard_Slot_Team {
        self.team.as_ref().unwrap_or_else(|| CMsgDOTAProfileCard_Slot_Team::default_instance())
    }

    fn get_team_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Team> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileCard_Slot_Team> {
        &mut self.team
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot {
    fn is_initialized(&self) -> bool {
        for v in &self.trophy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hero {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.emoticon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.team {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trophy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hero)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.emoticon)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.team)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.trophy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hero.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.emoticon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.trophy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hero.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.emoticon.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.team.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot {
    fn new() -> CMsgDOTAProfileCard_Slot {
        CMsgDOTAProfileCard_Slot::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgDOTAProfileCard_Slot::get_slot_id_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Trophy>>(
                    "trophy",
                    CMsgDOTAProfileCard_Slot::get_trophy_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_trophy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Stat>>(
                    "stat",
                    CMsgDOTAProfileCard_Slot::get_stat_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Item>>(
                    "item",
                    CMsgDOTAProfileCard_Slot::get_item_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Hero>>(
                    "hero",
                    CMsgDOTAProfileCard_Slot::get_hero_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Emoticon>>(
                    "emoticon",
                    CMsgDOTAProfileCard_Slot::get_emoticon_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_emoticon_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileCard_Slot_Team>>(
                    "team",
                    CMsgDOTAProfileCard_Slot::get_team_for_reflect,
                    CMsgDOTAProfileCard_Slot::mut_team_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot>(
                    "CMsgDOTAProfileCard_Slot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot {
    fn clear(&mut self) {
        self.clear_slot_id();
        self.clear_trophy();
        self.clear_stat();
        self.clear_item();
        self.clear_hero();
        self.clear_emoticon();
        self.clear_team();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Trophy {
    // message fields
    trophy_id: ::std::option::Option<u32>,
    trophy_score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Trophy {}

impl CMsgDOTAProfileCard_Slot_Trophy {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Trophy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Trophy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Trophy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Trophy,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Trophy::new)
        }
    }

    // optional uint32 trophy_id = 1;

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    fn get_trophy_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_id
    }

    fn mut_trophy_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_id
    }

    // optional uint32 trophy_score = 2;

    pub fn clear_trophy_score(&mut self) {
        self.trophy_score = ::std::option::Option::None;
    }

    pub fn has_trophy_score(&self) -> bool {
        self.trophy_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_score(&mut self, v: u32) {
        self.trophy_score = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_score(&self) -> u32 {
        self.trophy_score.unwrap_or(0)
    }

    fn get_trophy_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_score
    }

    fn mut_trophy_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_score
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Trophy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trophy_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trophy_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trophy_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trophy_score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Trophy {
    fn new() -> CMsgDOTAProfileCard_Slot_Trophy {
        CMsgDOTAProfileCard_Slot_Trophy::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Trophy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_id",
                    CMsgDOTAProfileCard_Slot_Trophy::get_trophy_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Trophy::mut_trophy_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_score",
                    CMsgDOTAProfileCard_Slot_Trophy::get_trophy_score_for_reflect,
                    CMsgDOTAProfileCard_Slot_Trophy::mut_trophy_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Trophy>(
                    "CMsgDOTAProfileCard_Slot_Trophy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Trophy {
    fn clear(&mut self) {
        self.clear_trophy_id();
        self.clear_trophy_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Trophy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Trophy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Stat {
    // message fields
    stat_id: ::std::option::Option<CMsgDOTAProfileCard_EStatID>,
    stat_score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Stat {}

impl CMsgDOTAProfileCard_Slot_Stat {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Stat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Stat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Stat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Stat,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Stat::new)
        }
    }

    // optional .CMsgDOTAProfileCard.EStatID stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: CMsgDOTAProfileCard_EStatID) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id(&self) -> CMsgDOTAProfileCard_EStatID {
        self.stat_id.unwrap_or(CMsgDOTAProfileCard_EStatID::k_eStat_SoloRank)
    }

    fn get_stat_id_for_reflect(&self) -> &::std::option::Option<CMsgDOTAProfileCard_EStatID> {
        &self.stat_id
    }

    fn mut_stat_id_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAProfileCard_EStatID> {
        &mut self.stat_id
    }

    // optional uint32 stat_score = 2;

    pub fn clear_stat_score(&mut self) {
        self.stat_score = ::std::option::Option::None;
    }

    pub fn has_stat_score(&self) -> bool {
        self.stat_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_score(&mut self, v: u32) {
        self.stat_score = ::std::option::Option::Some(v);
    }

    pub fn get_stat_score(&self) -> u32 {
        self.stat_score.unwrap_or(0)
    }

    fn get_stat_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stat_score
    }

    fn mut_stat_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stat_score
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.stat_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.stat_score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Stat {
    fn new() -> CMsgDOTAProfileCard_Slot_Stat {
        CMsgDOTAProfileCard_Slot_Stat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Stat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAProfileCard_EStatID>>(
                    "stat_id",
                    CMsgDOTAProfileCard_Slot_Stat::get_stat_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Stat::mut_stat_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stat_score",
                    CMsgDOTAProfileCard_Slot_Stat::get_stat_score_for_reflect,
                    CMsgDOTAProfileCard_Slot_Stat::mut_stat_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Stat>(
                    "CMsgDOTAProfileCard_Slot_Stat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Stat {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_stat_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Item {
    // message fields
    serialized_item: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Item {}

impl CMsgDOTAProfileCard_Slot_Item {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Item {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Item {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Item,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Item::new)
        }
    }

    // optional bytes serialized_item = 1;

    pub fn clear_serialized_item(&mut self) {
        self.serialized_item.clear();
    }

    pub fn has_serialized_item(&self) -> bool {
        self.serialized_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_item(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_item = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_item(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_item.is_none() {
            self.serialized_item.set_default();
        }
        self.serialized_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_item(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_item.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_serialized_item(&self) -> &[u8] {
        match self.serialized_item.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_serialized_item_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.serialized_item
    }

    fn mut_serialized_item_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.serialized_item
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_item)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serialized_item.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serialized_item.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Item {
    fn new() -> CMsgDOTAProfileCard_Slot_Item {
        CMsgDOTAProfileCard_Slot_Item::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Item>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "serialized_item",
                    CMsgDOTAProfileCard_Slot_Item::get_serialized_item_for_reflect,
                    CMsgDOTAProfileCard_Slot_Item::mut_serialized_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgDOTAProfileCard_Slot_Item::get_item_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Item::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Item>(
                    "CMsgDOTAProfileCard_Slot_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Item {
    fn clear(&mut self) {
        self.clear_serialized_item();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Hero {
    // message fields
    hero_id: ::std::option::Option<u32>,
    hero_wins: ::std::option::Option<u32>,
    hero_losses: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Hero {}

impl CMsgDOTAProfileCard_Slot_Hero {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Hero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Hero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Hero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Hero,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Hero::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 hero_wins = 2;

    pub fn clear_hero_wins(&mut self) {
        self.hero_wins = ::std::option::Option::None;
    }

    pub fn has_hero_wins(&self) -> bool {
        self.hero_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_wins(&mut self, v: u32) {
        self.hero_wins = ::std::option::Option::Some(v);
    }

    pub fn get_hero_wins(&self) -> u32 {
        self.hero_wins.unwrap_or(0)
    }

    fn get_hero_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_wins
    }

    fn mut_hero_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_wins
    }

    // optional uint32 hero_losses = 3;

    pub fn clear_hero_losses(&mut self) {
        self.hero_losses = ::std::option::Option::None;
    }

    pub fn has_hero_losses(&self) -> bool {
        self.hero_losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_losses(&mut self, v: u32) {
        self.hero_losses = ::std::option::Option::Some(v);
    }

    pub fn get_hero_losses(&self) -> u32 {
        self.hero_losses.unwrap_or(0)
    }

    fn get_hero_losses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_losses
    }

    fn mut_hero_losses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_losses
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Hero {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_wins = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_losses = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_wins {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_losses {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_wins {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_losses {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Hero {
    fn new() -> CMsgDOTAProfileCard_Slot_Hero {
        CMsgDOTAProfileCard_Slot_Hero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Hero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAProfileCard_Slot_Hero::get_hero_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Hero::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_wins",
                    CMsgDOTAProfileCard_Slot_Hero::get_hero_wins_for_reflect,
                    CMsgDOTAProfileCard_Slot_Hero::mut_hero_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_losses",
                    CMsgDOTAProfileCard_Slot_Hero::get_hero_losses_for_reflect,
                    CMsgDOTAProfileCard_Slot_Hero::mut_hero_losses_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Hero>(
                    "CMsgDOTAProfileCard_Slot_Hero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Hero {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_hero_wins();
        self.clear_hero_losses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Hero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Hero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Emoticon {
    // message fields
    emoticon_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Emoticon {}

impl CMsgDOTAProfileCard_Slot_Emoticon {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Emoticon {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Emoticon {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Emoticon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Emoticon,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Emoticon::new)
        }
    }

    // optional uint32 emoticon_id = 1;

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }

    pub fn get_emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    fn get_emoticon_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.emoticon_id
    }

    fn mut_emoticon_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.emoticon_id
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Emoticon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.emoticon_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.emoticon_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.emoticon_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Emoticon {
    fn new() -> CMsgDOTAProfileCard_Slot_Emoticon {
        CMsgDOTAProfileCard_Slot_Emoticon::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Emoticon>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "emoticon_id",
                    CMsgDOTAProfileCard_Slot_Emoticon::get_emoticon_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Emoticon::mut_emoticon_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Emoticon>(
                    "CMsgDOTAProfileCard_Slot_Emoticon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Emoticon {
    fn clear(&mut self) {
        self.clear_emoticon_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Emoticon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Emoticon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileCard_Slot_Team {
    // message fields
    team_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileCard_Slot_Team {}

impl CMsgDOTAProfileCard_Slot_Team {
    pub fn new() -> CMsgDOTAProfileCard_Slot_Team {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileCard_Slot_Team {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileCard_Slot_Team> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileCard_Slot_Team,
        };
        unsafe {
            instance.get(CMsgDOTAProfileCard_Slot_Team::new)
        }
    }

    // optional uint32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }
}

impl ::protobuf::Message for CMsgDOTAProfileCard_Slot_Team {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileCard_Slot_Team {
    fn new() -> CMsgDOTAProfileCard_Slot_Team {
        CMsgDOTAProfileCard_Slot_Team::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_Slot_Team>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAProfileCard_Slot_Team::get_team_id_for_reflect,
                    CMsgDOTAProfileCard_Slot_Team::mut_team_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileCard_Slot_Team>(
                    "CMsgDOTAProfileCard_Slot_Team",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileCard_Slot_Team {
    fn clear(&mut self) {
        self.clear_team_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileCard_Slot_Team {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_Slot_Team {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAProfileCard_EStatID {
    k_eStat_SoloRank = 1,
    k_eStat_PartyRank = 2,
    k_eStat_Wins = 3,
    k_eStat_Commends = 4,
    k_eStat_GamesPlayed = 5,
    k_eStat_FirstMatchDate = 6,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAProfileCard_EStatID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAProfileCard_EStatID> {
        match value {
            1 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_SoloRank),
            2 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_PartyRank),
            3 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_Wins),
            4 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_Commends),
            5 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_GamesPlayed),
            6 => ::std::option::Option::Some(CMsgDOTAProfileCard_EStatID::k_eStat_FirstMatchDate),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAProfileCard_EStatID] = &[
            CMsgDOTAProfileCard_EStatID::k_eStat_SoloRank,
            CMsgDOTAProfileCard_EStatID::k_eStat_PartyRank,
            CMsgDOTAProfileCard_EStatID::k_eStat_Wins,
            CMsgDOTAProfileCard_EStatID::k_eStat_Commends,
            CMsgDOTAProfileCard_EStatID::k_eStat_GamesPlayed,
            CMsgDOTAProfileCard_EStatID::k_eStat_FirstMatchDate,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAProfileCard_EStatID>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAProfileCard_EStatID", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAProfileCard_EStatID {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileCard_EStatID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSODOTAPlayerChallenge {
    // message fields
    account_id: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    slot_id: ::std::option::Option<u32>,
    challenge_type: ::std::option::Option<u32>,
    int_param_0: ::std::option::Option<u32>,
    int_param_1: ::std::option::Option<u32>,
    created_time: ::std::option::Option<u32>,
    completed: ::std::option::Option<u32>,
    sequence_id: ::std::option::Option<u32>,
    challenge_tier: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    attempts: ::std::option::Option<u32>,
    complete_limit: ::std::option::Option<u32>,
    quest_rank: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSODOTAPlayerChallenge {}

impl CSODOTAPlayerChallenge {
    pub fn new() -> CSODOTAPlayerChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSODOTAPlayerChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CSODOTAPlayerChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSODOTAPlayerChallenge,
        };
        unsafe {
            instance.get(CSODOTAPlayerChallenge::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 slot_id = 3;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional uint32 challenge_type = 4;

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: u32) {
        self.challenge_type = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_type(&self) -> u32 {
        self.challenge_type.unwrap_or(0)
    }

    fn get_challenge_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_type
    }

    fn mut_challenge_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_type
    }

    // optional uint32 int_param_0 = 5;

    pub fn clear_int_param_0(&mut self) {
        self.int_param_0 = ::std::option::Option::None;
    }

    pub fn has_int_param_0(&self) -> bool {
        self.int_param_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_0(&mut self, v: u32) {
        self.int_param_0 = ::std::option::Option::Some(v);
    }

    pub fn get_int_param_0(&self) -> u32 {
        self.int_param_0.unwrap_or(0)
    }

    fn get_int_param_0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.int_param_0
    }

    fn mut_int_param_0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.int_param_0
    }

    // optional uint32 int_param_1 = 6;

    pub fn clear_int_param_1(&mut self) {
        self.int_param_1 = ::std::option::Option::None;
    }

    pub fn has_int_param_1(&self) -> bool {
        self.int_param_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_1(&mut self, v: u32) {
        self.int_param_1 = ::std::option::Option::Some(v);
    }

    pub fn get_int_param_1(&self) -> u32 {
        self.int_param_1.unwrap_or(0)
    }

    fn get_int_param_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.int_param_1
    }

    fn mut_int_param_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.int_param_1
    }

    // optional uint32 created_time = 7;

    pub fn clear_created_time(&mut self) {
        self.created_time = ::std::option::Option::None;
    }

    pub fn has_created_time(&self) -> bool {
        self.created_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_time(&mut self, v: u32) {
        self.created_time = ::std::option::Option::Some(v);
    }

    pub fn get_created_time(&self) -> u32 {
        self.created_time.unwrap_or(0)
    }

    fn get_created_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.created_time
    }

    fn mut_created_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.created_time
    }

    // optional uint32 completed = 8;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.completed
    }

    // optional uint32 sequence_id = 9;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    fn get_sequence_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sequence_id
    }

    fn mut_sequence_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sequence_id
    }

    // optional uint32 challenge_tier = 10;

    pub fn clear_challenge_tier(&mut self) {
        self.challenge_tier = ::std::option::Option::None;
    }

    pub fn has_challenge_tier(&self) -> bool {
        self.challenge_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_tier(&mut self, v: u32) {
        self.challenge_tier = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_tier(&self) -> u32 {
        self.challenge_tier.unwrap_or(0)
    }

    fn get_challenge_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_tier
    }

    fn mut_challenge_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_tier
    }

    // optional uint32 flags = 11;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // optional uint32 attempts = 12;

    pub fn clear_attempts(&mut self) {
        self.attempts = ::std::option::Option::None;
    }

    pub fn has_attempts(&self) -> bool {
        self.attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: u32) {
        self.attempts = ::std::option::Option::Some(v);
    }

    pub fn get_attempts(&self) -> u32 {
        self.attempts.unwrap_or(0)
    }

    fn get_attempts_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attempts
    }

    fn mut_attempts_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attempts
    }

    // optional uint32 complete_limit = 13;

    pub fn clear_complete_limit(&mut self) {
        self.complete_limit = ::std::option::Option::None;
    }

    pub fn has_complete_limit(&self) -> bool {
        self.complete_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete_limit(&mut self, v: u32) {
        self.complete_limit = ::std::option::Option::Some(v);
    }

    pub fn get_complete_limit(&self) -> u32 {
        self.complete_limit.unwrap_or(0)
    }

    fn get_complete_limit_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.complete_limit
    }

    fn mut_complete_limit_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.complete_limit
    }

    // optional uint32 quest_rank = 14;

    pub fn clear_quest_rank(&mut self) {
        self.quest_rank = ::std::option::Option::None;
    }

    pub fn has_quest_rank(&self) -> bool {
        self.quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_rank(&mut self, v: u32) {
        self.quest_rank = ::std::option::Option::Some(v);
    }

    pub fn get_quest_rank(&self) -> u32 {
        self.quest_rank.unwrap_or(0)
    }

    fn get_quest_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_rank
    }

    fn mut_quest_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_rank
    }
}

impl ::protobuf::Message for CSODOTAPlayerChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.int_param_0 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.int_param_1 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.created_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_tier = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempts = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.complete_limit = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_rank = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.int_param_0 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.int_param_1 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.created_time {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_tier {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attempts {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.complete_limit {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_rank {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.int_param_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.int_param_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.created_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.completed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.challenge_tier {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.attempts {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.complete_limit {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.quest_rank {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSODOTAPlayerChallenge {
    fn new() -> CSODOTAPlayerChallenge {
        CSODOTAPlayerChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSODOTAPlayerChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CSODOTAPlayerChallenge::get_account_id_for_reflect,
                    CSODOTAPlayerChallenge::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CSODOTAPlayerChallenge::get_event_id_for_reflect,
                    CSODOTAPlayerChallenge::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CSODOTAPlayerChallenge::get_slot_id_for_reflect,
                    CSODOTAPlayerChallenge::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_type",
                    CSODOTAPlayerChallenge::get_challenge_type_for_reflect,
                    CSODOTAPlayerChallenge::mut_challenge_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "int_param_0",
                    CSODOTAPlayerChallenge::get_int_param_0_for_reflect,
                    CSODOTAPlayerChallenge::mut_int_param_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "int_param_1",
                    CSODOTAPlayerChallenge::get_int_param_1_for_reflect,
                    CSODOTAPlayerChallenge::mut_int_param_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "created_time",
                    CSODOTAPlayerChallenge::get_created_time_for_reflect,
                    CSODOTAPlayerChallenge::mut_created_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "completed",
                    CSODOTAPlayerChallenge::get_completed_for_reflect,
                    CSODOTAPlayerChallenge::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence_id",
                    CSODOTAPlayerChallenge::get_sequence_id_for_reflect,
                    CSODOTAPlayerChallenge::mut_sequence_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_tier",
                    CSODOTAPlayerChallenge::get_challenge_tier_for_reflect,
                    CSODOTAPlayerChallenge::mut_challenge_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    CSODOTAPlayerChallenge::get_flags_for_reflect,
                    CSODOTAPlayerChallenge::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attempts",
                    CSODOTAPlayerChallenge::get_attempts_for_reflect,
                    CSODOTAPlayerChallenge::mut_attempts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "complete_limit",
                    CSODOTAPlayerChallenge::get_complete_limit_for_reflect,
                    CSODOTAPlayerChallenge::mut_complete_limit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_rank",
                    CSODOTAPlayerChallenge::get_quest_rank_for_reflect,
                    CSODOTAPlayerChallenge::mut_quest_rank_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSODOTAPlayerChallenge>(
                    "CSODOTAPlayerChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSODOTAPlayerChallenge {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_event_id();
        self.clear_slot_id();
        self.clear_challenge_type();
        self.clear_int_param_0();
        self.clear_int_param_1();
        self.clear_created_time();
        self.clear_completed();
        self.clear_sequence_id();
        self.clear_challenge_tier();
        self.clear_flags();
        self.clear_attempts();
        self.clear_complete_limit();
        self.clear_quest_rank();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSODOTAPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAPlayerChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CSODOTAPlayerChallenge_EFlags {
    eFlag_InstantRerollUncompleted = 1,
    eFlag_QuestChallenge = 2,
}

impl ::protobuf::ProtobufEnum for CSODOTAPlayerChallenge_EFlags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSODOTAPlayerChallenge_EFlags> {
        match value {
            1 => ::std::option::Option::Some(CSODOTAPlayerChallenge_EFlags::eFlag_InstantRerollUncompleted),
            2 => ::std::option::Option::Some(CSODOTAPlayerChallenge_EFlags::eFlag_QuestChallenge),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CSODOTAPlayerChallenge_EFlags] = &[
            CSODOTAPlayerChallenge_EFlags::eFlag_InstantRerollUncompleted,
            CSODOTAPlayerChallenge_EFlags::eFlag_QuestChallenge,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CSODOTAPlayerChallenge_EFlags>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CSODOTAPlayerChallenge_EFlags", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CSODOTAPlayerChallenge_EFlags {
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAPlayerChallenge_EFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRerollPlayerChallenge {
    // message fields
    event_id: ::std::option::Option<u32>,
    sequence_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRerollPlayerChallenge {}

impl CMsgClientToGCRerollPlayerChallenge {
    pub fn new() -> CMsgClientToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRerollPlayerChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRerollPlayerChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRerollPlayerChallenge,
        };
        unsafe {
            instance.get(CMsgClientToGCRerollPlayerChallenge::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 sequence_id = 3;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    fn get_sequence_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sequence_id
    }

    fn mut_sequence_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sequence_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRerollPlayerChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRerollPlayerChallenge {
    fn new() -> CMsgClientToGCRerollPlayerChallenge {
        CMsgClientToGCRerollPlayerChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRerollPlayerChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCRerollPlayerChallenge::get_event_id_for_reflect,
                    CMsgClientToGCRerollPlayerChallenge::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence_id",
                    CMsgClientToGCRerollPlayerChallenge::get_sequence_id_for_reflect,
                    CMsgClientToGCRerollPlayerChallenge::mut_sequence_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRerollPlayerChallenge>(
                    "CMsgClientToGCRerollPlayerChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRerollPlayerChallenge {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_sequence_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRerollPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRerollPlayerChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRerollPlayerChallengeResponse {
    // message fields
    result: ::std::option::Option<CMsgGCRerollPlayerChallengeResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCRerollPlayerChallengeResponse {}

impl CMsgGCRerollPlayerChallengeResponse {
    pub fn new() -> CMsgGCRerollPlayerChallengeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCRerollPlayerChallengeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCRerollPlayerChallengeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCRerollPlayerChallengeResponse,
        };
        unsafe {
            instance.get(CMsgGCRerollPlayerChallengeResponse::new)
        }
    }

    // optional .CMsgGCRerollPlayerChallengeResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGCRerollPlayerChallengeResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGCRerollPlayerChallengeResponse_EResult {
        self.result.unwrap_or(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_Success)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGCRerollPlayerChallengeResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCRerollPlayerChallengeResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCRerollPlayerChallengeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCRerollPlayerChallengeResponse {
    fn new() -> CMsgGCRerollPlayerChallengeResponse {
        CMsgGCRerollPlayerChallengeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCRerollPlayerChallengeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCRerollPlayerChallengeResponse_EResult>>(
                    "result",
                    CMsgGCRerollPlayerChallengeResponse::get_result_for_reflect,
                    CMsgGCRerollPlayerChallengeResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCRerollPlayerChallengeResponse>(
                    "CMsgGCRerollPlayerChallengeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCRerollPlayerChallengeResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRerollPlayerChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRerollPlayerChallengeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCRerollPlayerChallengeResponse_EResult {
    eResult_Success = 0,
    eResult_Dropped = 1,
    eResult_NotFound = 2,
    eResult_CantReroll = 3,
    eResult_ServerError = 4,
}

impl ::protobuf::ProtobufEnum for CMsgGCRerollPlayerChallengeResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCRerollPlayerChallengeResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_Success),
            1 => ::std::option::Option::Some(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_Dropped),
            2 => ::std::option::Option::Some(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_NotFound),
            3 => ::std::option::Option::Some(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_CantReroll),
            4 => ::std::option::Option::Some(CMsgGCRerollPlayerChallengeResponse_EResult::eResult_ServerError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCRerollPlayerChallengeResponse_EResult] = &[
            CMsgGCRerollPlayerChallengeResponse_EResult::eResult_Success,
            CMsgGCRerollPlayerChallengeResponse_EResult::eResult_Dropped,
            CMsgGCRerollPlayerChallengeResponse_EResult::eResult_NotFound,
            CMsgGCRerollPlayerChallengeResponse_EResult::eResult_CantReroll,
            CMsgGCRerollPlayerChallengeResponse_EResult::eResult_ServerError,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCRerollPlayerChallengeResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCRerollPlayerChallengeResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCRerollPlayerChallengeResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRerollPlayerChallengeResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCTopCustomGamesList {
    // message fields
    top_custom_games: ::std::vec::Vec<u64>,
    game_of_the_day: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCTopCustomGamesList {}

impl CMsgGCTopCustomGamesList {
    pub fn new() -> CMsgGCTopCustomGamesList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCTopCustomGamesList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCTopCustomGamesList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCTopCustomGamesList,
        };
        unsafe {
            instance.get(CMsgGCTopCustomGamesList::new)
        }
    }

    // repeated uint64 top_custom_games = 1;

    pub fn clear_top_custom_games(&mut self) {
        self.top_custom_games.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_custom_games(&mut self, v: ::std::vec::Vec<u64>) {
        self.top_custom_games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_custom_games(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.top_custom_games
    }

    // Take field
    pub fn take_top_custom_games(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.top_custom_games, ::std::vec::Vec::new())
    }

    pub fn get_top_custom_games(&self) -> &[u64] {
        &self.top_custom_games
    }

    fn get_top_custom_games_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.top_custom_games
    }

    fn mut_top_custom_games_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.top_custom_games
    }

    // optional uint64 game_of_the_day = 2;

    pub fn clear_game_of_the_day(&mut self) {
        self.game_of_the_day = ::std::option::Option::None;
    }

    pub fn has_game_of_the_day(&self) -> bool {
        self.game_of_the_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_of_the_day(&mut self, v: u64) {
        self.game_of_the_day = ::std::option::Option::Some(v);
    }

    pub fn get_game_of_the_day(&self) -> u64 {
        self.game_of_the_day.unwrap_or(0)
    }

    fn get_game_of_the_day_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.game_of_the_day
    }

    fn mut_game_of_the_day_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.game_of_the_day
    }
}

impl ::protobuf::Message for CMsgGCTopCustomGamesList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.top_custom_games)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.game_of_the_day = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.top_custom_games {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_of_the_day {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.top_custom_games {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.game_of_the_day {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCTopCustomGamesList {
    fn new() -> CMsgGCTopCustomGamesList {
        CMsgGCTopCustomGamesList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCTopCustomGamesList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "top_custom_games",
                    CMsgGCTopCustomGamesList::get_top_custom_games_for_reflect,
                    CMsgGCTopCustomGamesList::mut_top_custom_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "game_of_the_day",
                    CMsgGCTopCustomGamesList::get_game_of_the_day_for_reflect,
                    CMsgGCTopCustomGamesList::mut_game_of_the_day_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCTopCustomGamesList>(
                    "CMsgGCTopCustomGamesList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCTopCustomGamesList {
    fn clear(&mut self) {
        self.clear_top_custom_games();
        self.clear_game_of_the_day();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCTopCustomGamesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCTopCustomGamesList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats {
    // message fields
    field_match: ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_MatchDetails>,
    teams: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails>,
    buildings: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails>,
    graph_data: ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_GraphData>,
    delta_frame: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats {}

impl CMsgDOTARealtimeGameStats {
    pub fn new() -> CMsgDOTARealtimeGameStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats::new)
        }
    }

    // optional .CMsgDOTARealtimeGameStats.MatchDetails match = 1;

    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: CMsgDOTARealtimeGameStats_MatchDetails) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut CMsgDOTARealtimeGameStats_MatchDetails {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> CMsgDOTARealtimeGameStats_MatchDetails {
        self.field_match.take().unwrap_or_else(|| CMsgDOTARealtimeGameStats_MatchDetails::new())
    }

    pub fn get_field_match(&self) -> &CMsgDOTARealtimeGameStats_MatchDetails {
        self.field_match.as_ref().unwrap_or_else(|| CMsgDOTARealtimeGameStats_MatchDetails::default_instance())
    }

    fn get_field_match_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_MatchDetails> {
        &self.field_match
    }

    fn mut_field_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_MatchDetails> {
        &mut self.field_match
    }

    // repeated .CMsgDOTARealtimeGameStats.TeamDetails teams = 2;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgDOTARealtimeGameStats_TeamDetails] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_TeamDetails> {
        &mut self.teams
    }

    // repeated .CMsgDOTARealtimeGameStats.BuildingDetails buildings = 3;

    pub fn clear_buildings(&mut self) {
        self.buildings.clear();
    }

    // Param is passed by value, moved
    pub fn set_buildings(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails>) {
        self.buildings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buildings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails> {
        &mut self.buildings
    }

    // Take field
    pub fn take_buildings(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails> {
        ::std::mem::replace(&mut self.buildings, ::protobuf::RepeatedField::new())
    }

    pub fn get_buildings(&self) -> &[CMsgDOTARealtimeGameStats_BuildingDetails] {
        &self.buildings
    }

    fn get_buildings_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails> {
        &self.buildings
    }

    fn mut_buildings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BuildingDetails> {
        &mut self.buildings
    }

    // optional .CMsgDOTARealtimeGameStats.GraphData graph_data = 4;

    pub fn clear_graph_data(&mut self) {
        self.graph_data.clear();
    }

    pub fn has_graph_data(&self) -> bool {
        self.graph_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph_data(&mut self, v: CMsgDOTARealtimeGameStats_GraphData) {
        self.graph_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_data(&mut self) -> &mut CMsgDOTARealtimeGameStats_GraphData {
        if self.graph_data.is_none() {
            self.graph_data.set_default();
        }
        self.graph_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph_data(&mut self) -> CMsgDOTARealtimeGameStats_GraphData {
        self.graph_data.take().unwrap_or_else(|| CMsgDOTARealtimeGameStats_GraphData::new())
    }

    pub fn get_graph_data(&self) -> &CMsgDOTARealtimeGameStats_GraphData {
        self.graph_data.as_ref().unwrap_or_else(|| CMsgDOTARealtimeGameStats_GraphData::default_instance())
    }

    fn get_graph_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_GraphData> {
        &self.graph_data
    }

    fn mut_graph_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStats_GraphData> {
        &mut self.graph_data
    }

    // optional bool delta_frame = 5;

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }

    pub fn get_delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    fn get_delta_frame_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.delta_frame
    }

    fn mut_delta_frame_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.delta_frame
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buildings)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delta_frame = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.teams {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buildings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.graph_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats {
    fn new() -> CMsgDOTARealtimeGameStats {
        CMsgDOTARealtimeGameStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_MatchDetails>>(
                    "match",
                    CMsgDOTARealtimeGameStats::get_field_match_for_reflect,
                    CMsgDOTARealtimeGameStats::mut_field_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_TeamDetails>>(
                    "teams",
                    CMsgDOTARealtimeGameStats::get_teams_for_reflect,
                    CMsgDOTARealtimeGameStats::mut_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_BuildingDetails>>(
                    "buildings",
                    CMsgDOTARealtimeGameStats::get_buildings_for_reflect,
                    CMsgDOTARealtimeGameStats::mut_buildings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_GraphData>>(
                    "graph_data",
                    CMsgDOTARealtimeGameStats::get_graph_data_for_reflect,
                    CMsgDOTARealtimeGameStats::mut_graph_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delta_frame",
                    CMsgDOTARealtimeGameStats::get_delta_frame_for_reflect,
                    CMsgDOTARealtimeGameStats::mut_delta_frame_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats>(
                    "CMsgDOTARealtimeGameStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats {
    fn clear(&mut self) {
        self.clear_field_match();
        self.clear_teams();
        self.clear_buildings();
        self.clear_graph_data();
        self.clear_delta_frame();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_TeamDetails {
    // message fields
    team_number: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_logo: ::std::option::Option<u64>,
    score: ::std::option::Option<u32>,
    players: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails>,
    only_team: ::std::option::Option<bool>,
    cheers: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_TeamDetails {}

impl CMsgDOTARealtimeGameStats_TeamDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_TeamDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_TeamDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_TeamDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_TeamDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_TeamDetails::new)
        }
    }

    // optional uint32 team_number = 1;

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: u32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    pub fn get_team_number(&self) -> u32 {
        self.team_number.unwrap_or(0)
    }

    fn get_team_number_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_number
    }

    fn mut_team_number_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_number
    }

    // optional uint32 team_id = 2;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 3;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional fixed64 team_logo = 4;

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    fn get_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_logo
    }

    fn mut_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_logo
    }

    // optional uint32 score = 5;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // repeated .CMsgDOTARealtimeGameStats.PlayerDetails players = 6;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgDOTARealtimeGameStats_PlayerDetails] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PlayerDetails> {
        &mut self.players
    }

    // optional bool only_team = 7;

    pub fn clear_only_team(&mut self) {
        self.only_team = ::std::option::Option::None;
    }

    pub fn has_only_team(&self) -> bool {
        self.only_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_team(&mut self, v: bool) {
        self.only_team = ::std::option::Option::Some(v);
    }

    pub fn get_only_team(&self) -> bool {
        self.only_team.unwrap_or(false)
    }

    fn get_only_team_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.only_team
    }

    fn mut_only_team_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.only_team
    }

    // optional uint32 cheers = 8;

    pub fn clear_cheers(&mut self) {
        self.cheers = ::std::option::Option::None;
    }

    pub fn has_cheers(&self) -> bool {
        self.cheers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheers(&mut self, v: u32) {
        self.cheers = ::std::option::Option::Some(v);
    }

    pub fn get_cheers(&self) -> u32 {
        self.cheers.unwrap_or(0)
    }

    fn get_cheers_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cheers
    }

    fn mut_cheers_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cheers
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_TeamDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.team_logo = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_team = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cheers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_logo {
            my_size += 9;
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.only_team {
            my_size += 2;
        }
        if let Some(v) = self.cheers {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(5, v)?;
        }
        for v in &self.players {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.only_team {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.cheers {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_TeamDetails {
    fn new() -> CMsgDOTARealtimeGameStats_TeamDetails {
        CMsgDOTARealtimeGameStats_TeamDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_TeamDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_number",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_team_number_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_team_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_team_id_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_team_name_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "team_logo",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_team_logo_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_score_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_PlayerDetails>>(
                    "players",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_players_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "only_team",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_only_team_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_only_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cheers",
                    CMsgDOTARealtimeGameStats_TeamDetails::get_cheers_for_reflect,
                    CMsgDOTARealtimeGameStats_TeamDetails::mut_cheers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_TeamDetails>(
                    "CMsgDOTARealtimeGameStats_TeamDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_TeamDetails {
    fn clear(&mut self) {
        self.clear_team_number();
        self.clear_team_id();
        self.clear_team_name();
        self.clear_team_logo();
        self.clear_score();
        self.clear_players();
        self.clear_only_team();
        self.clear_cheers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_TeamDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_TeamDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_ItemDetails {
    // message fields
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    time: ::std::option::Option<i32>,
    sold: ::std::option::Option<bool>,
    stackcount: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_ItemDetails {}

impl CMsgDOTARealtimeGameStats_ItemDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_ItemDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_ItemDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_ItemDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_ItemDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_ItemDetails::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional int32 time = 3;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.time
    }

    // optional bool sold = 4;

    pub fn clear_sold(&mut self) {
        self.sold = ::std::option::Option::None;
    }

    pub fn has_sold(&self) -> bool {
        self.sold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sold(&mut self, v: bool) {
        self.sold = ::std::option::Option::Some(v);
    }

    pub fn get_sold(&self) -> bool {
        self.sold.unwrap_or(false)
    }

    fn get_sold_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.sold
    }

    fn mut_sold_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.sold
    }

    // optional uint32 stackcount = 5;

    pub fn clear_stackcount(&mut self) {
        self.stackcount = ::std::option::Option::None;
    }

    pub fn has_stackcount(&self) -> bool {
        self.stackcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stackcount(&mut self, v: u32) {
        self.stackcount = ::std::option::Option::Some(v);
    }

    pub fn get_stackcount(&self) -> u32 {
        self.stackcount.unwrap_or(0)
    }

    fn get_stackcount_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stackcount
    }

    fn mut_stackcount_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stackcount
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_ItemDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sold = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stackcount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sold {
            my_size += 2;
        }
        if let Some(v) = self.stackcount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.sold {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.stackcount {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_ItemDetails {
    fn new() -> CMsgDOTARealtimeGameStats_ItemDetails {
        CMsgDOTARealtimeGameStats_ItemDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_ItemDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgDOTARealtimeGameStats_ItemDetails::get_id_for_reflect,
                    CMsgDOTARealtimeGameStats_ItemDetails::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTARealtimeGameStats_ItemDetails::get_name_for_reflect,
                    CMsgDOTARealtimeGameStats_ItemDetails::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "time",
                    CMsgDOTARealtimeGameStats_ItemDetails::get_time_for_reflect,
                    CMsgDOTARealtimeGameStats_ItemDetails::mut_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sold",
                    CMsgDOTARealtimeGameStats_ItemDetails::get_sold_for_reflect,
                    CMsgDOTARealtimeGameStats_ItemDetails::mut_sold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stackcount",
                    CMsgDOTARealtimeGameStats_ItemDetails::get_stackcount_for_reflect,
                    CMsgDOTARealtimeGameStats_ItemDetails::mut_stackcount_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_ItemDetails>(
                    "CMsgDOTARealtimeGameStats_ItemDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_ItemDetails {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.clear_time();
        self.clear_sold();
        self.clear_stackcount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_ItemDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_ItemDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_AbilityDetails {
    // message fields
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    level: ::std::option::Option<u32>,
    cooldown: ::std::option::Option<f32>,
    cooldown_max: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_AbilityDetails {}

impl CMsgDOTARealtimeGameStats_AbilityDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_AbilityDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_AbilityDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_AbilityDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_AbilityDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_AbilityDetails::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 level = 3;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional float cooldown = 4;

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    pub fn get_cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    fn get_cooldown_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cooldown
    }

    fn mut_cooldown_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cooldown
    }

    // optional float cooldown_max = 5;

    pub fn clear_cooldown_max(&mut self) {
        self.cooldown_max = ::std::option::Option::None;
    }

    pub fn has_cooldown_max(&self) -> bool {
        self.cooldown_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_max(&mut self, v: f32) {
        self.cooldown_max = ::std::option::Option::Some(v);
    }

    pub fn get_cooldown_max(&self) -> f32 {
        self.cooldown_max.unwrap_or(0.)
    }

    fn get_cooldown_max_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cooldown_max
    }

    fn mut_cooldown_max_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cooldown_max
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_AbilityDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cooldown = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cooldown_max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cooldown {
            my_size += 5;
        }
        if let Some(v) = self.cooldown_max {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.cooldown_max {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_AbilityDetails {
    fn new() -> CMsgDOTARealtimeGameStats_AbilityDetails {
        CMsgDOTARealtimeGameStats_AbilityDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_AbilityDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgDOTARealtimeGameStats_AbilityDetails::get_id_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityDetails::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTARealtimeGameStats_AbilityDetails::get_name_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityDetails::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgDOTARealtimeGameStats_AbilityDetails::get_level_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityDetails::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cooldown",
                    CMsgDOTARealtimeGameStats_AbilityDetails::get_cooldown_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityDetails::mut_cooldown_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cooldown_max",
                    CMsgDOTARealtimeGameStats_AbilityDetails::get_cooldown_max_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityDetails::mut_cooldown_max_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_AbilityDetails>(
                    "CMsgDOTARealtimeGameStats_AbilityDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_AbilityDetails {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.clear_level();
        self.clear_cooldown();
        self.clear_cooldown_max();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_AbilityDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_AbilityDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_HeroToHeroStats {
    // message fields
    victimid: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_HeroToHeroStats {}

impl CMsgDOTARealtimeGameStats_HeroToHeroStats {
    pub fn new() -> CMsgDOTARealtimeGameStats_HeroToHeroStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_HeroToHeroStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_HeroToHeroStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_HeroToHeroStats,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_HeroToHeroStats::new)
        }
    }

    // optional uint32 victimid = 1;

    pub fn clear_victimid(&mut self) {
        self.victimid = ::std::option::Option::None;
    }

    pub fn has_victimid(&self) -> bool {
        self.victimid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victimid(&mut self, v: u32) {
        self.victimid = ::std::option::Option::Some(v);
    }

    pub fn get_victimid(&self) -> u32 {
        self.victimid.unwrap_or(0)
    }

    fn get_victimid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.victimid
    }

    fn mut_victimid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.victimid
    }

    // optional uint32 kills = 2;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 assists = 3;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_HeroToHeroStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.victimid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.victimid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.victimid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_HeroToHeroStats {
    fn new() -> CMsgDOTARealtimeGameStats_HeroToHeroStats {
        CMsgDOTARealtimeGameStats_HeroToHeroStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_HeroToHeroStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "victimid",
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::get_victimid_for_reflect,
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::mut_victimid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::get_kills_for_reflect,
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::get_assists_for_reflect,
                    CMsgDOTARealtimeGameStats_HeroToHeroStats::mut_assists_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_HeroToHeroStats>(
                    "CMsgDOTARealtimeGameStats_HeroToHeroStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_HeroToHeroStats {
    fn clear(&mut self) {
        self.clear_victimid();
        self.clear_kills();
        self.clear_assists();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_HeroToHeroStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_HeroToHeroStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_AbilityList {
    // message fields
    id: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_AbilityList {}

impl CMsgDOTARealtimeGameStats_AbilityList {
    pub fn new() -> CMsgDOTARealtimeGameStats_AbilityList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_AbilityList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_AbilityList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_AbilityList,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_AbilityList::new)
        }
    }

    // repeated uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[u32] {
        &self.id
    }

    fn get_id_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.id
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_AbilityList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_AbilityList {
    fn new() -> CMsgDOTARealtimeGameStats_AbilityList {
        CMsgDOTARealtimeGameStats_AbilityList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_AbilityList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgDOTARealtimeGameStats_AbilityList::get_id_for_reflect,
                    CMsgDOTARealtimeGameStats_AbilityList::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_AbilityList>(
                    "CMsgDOTARealtimeGameStats_AbilityList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_AbilityList {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_AbilityList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_AbilityList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_PlayerDetails {
    // message fields
    accountid: ::std::option::Option<u32>,
    playerid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    team: ::std::option::Option<u32>,
    heroid: ::std::option::Option<u32>,
    healthpoints: ::std::option::Option<u32>,
    maxhealthpoints: ::std::option::Option<u32>,
    healthregenrate: ::std::option::Option<f32>,
    manapoints: ::std::option::Option<u32>,
    maxmanapoints: ::std::option::Option<u32>,
    manaregenrate: ::std::option::Option<f32>,
    base_strength: ::std::option::Option<u32>,
    base_agility: ::std::option::Option<u32>,
    base_intelligence: ::std::option::Option<u32>,
    base_armor: ::std::option::Option<i32>,
    base_movespeed: ::std::option::Option<u32>,
    base_damage: ::std::option::Option<u32>,
    strength: ::std::option::Option<u32>,
    agility: ::std::option::Option<u32>,
    intelligence: ::std::option::Option<u32>,
    armor: ::std::option::Option<i32>,
    movespeed: ::std::option::Option<u32>,
    damage: ::std::option::Option<u32>,
    hero_damage: ::std::option::Option<u32>,
    tower_damage: ::std::option::Option<u32>,
    abilities: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails>,
    level: ::std::option::Option<u32>,
    kill_count: ::std::option::Option<u32>,
    death_count: ::std::option::Option<u32>,
    assists_count: ::std::option::Option<u32>,
    denies_count: ::std::option::Option<u32>,
    lh_count: ::std::option::Option<u32>,
    hero_healing: ::std::option::Option<u32>,
    gold_per_min: ::std::option::Option<u32>,
    xp_per_min: ::std::option::Option<u32>,
    net_gold: ::std::option::Option<u32>,
    gold: ::std::option::Option<u32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    respawn_time: ::std::option::Option<i32>,
    ultimate_cooldown: ::std::option::Option<u32>,
    has_buyback: ::std::option::Option<bool>,
    items: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>,
    stashitems: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>,
    itemshoppinglist: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>,
    levelpoints: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList>,
    hero_to_hero_stats: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats>,
    has_ultimate: ::std::option::Option<bool>,
    has_ultimate_mana: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_PlayerDetails {}

impl CMsgDOTARealtimeGameStats_PlayerDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_PlayerDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_PlayerDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_PlayerDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_PlayerDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_PlayerDetails::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint32 playerid = 2;

    pub fn clear_playerid(&mut self) {
        self.playerid = ::std::option::Option::None;
    }

    pub fn has_playerid(&self) -> bool {
        self.playerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid(&mut self, v: u32) {
        self.playerid = ::std::option::Option::Some(v);
    }

    pub fn get_playerid(&self) -> u32 {
        self.playerid.unwrap_or(0)
    }

    fn get_playerid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.playerid
    }

    fn mut_playerid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.playerid
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 team = 4;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 heroid = 5;

    pub fn clear_heroid(&mut self) {
        self.heroid = ::std::option::Option::None;
    }

    pub fn has_heroid(&self) -> bool {
        self.heroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heroid(&mut self, v: u32) {
        self.heroid = ::std::option::Option::Some(v);
    }

    pub fn get_heroid(&self) -> u32 {
        self.heroid.unwrap_or(0)
    }

    fn get_heroid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.heroid
    }

    fn mut_heroid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.heroid
    }

    // optional uint32 healthpoints = 6;

    pub fn clear_healthpoints(&mut self) {
        self.healthpoints = ::std::option::Option::None;
    }

    pub fn has_healthpoints(&self) -> bool {
        self.healthpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthpoints(&mut self, v: u32) {
        self.healthpoints = ::std::option::Option::Some(v);
    }

    pub fn get_healthpoints(&self) -> u32 {
        self.healthpoints.unwrap_or(0)
    }

    fn get_healthpoints_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.healthpoints
    }

    fn mut_healthpoints_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.healthpoints
    }

    // optional uint32 maxhealthpoints = 7;

    pub fn clear_maxhealthpoints(&mut self) {
        self.maxhealthpoints = ::std::option::Option::None;
    }

    pub fn has_maxhealthpoints(&self) -> bool {
        self.maxhealthpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxhealthpoints(&mut self, v: u32) {
        self.maxhealthpoints = ::std::option::Option::Some(v);
    }

    pub fn get_maxhealthpoints(&self) -> u32 {
        self.maxhealthpoints.unwrap_or(0)
    }

    fn get_maxhealthpoints_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maxhealthpoints
    }

    fn mut_maxhealthpoints_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maxhealthpoints
    }

    // optional float healthregenrate = 8;

    pub fn clear_healthregenrate(&mut self) {
        self.healthregenrate = ::std::option::Option::None;
    }

    pub fn has_healthregenrate(&self) -> bool {
        self.healthregenrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthregenrate(&mut self, v: f32) {
        self.healthregenrate = ::std::option::Option::Some(v);
    }

    pub fn get_healthregenrate(&self) -> f32 {
        self.healthregenrate.unwrap_or(0.)
    }

    fn get_healthregenrate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.healthregenrate
    }

    fn mut_healthregenrate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.healthregenrate
    }

    // optional uint32 manapoints = 9;

    pub fn clear_manapoints(&mut self) {
        self.manapoints = ::std::option::Option::None;
    }

    pub fn has_manapoints(&self) -> bool {
        self.manapoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manapoints(&mut self, v: u32) {
        self.manapoints = ::std::option::Option::Some(v);
    }

    pub fn get_manapoints(&self) -> u32 {
        self.manapoints.unwrap_or(0)
    }

    fn get_manapoints_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.manapoints
    }

    fn mut_manapoints_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.manapoints
    }

    // optional uint32 maxmanapoints = 10;

    pub fn clear_maxmanapoints(&mut self) {
        self.maxmanapoints = ::std::option::Option::None;
    }

    pub fn has_maxmanapoints(&self) -> bool {
        self.maxmanapoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxmanapoints(&mut self, v: u32) {
        self.maxmanapoints = ::std::option::Option::Some(v);
    }

    pub fn get_maxmanapoints(&self) -> u32 {
        self.maxmanapoints.unwrap_or(0)
    }

    fn get_maxmanapoints_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maxmanapoints
    }

    fn mut_maxmanapoints_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maxmanapoints
    }

    // optional float manaregenrate = 11;

    pub fn clear_manaregenrate(&mut self) {
        self.manaregenrate = ::std::option::Option::None;
    }

    pub fn has_manaregenrate(&self) -> bool {
        self.manaregenrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manaregenrate(&mut self, v: f32) {
        self.manaregenrate = ::std::option::Option::Some(v);
    }

    pub fn get_manaregenrate(&self) -> f32 {
        self.manaregenrate.unwrap_or(0.)
    }

    fn get_manaregenrate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.manaregenrate
    }

    fn mut_manaregenrate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.manaregenrate
    }

    // optional uint32 base_strength = 12;

    pub fn clear_base_strength(&mut self) {
        self.base_strength = ::std::option::Option::None;
    }

    pub fn has_base_strength(&self) -> bool {
        self.base_strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_strength(&mut self, v: u32) {
        self.base_strength = ::std::option::Option::Some(v);
    }

    pub fn get_base_strength(&self) -> u32 {
        self.base_strength.unwrap_or(0)
    }

    fn get_base_strength_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_strength
    }

    fn mut_base_strength_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_strength
    }

    // optional uint32 base_agility = 13;

    pub fn clear_base_agility(&mut self) {
        self.base_agility = ::std::option::Option::None;
    }

    pub fn has_base_agility(&self) -> bool {
        self.base_agility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_agility(&mut self, v: u32) {
        self.base_agility = ::std::option::Option::Some(v);
    }

    pub fn get_base_agility(&self) -> u32 {
        self.base_agility.unwrap_or(0)
    }

    fn get_base_agility_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_agility
    }

    fn mut_base_agility_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_agility
    }

    // optional uint32 base_intelligence = 14;

    pub fn clear_base_intelligence(&mut self) {
        self.base_intelligence = ::std::option::Option::None;
    }

    pub fn has_base_intelligence(&self) -> bool {
        self.base_intelligence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_intelligence(&mut self, v: u32) {
        self.base_intelligence = ::std::option::Option::Some(v);
    }

    pub fn get_base_intelligence(&self) -> u32 {
        self.base_intelligence.unwrap_or(0)
    }

    fn get_base_intelligence_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_intelligence
    }

    fn mut_base_intelligence_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_intelligence
    }

    // optional int32 base_armor = 15;

    pub fn clear_base_armor(&mut self) {
        self.base_armor = ::std::option::Option::None;
    }

    pub fn has_base_armor(&self) -> bool {
        self.base_armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_armor(&mut self, v: i32) {
        self.base_armor = ::std::option::Option::Some(v);
    }

    pub fn get_base_armor(&self) -> i32 {
        self.base_armor.unwrap_or(0)
    }

    fn get_base_armor_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.base_armor
    }

    fn mut_base_armor_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.base_armor
    }

    // optional uint32 base_movespeed = 16;

    pub fn clear_base_movespeed(&mut self) {
        self.base_movespeed = ::std::option::Option::None;
    }

    pub fn has_base_movespeed(&self) -> bool {
        self.base_movespeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_movespeed(&mut self, v: u32) {
        self.base_movespeed = ::std::option::Option::Some(v);
    }

    pub fn get_base_movespeed(&self) -> u32 {
        self.base_movespeed.unwrap_or(0)
    }

    fn get_base_movespeed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_movespeed
    }

    fn mut_base_movespeed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_movespeed
    }

    // optional uint32 base_damage = 17;

    pub fn clear_base_damage(&mut self) {
        self.base_damage = ::std::option::Option::None;
    }

    pub fn has_base_damage(&self) -> bool {
        self.base_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_damage(&mut self, v: u32) {
        self.base_damage = ::std::option::Option::Some(v);
    }

    pub fn get_base_damage(&self) -> u32 {
        self.base_damage.unwrap_or(0)
    }

    fn get_base_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_damage
    }

    fn mut_base_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_damage
    }

    // optional uint32 strength = 18;

    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: u32) {
        self.strength = ::std::option::Option::Some(v);
    }

    pub fn get_strength(&self) -> u32 {
        self.strength.unwrap_or(0)
    }

    fn get_strength_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.strength
    }

    fn mut_strength_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.strength
    }

    // optional uint32 agility = 19;

    pub fn clear_agility(&mut self) {
        self.agility = ::std::option::Option::None;
    }

    pub fn has_agility(&self) -> bool {
        self.agility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agility(&mut self, v: u32) {
        self.agility = ::std::option::Option::Some(v);
    }

    pub fn get_agility(&self) -> u32 {
        self.agility.unwrap_or(0)
    }

    fn get_agility_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.agility
    }

    fn mut_agility_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.agility
    }

    // optional uint32 intelligence = 20;

    pub fn clear_intelligence(&mut self) {
        self.intelligence = ::std::option::Option::None;
    }

    pub fn has_intelligence(&self) -> bool {
        self.intelligence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intelligence(&mut self, v: u32) {
        self.intelligence = ::std::option::Option::Some(v);
    }

    pub fn get_intelligence(&self) -> u32 {
        self.intelligence.unwrap_or(0)
    }

    fn get_intelligence_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.intelligence
    }

    fn mut_intelligence_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.intelligence
    }

    // optional int32 armor = 21;

    pub fn clear_armor(&mut self) {
        self.armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: i32) {
        self.armor = ::std::option::Option::Some(v);
    }

    pub fn get_armor(&self) -> i32 {
        self.armor.unwrap_or(0)
    }

    fn get_armor_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.armor
    }

    fn mut_armor_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.armor
    }

    // optional uint32 movespeed = 22;

    pub fn clear_movespeed(&mut self) {
        self.movespeed = ::std::option::Option::None;
    }

    pub fn has_movespeed(&self) -> bool {
        self.movespeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movespeed(&mut self, v: u32) {
        self.movespeed = ::std::option::Option::Some(v);
    }

    pub fn get_movespeed(&self) -> u32 {
        self.movespeed.unwrap_or(0)
    }

    fn get_movespeed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.movespeed
    }

    fn mut_movespeed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.movespeed
    }

    // optional uint32 damage = 23;

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    pub fn get_damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    fn get_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage
    }

    fn mut_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage
    }

    // optional uint32 hero_damage = 24;

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    fn get_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_damage
    }

    fn mut_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_damage
    }

    // optional uint32 tower_damage = 25;

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    fn get_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_damage
    }

    fn mut_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_damage
    }

    // repeated .CMsgDOTARealtimeGameStats.AbilityDetails abilities = 26;

    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_abilities(&self) -> &[CMsgDOTARealtimeGameStats_AbilityDetails] {
        &self.abilities
    }

    fn get_abilities_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails> {
        &self.abilities
    }

    fn mut_abilities_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityDetails> {
        &mut self.abilities
    }

    // optional uint32 level = 27;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional uint32 kill_count = 28;

    pub fn clear_kill_count(&mut self) {
        self.kill_count = ::std::option::Option::None;
    }

    pub fn has_kill_count(&self) -> bool {
        self.kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_count(&mut self, v: u32) {
        self.kill_count = ::std::option::Option::Some(v);
    }

    pub fn get_kill_count(&self) -> u32 {
        self.kill_count.unwrap_or(0)
    }

    fn get_kill_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kill_count
    }

    fn mut_kill_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kill_count
    }

    // optional uint32 death_count = 29;

    pub fn clear_death_count(&mut self) {
        self.death_count = ::std::option::Option::None;
    }

    pub fn has_death_count(&self) -> bool {
        self.death_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_count(&mut self, v: u32) {
        self.death_count = ::std::option::Option::Some(v);
    }

    pub fn get_death_count(&self) -> u32 {
        self.death_count.unwrap_or(0)
    }

    fn get_death_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.death_count
    }

    fn mut_death_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.death_count
    }

    // optional uint32 assists_count = 30;

    pub fn clear_assists_count(&mut self) {
        self.assists_count = ::std::option::Option::None;
    }

    pub fn has_assists_count(&self) -> bool {
        self.assists_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists_count(&mut self, v: u32) {
        self.assists_count = ::std::option::Option::Some(v);
    }

    pub fn get_assists_count(&self) -> u32 {
        self.assists_count.unwrap_or(0)
    }

    fn get_assists_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists_count
    }

    fn mut_assists_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists_count
    }

    // optional uint32 denies_count = 31;

    pub fn clear_denies_count(&mut self) {
        self.denies_count = ::std::option::Option::None;
    }

    pub fn has_denies_count(&self) -> bool {
        self.denies_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies_count(&mut self, v: u32) {
        self.denies_count = ::std::option::Option::Some(v);
    }

    pub fn get_denies_count(&self) -> u32 {
        self.denies_count.unwrap_or(0)
    }

    fn get_denies_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies_count
    }

    fn mut_denies_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies_count
    }

    // optional uint32 lh_count = 32;

    pub fn clear_lh_count(&mut self) {
        self.lh_count = ::std::option::Option::None;
    }

    pub fn has_lh_count(&self) -> bool {
        self.lh_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lh_count(&mut self, v: u32) {
        self.lh_count = ::std::option::Option::Some(v);
    }

    pub fn get_lh_count(&self) -> u32 {
        self.lh_count.unwrap_or(0)
    }

    fn get_lh_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lh_count
    }

    fn mut_lh_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lh_count
    }

    // optional uint32 hero_healing = 33;

    pub fn clear_hero_healing(&mut self) {
        self.hero_healing = ::std::option::Option::None;
    }

    pub fn has_hero_healing(&self) -> bool {
        self.hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_healing(&mut self, v: u32) {
        self.hero_healing = ::std::option::Option::Some(v);
    }

    pub fn get_hero_healing(&self) -> u32 {
        self.hero_healing.unwrap_or(0)
    }

    fn get_hero_healing_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_healing
    }

    fn mut_hero_healing_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_healing
    }

    // optional uint32 gold_per_min = 34;

    pub fn clear_gold_per_min(&mut self) {
        self.gold_per_min = ::std::option::Option::None;
    }

    pub fn has_gold_per_min(&self) -> bool {
        self.gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_per_min(&mut self, v: u32) {
        self.gold_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_gold_per_min(&self) -> u32 {
        self.gold_per_min.unwrap_or(0)
    }

    fn get_gold_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_per_min
    }

    fn mut_gold_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_per_min
    }

    // optional uint32 xp_per_min = 35;

    pub fn clear_xp_per_min(&mut self) {
        self.xp_per_min = ::std::option::Option::None;
    }

    pub fn has_xp_per_min(&self) -> bool {
        self.xp_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_per_min(&mut self, v: u32) {
        self.xp_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_xp_per_min(&self) -> u32 {
        self.xp_per_min.unwrap_or(0)
    }

    fn get_xp_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_per_min
    }

    fn mut_xp_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_per_min
    }

    // optional uint32 net_gold = 36;

    pub fn clear_net_gold(&mut self) {
        self.net_gold = ::std::option::Option::None;
    }

    pub fn has_net_gold(&self) -> bool {
        self.net_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_gold(&mut self, v: u32) {
        self.net_gold = ::std::option::Option::Some(v);
    }

    pub fn get_net_gold(&self) -> u32 {
        self.net_gold.unwrap_or(0)
    }

    fn get_net_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_gold
    }

    fn mut_net_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_gold
    }

    // optional uint32 gold = 37;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional float x = 38;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 39;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }

    // optional int32 respawn_time = 40;

    pub fn clear_respawn_time(&mut self) {
        self.respawn_time = ::std::option::Option::None;
    }

    pub fn has_respawn_time(&self) -> bool {
        self.respawn_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_respawn_time(&mut self, v: i32) {
        self.respawn_time = ::std::option::Option::Some(v);
    }

    pub fn get_respawn_time(&self) -> i32 {
        self.respawn_time.unwrap_or(0)
    }

    fn get_respawn_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.respawn_time
    }

    fn mut_respawn_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.respawn_time
    }

    // optional uint32 ultimate_cooldown = 41;

    pub fn clear_ultimate_cooldown(&mut self) {
        self.ultimate_cooldown = ::std::option::Option::None;
    }

    pub fn has_ultimate_cooldown(&self) -> bool {
        self.ultimate_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ultimate_cooldown(&mut self, v: u32) {
        self.ultimate_cooldown = ::std::option::Option::Some(v);
    }

    pub fn get_ultimate_cooldown(&self) -> u32 {
        self.ultimate_cooldown.unwrap_or(0)
    }

    fn get_ultimate_cooldown_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ultimate_cooldown
    }

    fn mut_ultimate_cooldown_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ultimate_cooldown
    }

    // optional bool has_buyback = 42;

    pub fn clear_has_buyback(&mut self) {
        self.has_buyback = ::std::option::Option::None;
    }

    pub fn has_has_buyback(&self) -> bool {
        self.has_buyback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_buyback(&mut self, v: bool) {
        self.has_buyback = ::std::option::Option::Some(v);
    }

    pub fn get_has_buyback(&self) -> bool {
        self.has_buyback.unwrap_or(false)
    }

    fn get_has_buyback_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_buyback
    }

    fn mut_has_buyback_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_buyback
    }

    // repeated .CMsgDOTARealtimeGameStats.ItemDetails items = 43;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[CMsgDOTARealtimeGameStats_ItemDetails] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.items
    }

    // repeated .CMsgDOTARealtimeGameStats.ItemDetails stashitems = 44;

    pub fn clear_stashitems(&mut self) {
        self.stashitems.clear();
    }

    // Param is passed by value, moved
    pub fn set_stashitems(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>) {
        self.stashitems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stashitems(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.stashitems
    }

    // Take field
    pub fn take_stashitems(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        ::std::mem::replace(&mut self.stashitems, ::protobuf::RepeatedField::new())
    }

    pub fn get_stashitems(&self) -> &[CMsgDOTARealtimeGameStats_ItemDetails] {
        &self.stashitems
    }

    fn get_stashitems_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &self.stashitems
    }

    fn mut_stashitems_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.stashitems
    }

    // repeated .CMsgDOTARealtimeGameStats.ItemDetails itemshoppinglist = 45;

    pub fn clear_itemshoppinglist(&mut self) {
        self.itemshoppinglist.clear();
    }

    // Param is passed by value, moved
    pub fn set_itemshoppinglist(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails>) {
        self.itemshoppinglist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_itemshoppinglist(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.itemshoppinglist
    }

    // Take field
    pub fn take_itemshoppinglist(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        ::std::mem::replace(&mut self.itemshoppinglist, ::protobuf::RepeatedField::new())
    }

    pub fn get_itemshoppinglist(&self) -> &[CMsgDOTARealtimeGameStats_ItemDetails] {
        &self.itemshoppinglist
    }

    fn get_itemshoppinglist_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &self.itemshoppinglist
    }

    fn mut_itemshoppinglist_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_ItemDetails> {
        &mut self.itemshoppinglist
    }

    // repeated .CMsgDOTARealtimeGameStats.AbilityList levelpoints = 46;

    pub fn clear_levelpoints(&mut self) {
        self.levelpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_levelpoints(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList>) {
        self.levelpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_levelpoints(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList> {
        &mut self.levelpoints
    }

    // Take field
    pub fn take_levelpoints(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList> {
        ::std::mem::replace(&mut self.levelpoints, ::protobuf::RepeatedField::new())
    }

    pub fn get_levelpoints(&self) -> &[CMsgDOTARealtimeGameStats_AbilityList] {
        &self.levelpoints
    }

    fn get_levelpoints_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList> {
        &self.levelpoints
    }

    fn mut_levelpoints_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_AbilityList> {
        &mut self.levelpoints
    }

    // repeated .CMsgDOTARealtimeGameStats.HeroToHeroStats hero_to_hero_stats = 47;

    pub fn clear_hero_to_hero_stats(&mut self) {
        self.hero_to_hero_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_to_hero_stats(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats>) {
        self.hero_to_hero_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_to_hero_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats> {
        &mut self.hero_to_hero_stats
    }

    // Take field
    pub fn take_hero_to_hero_stats(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats> {
        ::std::mem::replace(&mut self.hero_to_hero_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_hero_to_hero_stats(&self) -> &[CMsgDOTARealtimeGameStats_HeroToHeroStats] {
        &self.hero_to_hero_stats
    }

    fn get_hero_to_hero_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats> {
        &self.hero_to_hero_stats
    }

    fn mut_hero_to_hero_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_HeroToHeroStats> {
        &mut self.hero_to_hero_stats
    }

    // optional bool has_ultimate = 48;

    pub fn clear_has_ultimate(&mut self) {
        self.has_ultimate = ::std::option::Option::None;
    }

    pub fn has_has_ultimate(&self) -> bool {
        self.has_ultimate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_ultimate(&mut self, v: bool) {
        self.has_ultimate = ::std::option::Option::Some(v);
    }

    pub fn get_has_ultimate(&self) -> bool {
        self.has_ultimate.unwrap_or(false)
    }

    fn get_has_ultimate_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_ultimate
    }

    fn mut_has_ultimate_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_ultimate
    }

    // optional bool has_ultimate_mana = 49;

    pub fn clear_has_ultimate_mana(&mut self) {
        self.has_ultimate_mana = ::std::option::Option::None;
    }

    pub fn has_has_ultimate_mana(&self) -> bool {
        self.has_ultimate_mana.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_ultimate_mana(&mut self, v: bool) {
        self.has_ultimate_mana = ::std::option::Option::Some(v);
    }

    pub fn get_has_ultimate_mana(&self) -> bool {
        self.has_ultimate_mana.unwrap_or(false)
    }

    fn get_has_ultimate_mana_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_ultimate_mana
    }

    fn mut_has_ultimate_mana_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_ultimate_mana
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_PlayerDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stashitems {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.itemshoppinglist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.levelpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hero_to_hero_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.playerid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heroid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healthpoints = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxhealthpoints = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healthregenrate = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.manapoints = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxmanapoints = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.manaregenrate = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_strength = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_agility = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_intelligence = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.base_armor = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_movespeed = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_damage = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strength = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.agility = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.intelligence = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.armor = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.movespeed = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_damage = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_damage = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kill_count = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.death_count = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists_count = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies_count = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lh_count = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_healing = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_per_min = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_per_min = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_gold = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.respawn_time = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ultimate_cooldown = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_buyback = ::std::option::Option::Some(tmp);
                },
                43 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                44 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stashitems)?;
                },
                45 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.itemshoppinglist)?;
                },
                46 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.levelpoints)?;
                },
                47 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hero_to_hero_stats)?;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_ultimate = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_ultimate_mana = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heroid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healthpoints {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxhealthpoints {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healthregenrate {
            my_size += 5;
        }
        if let Some(v) = self.manapoints {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxmanapoints {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manaregenrate {
            my_size += 5;
        }
        if let Some(v) = self.base_strength {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_agility {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_intelligence {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_armor {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_movespeed {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_damage {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strength {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.agility {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.intelligence {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.armor {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.movespeed {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kill_count {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_count {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists_count {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies_count {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lh_count {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_healing {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_per_min {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_per_min {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_gold {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += 6;
        }
        if let Some(v) = self.y {
            my_size += 6;
        }
        if let Some(v) = self.respawn_time {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ultimate_cooldown {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.has_buyback {
            my_size += 3;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stashitems {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.itemshoppinglist {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.levelpoints {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.hero_to_hero_stats {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.has_ultimate {
            my_size += 3;
        }
        if let Some(v) = self.has_ultimate_mana {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.playerid {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.heroid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.healthpoints {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.maxhealthpoints {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.healthregenrate {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.manapoints {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.maxmanapoints {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.manaregenrate {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.base_strength {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.base_agility {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.base_intelligence {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.base_armor {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.base_movespeed {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.base_damage {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.strength {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.agility {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.intelligence {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.armor {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.movespeed {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(25, v)?;
        }
        for v in &self.abilities {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.level {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.kill_count {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.death_count {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.assists_count {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.denies_count {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.lh_count {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.hero_healing {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.gold_per_min {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.xp_per_min {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.net_gold {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.gold {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(38, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(39, v)?;
        }
        if let Some(v) = self.respawn_time {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.ultimate_cooldown {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.has_buyback {
            os.write_bool(42, v)?;
        }
        for v in &self.items {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stashitems {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.itemshoppinglist {
            os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.levelpoints {
            os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.hero_to_hero_stats {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.has_ultimate {
            os.write_bool(48, v)?;
        }
        if let Some(v) = self.has_ultimate_mana {
            os.write_bool(49, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_PlayerDetails {
    fn new() -> CMsgDOTARealtimeGameStats_PlayerDetails {
        CMsgDOTARealtimeGameStats_PlayerDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_PlayerDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_accountid_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "playerid",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_playerid_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_playerid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_name_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_team_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "heroid",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_heroid_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_heroid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "healthpoints",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_healthpoints_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_healthpoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maxhealthpoints",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_maxhealthpoints_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_maxhealthpoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "healthregenrate",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_healthregenrate_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_healthregenrate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "manapoints",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_manapoints_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_manapoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maxmanapoints",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_maxmanapoints_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_maxmanapoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "manaregenrate",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_manaregenrate_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_manaregenrate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_strength",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_strength_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_strength_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_agility",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_agility_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_agility_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_intelligence",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_intelligence_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_intelligence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "base_armor",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_armor_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_armor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_movespeed",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_movespeed_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_movespeed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_damage",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_base_damage_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_base_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "strength",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_strength_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_strength_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "agility",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_agility_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_agility_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "intelligence",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_intelligence_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_intelligence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "armor",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_armor_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_armor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "movespeed",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_movespeed_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_movespeed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_damage_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_damage",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_hero_damage_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_damage",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_tower_damage_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_AbilityDetails>>(
                    "abilities",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_abilities_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_abilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_level_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kill_count",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_kill_count_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_kill_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "death_count",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_death_count_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_death_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists_count",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_assists_count_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_assists_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies_count",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_denies_count_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_denies_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lh_count",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_lh_count_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_lh_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_healing",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_hero_healing_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_hero_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_per_min",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_gold_per_min_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_gold_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_per_min",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_xp_per_min_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_xp_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_gold",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_net_gold_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_net_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_gold_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_x_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_y_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "respawn_time",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_respawn_time_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_respawn_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ultimate_cooldown",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_ultimate_cooldown_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_ultimate_cooldown_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_buyback",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_has_buyback_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_has_buyback_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_ItemDetails>>(
                    "items",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_items_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_ItemDetails>>(
                    "stashitems",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_stashitems_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_stashitems_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_ItemDetails>>(
                    "itemshoppinglist",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_itemshoppinglist_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_itemshoppinglist_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_AbilityList>>(
                    "levelpoints",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_levelpoints_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_levelpoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_HeroToHeroStats>>(
                    "hero_to_hero_stats",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_hero_to_hero_stats_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_hero_to_hero_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_ultimate",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_has_ultimate_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_has_ultimate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_ultimate_mana",
                    CMsgDOTARealtimeGameStats_PlayerDetails::get_has_ultimate_mana_for_reflect,
                    CMsgDOTARealtimeGameStats_PlayerDetails::mut_has_ultimate_mana_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_PlayerDetails>(
                    "CMsgDOTARealtimeGameStats_PlayerDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_PlayerDetails {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_playerid();
        self.clear_name();
        self.clear_team();
        self.clear_heroid();
        self.clear_healthpoints();
        self.clear_maxhealthpoints();
        self.clear_healthregenrate();
        self.clear_manapoints();
        self.clear_maxmanapoints();
        self.clear_manaregenrate();
        self.clear_base_strength();
        self.clear_base_agility();
        self.clear_base_intelligence();
        self.clear_base_armor();
        self.clear_base_movespeed();
        self.clear_base_damage();
        self.clear_strength();
        self.clear_agility();
        self.clear_intelligence();
        self.clear_armor();
        self.clear_movespeed();
        self.clear_damage();
        self.clear_hero_damage();
        self.clear_tower_damage();
        self.clear_abilities();
        self.clear_level();
        self.clear_kill_count();
        self.clear_death_count();
        self.clear_assists_count();
        self.clear_denies_count();
        self.clear_lh_count();
        self.clear_hero_healing();
        self.clear_gold_per_min();
        self.clear_xp_per_min();
        self.clear_net_gold();
        self.clear_gold();
        self.clear_x();
        self.clear_y();
        self.clear_respawn_time();
        self.clear_ultimate_cooldown();
        self.clear_has_buyback();
        self.clear_items();
        self.clear_stashitems();
        self.clear_itemshoppinglist();
        self.clear_levelpoints();
        self.clear_hero_to_hero_stats();
        self.clear_has_ultimate();
        self.clear_has_ultimate_mana();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_PlayerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_PlayerDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_BuildingDetails {
    // message fields
    team: ::std::option::Option<u32>,
    heading: ::std::option::Option<f32>,
    lane: ::std::option::Option<u32>,
    tier: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    destroyed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_BuildingDetails {}

impl CMsgDOTARealtimeGameStats_BuildingDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_BuildingDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_BuildingDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_BuildingDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_BuildingDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_BuildingDetails::new)
        }
    }

    // optional uint32 team = 2;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional float heading = 3;

    pub fn clear_heading(&mut self) {
        self.heading = ::std::option::Option::None;
    }

    pub fn has_heading(&self) -> bool {
        self.heading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: f32) {
        self.heading = ::std::option::Option::Some(v);
    }

    pub fn get_heading(&self) -> f32 {
        self.heading.unwrap_or(0.)
    }

    fn get_heading_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.heading
    }

    fn mut_heading_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.heading
    }

    // optional uint32 lane = 4;

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    pub fn get_lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    fn get_lane_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lane
    }

    fn mut_lane_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lane
    }

    // optional uint32 tier = 5;

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    pub fn get_tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    fn get_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tier
    }

    fn mut_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tier
    }

    // optional uint32 type = 6;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // optional float x = 7;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 8;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }

    // optional bool destroyed = 9;

    pub fn clear_destroyed(&mut self) {
        self.destroyed = ::std::option::Option::None;
    }

    pub fn has_destroyed(&self) -> bool {
        self.destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroyed(&mut self, v: bool) {
        self.destroyed = ::std::option::Option::Some(v);
    }

    pub fn get_destroyed(&self) -> bool {
        self.destroyed.unwrap_or(false)
    }

    fn get_destroyed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.destroyed
    }

    fn mut_destroyed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.destroyed
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_BuildingDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.heading = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lane = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tier = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.destroyed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heading {
            my_size += 5;
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        if let Some(v) = self.destroyed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.heading {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.destroyed {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_BuildingDetails {
    fn new() -> CMsgDOTARealtimeGameStats_BuildingDetails {
        CMsgDOTARealtimeGameStats_BuildingDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_BuildingDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_team_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "heading",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_heading_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_heading_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lane",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_lane_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_lane_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tier",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_tier_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_field_type_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_x_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_y_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "destroyed",
                    CMsgDOTARealtimeGameStats_BuildingDetails::get_destroyed_for_reflect,
                    CMsgDOTARealtimeGameStats_BuildingDetails::mut_destroyed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_BuildingDetails>(
                    "CMsgDOTARealtimeGameStats_BuildingDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_BuildingDetails {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_heading();
        self.clear_lane();
        self.clear_tier();
        self.clear_field_type();
        self.clear_x();
        self.clear_y();
        self.clear_destroyed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_BuildingDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_BuildingDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_KillDetails {
    // message fields
    player_id: ::std::option::Option<u32>,
    death_time: ::std::option::Option<i32>,
    killer_player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_KillDetails {}

impl CMsgDOTARealtimeGameStats_KillDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_KillDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_KillDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_KillDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_KillDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_KillDetails::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional int32 death_time = 2;

    pub fn clear_death_time(&mut self) {
        self.death_time = ::std::option::Option::None;
    }

    pub fn has_death_time(&self) -> bool {
        self.death_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_time(&mut self, v: i32) {
        self.death_time = ::std::option::Option::Some(v);
    }

    pub fn get_death_time(&self) -> i32 {
        self.death_time.unwrap_or(0)
    }

    fn get_death_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.death_time
    }

    fn mut_death_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.death_time
    }

    // optional uint32 killer_player_id = 3;

    pub fn clear_killer_player_id(&mut self) {
        self.killer_player_id = ::std::option::Option::None;
    }

    pub fn has_killer_player_id(&self) -> bool {
        self.killer_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_player_id(&mut self, v: u32) {
        self.killer_player_id = ::std::option::Option::Some(v);
    }

    pub fn get_killer_player_id(&self) -> u32 {
        self.killer_player_id.unwrap_or(0)
    }

    fn get_killer_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killer_player_id
    }

    fn mut_killer_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killer_player_id
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_KillDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.death_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killer_player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.killer_player_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.death_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.killer_player_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_KillDetails {
    fn new() -> CMsgDOTARealtimeGameStats_KillDetails {
        CMsgDOTARealtimeGameStats_KillDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_KillDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CMsgDOTARealtimeGameStats_KillDetails::get_player_id_for_reflect,
                    CMsgDOTARealtimeGameStats_KillDetails::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "death_time",
                    CMsgDOTARealtimeGameStats_KillDetails::get_death_time_for_reflect,
                    CMsgDOTARealtimeGameStats_KillDetails::mut_death_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killer_player_id",
                    CMsgDOTARealtimeGameStats_KillDetails::get_killer_player_id_for_reflect,
                    CMsgDOTARealtimeGameStats_KillDetails::mut_killer_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_KillDetails>(
                    "CMsgDOTARealtimeGameStats_KillDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_KillDetails {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_death_time();
        self.clear_killer_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_KillDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_KillDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_BroadcasterDetails {
    // message fields
    player_id: ::std::option::Option<u32>,
    selected_hero: ::std::option::Option<u32>,
    selected_graph: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_BroadcasterDetails {}

impl CMsgDOTARealtimeGameStats_BroadcasterDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_BroadcasterDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_BroadcasterDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_BroadcasterDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_BroadcasterDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_BroadcasterDetails::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 selected_hero = 2;

    pub fn clear_selected_hero(&mut self) {
        self.selected_hero = ::std::option::Option::None;
    }

    pub fn has_selected_hero(&self) -> bool {
        self.selected_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_hero(&mut self, v: u32) {
        self.selected_hero = ::std::option::Option::Some(v);
    }

    pub fn get_selected_hero(&self) -> u32 {
        self.selected_hero.unwrap_or(0)
    }

    fn get_selected_hero_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selected_hero
    }

    fn mut_selected_hero_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selected_hero
    }

    // optional uint32 selected_graph = 3;

    pub fn clear_selected_graph(&mut self) {
        self.selected_graph = ::std::option::Option::None;
    }

    pub fn has_selected_graph(&self) -> bool {
        self.selected_graph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_graph(&mut self, v: u32) {
        self.selected_graph = ::std::option::Option::Some(v);
    }

    pub fn get_selected_graph(&self) -> u32 {
        self.selected_graph.unwrap_or(0)
    }

    fn get_selected_graph_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selected_graph
    }

    fn mut_selected_graph_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selected_graph
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_BroadcasterDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selected_hero = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selected_graph = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selected_hero {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selected_graph {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.selected_hero {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.selected_graph {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_BroadcasterDetails {
    fn new() -> CMsgDOTARealtimeGameStats_BroadcasterDetails {
        CMsgDOTARealtimeGameStats_BroadcasterDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_BroadcasterDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::get_player_id_for_reflect,
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selected_hero",
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::get_selected_hero_for_reflect,
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::mut_selected_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selected_graph",
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::get_selected_graph_for_reflect,
                    CMsgDOTARealtimeGameStats_BroadcasterDetails::mut_selected_graph_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_BroadcasterDetails>(
                    "CMsgDOTARealtimeGameStats_BroadcasterDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_BroadcasterDetails {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_selected_hero();
        self.clear_selected_graph();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_BroadcasterDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_BroadcasterDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_PickBanDetails {
    // message fields
    hero: ::std::option::Option<u32>,
    team: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_PickBanDetails {}

impl CMsgDOTARealtimeGameStats_PickBanDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_PickBanDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_PickBanDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_PickBanDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_PickBanDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_PickBanDetails::new)
        }
    }

    // optional uint32 hero = 1;

    pub fn clear_hero(&mut self) {
        self.hero = ::std::option::Option::None;
    }

    pub fn has_hero(&self) -> bool {
        self.hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero(&mut self, v: u32) {
        self.hero = ::std::option::Option::Some(v);
    }

    pub fn get_hero(&self) -> u32 {
        self.hero.unwrap_or(0)
    }

    fn get_hero_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero
    }

    fn mut_hero_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero
    }

    // optional uint32 team = 2;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_PickBanDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_PickBanDetails {
    fn new() -> CMsgDOTARealtimeGameStats_PickBanDetails {
        CMsgDOTARealtimeGameStats_PickBanDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_PickBanDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero",
                    CMsgDOTARealtimeGameStats_PickBanDetails::get_hero_for_reflect,
                    CMsgDOTARealtimeGameStats_PickBanDetails::mut_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARealtimeGameStats_PickBanDetails::get_team_for_reflect,
                    CMsgDOTARealtimeGameStats_PickBanDetails::mut_team_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_PickBanDetails>(
                    "CMsgDOTARealtimeGameStats_PickBanDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_PickBanDetails {
    fn clear(&mut self) {
        self.clear_hero();
        self.clear_team();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_PickBanDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_PickBanDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_MatchDetails {
    // message fields
    server_steam_id: ::std::option::Option<u64>,
    matchid: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    time_of_day: ::std::option::Option<f32>,
    is_nightstalker_night: ::std::option::Option<bool>,
    game_time: ::std::option::Option<i32>,
    teamid_radiant: ::std::option::Option<u32>,
    teamid_dire: ::std::option::Option<u32>,
    picks: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails>,
    bans: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails>,
    kills: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails>,
    broadcasters: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails>,
    game_mode: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    single_team: ::std::option::Option<bool>,
    cheers_peak: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_MatchDetails {}

impl CMsgDOTARealtimeGameStats_MatchDetails {
    pub fn new() -> CMsgDOTARealtimeGameStats_MatchDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_MatchDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_MatchDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_MatchDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_MatchDetails::new)
        }
    }

    // optional fixed64 server_steam_id = 1;

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    fn get_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_steam_id
    }

    fn mut_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_steam_id
    }

    // optional uint64 matchid = 2;

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    fn get_matchid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.matchid
    }

    fn mut_matchid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.matchid
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional float time_of_day = 4;

    pub fn clear_time_of_day(&mut self) {
        self.time_of_day = ::std::option::Option::None;
    }

    pub fn has_time_of_day(&self) -> bool {
        self.time_of_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: f32) {
        self.time_of_day = ::std::option::Option::Some(v);
    }

    pub fn get_time_of_day(&self) -> f32 {
        self.time_of_day.unwrap_or(0.)
    }

    fn get_time_of_day_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.time_of_day
    }

    fn mut_time_of_day_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.time_of_day
    }

    // optional bool is_nightstalker_night = 5;

    pub fn clear_is_nightstalker_night(&mut self) {
        self.is_nightstalker_night = ::std::option::Option::None;
    }

    pub fn has_is_nightstalker_night(&self) -> bool {
        self.is_nightstalker_night.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_nightstalker_night(&mut self, v: bool) {
        self.is_nightstalker_night = ::std::option::Option::Some(v);
    }

    pub fn get_is_nightstalker_night(&self) -> bool {
        self.is_nightstalker_night.unwrap_or(false)
    }

    fn get_is_nightstalker_night_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_nightstalker_night
    }

    fn mut_is_nightstalker_night_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_nightstalker_night
    }

    // optional int32 game_time = 6;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: i32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> i32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.game_time
    }

    // optional uint32 teamid_radiant = 8;

    pub fn clear_teamid_radiant(&mut self) {
        self.teamid_radiant = ::std::option::Option::None;
    }

    pub fn has_teamid_radiant(&self) -> bool {
        self.teamid_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamid_radiant(&mut self, v: u32) {
        self.teamid_radiant = ::std::option::Option::Some(v);
    }

    pub fn get_teamid_radiant(&self) -> u32 {
        self.teamid_radiant.unwrap_or(0)
    }

    fn get_teamid_radiant_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teamid_radiant
    }

    fn mut_teamid_radiant_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teamid_radiant
    }

    // optional uint32 teamid_dire = 9;

    pub fn clear_teamid_dire(&mut self) {
        self.teamid_dire = ::std::option::Option::None;
    }

    pub fn has_teamid_dire(&self) -> bool {
        self.teamid_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamid_dire(&mut self, v: u32) {
        self.teamid_dire = ::std::option::Option::Some(v);
    }

    pub fn get_teamid_dire(&self) -> u32 {
        self.teamid_dire.unwrap_or(0)
    }

    fn get_teamid_dire_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teamid_dire
    }

    fn mut_teamid_dire_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teamid_dire
    }

    // repeated .CMsgDOTARealtimeGameStats.PickBanDetails picks = 10;

    pub fn clear_picks(&mut self) {
        self.picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails>) {
        self.picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &mut self.picks
    }

    // Take field
    pub fn take_picks(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        ::std::mem::replace(&mut self.picks, ::protobuf::RepeatedField::new())
    }

    pub fn get_picks(&self) -> &[CMsgDOTARealtimeGameStats_PickBanDetails] {
        &self.picks
    }

    fn get_picks_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &self.picks
    }

    fn mut_picks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &mut self.picks
    }

    // repeated .CMsgDOTARealtimeGameStats.PickBanDetails bans = 11;

    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }

    pub fn get_bans(&self) -> &[CMsgDOTARealtimeGameStats_PickBanDetails] {
        &self.bans
    }

    fn get_bans_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &self.bans
    }

    fn mut_bans_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_PickBanDetails> {
        &mut self.bans
    }

    // repeated .CMsgDOTARealtimeGameStats.KillDetails kills = 12;

    pub fn clear_kills(&mut self) {
        self.kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails>) {
        self.kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kills(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails> {
        &mut self.kills
    }

    // Take field
    pub fn take_kills(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails> {
        ::std::mem::replace(&mut self.kills, ::protobuf::RepeatedField::new())
    }

    pub fn get_kills(&self) -> &[CMsgDOTARealtimeGameStats_KillDetails] {
        &self.kills
    }

    fn get_kills_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_KillDetails> {
        &mut self.kills
    }

    // repeated .CMsgDOTARealtimeGameStats.BroadcasterDetails broadcasters = 13;

    pub fn clear_broadcasters(&mut self) {
        self.broadcasters.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasters(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails>) {
        self.broadcasters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails> {
        &mut self.broadcasters
    }

    // Take field
    pub fn take_broadcasters(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails> {
        ::std::mem::replace(&mut self.broadcasters, ::protobuf::RepeatedField::new())
    }

    pub fn get_broadcasters(&self) -> &[CMsgDOTARealtimeGameStats_BroadcasterDetails] {
        &self.broadcasters
    }

    fn get_broadcasters_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails> {
        &self.broadcasters
    }

    fn mut_broadcasters_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_BroadcasterDetails> {
        &mut self.broadcasters
    }

    // optional uint32 game_mode = 14;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_mode
    }

    // optional uint32 league_id = 15;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional bool single_team = 16;

    pub fn clear_single_team(&mut self) {
        self.single_team = ::std::option::Option::None;
    }

    pub fn has_single_team(&self) -> bool {
        self.single_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_single_team(&mut self, v: bool) {
        self.single_team = ::std::option::Option::Some(v);
    }

    pub fn get_single_team(&self) -> bool {
        self.single_team.unwrap_or(false)
    }

    fn get_single_team_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.single_team
    }

    fn mut_single_team_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.single_team
    }

    // optional uint32 cheers_peak = 17;

    pub fn clear_cheers_peak(&mut self) {
        self.cheers_peak = ::std::option::Option::None;
    }

    pub fn has_cheers_peak(&self) -> bool {
        self.cheers_peak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheers_peak(&mut self, v: u32) {
        self.cheers_peak = ::std::option::Option::Some(v);
    }

    pub fn get_cheers_peak(&self) -> u32 {
        self.cheers_peak.unwrap_or(0)
    }

    fn get_cheers_peak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cheers_peak
    }

    fn mut_cheers_peak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cheers_peak
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_MatchDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.picks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.broadcasters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.time_of_day = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_nightstalker_night = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teamid_radiant = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teamid_dire = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kills)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.broadcasters)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.single_team = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cheers_peak = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_of_day {
            my_size += 5;
        }
        if let Some(v) = self.is_nightstalker_night {
            my_size += 2;
        }
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamid_radiant {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamid_dire {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.kills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.broadcasters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.single_team {
            my_size += 3;
        }
        if let Some(v) = self.cheers_peak {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.time_of_day {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.is_nightstalker_night {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.teamid_radiant {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.teamid_dire {
            os.write_uint32(9, v)?;
        }
        for v in &self.picks {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.bans {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.kills {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.broadcasters {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.game_mode {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.single_team {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.cheers_peak {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_MatchDetails {
    fn new() -> CMsgDOTARealtimeGameStats_MatchDetails {
        CMsgDOTARealtimeGameStats_MatchDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_MatchDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "server_steam_id",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_server_steam_id_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_matchid_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_matchid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_timestamp_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "time_of_day",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_time_of_day_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_time_of_day_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_nightstalker_night",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_is_nightstalker_night_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_is_nightstalker_night_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_time",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_game_time_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teamid_radiant",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_teamid_radiant_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_teamid_radiant_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teamid_dire",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_teamid_dire_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_teamid_dire_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_PickBanDetails>>(
                    "picks",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_picks_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_picks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_PickBanDetails>>(
                    "bans",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_bans_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_bans_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_KillDetails>>(
                    "kills",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_kills_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_BroadcasterDetails>>(
                    "broadcasters",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_broadcasters_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_broadcasters_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_mode",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_game_mode_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_league_id_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "single_team",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_single_team_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_single_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cheers_peak",
                    CMsgDOTARealtimeGameStats_MatchDetails::get_cheers_peak_for_reflect,
                    CMsgDOTARealtimeGameStats_MatchDetails::mut_cheers_peak_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_MatchDetails>(
                    "CMsgDOTARealtimeGameStats_MatchDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_MatchDetails {
    fn clear(&mut self) {
        self.clear_server_steam_id();
        self.clear_matchid();
        self.clear_timestamp();
        self.clear_time_of_day();
        self.clear_is_nightstalker_night();
        self.clear_game_time();
        self.clear_teamid_radiant();
        self.clear_teamid_dire();
        self.clear_picks();
        self.clear_bans();
        self.clear_kills();
        self.clear_broadcasters();
        self.clear_game_mode();
        self.clear_league_id();
        self.clear_single_team();
        self.clear_cheers_peak();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_MatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_MatchDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_GraphData {
    // message fields
    graph_gold: ::std::vec::Vec<i32>,
    graph_xp: ::std::vec::Vec<i32>,
    graph_kill: ::std::vec::Vec<i32>,
    graph_tower: ::std::vec::Vec<i32>,
    graph_rax: ::std::vec::Vec<i32>,
    team_loc_stats: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_GraphData {}

impl CMsgDOTARealtimeGameStats_GraphData {
    pub fn new() -> CMsgDOTARealtimeGameStats_GraphData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_GraphData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_GraphData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_GraphData,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_GraphData::new)
        }
    }

    // repeated int32 graph_gold = 1;

    pub fn clear_graph_gold(&mut self) {
        self.graph_gold.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_gold(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_gold = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_gold(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_gold
    }

    // Take field
    pub fn take_graph_gold(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_gold, ::std::vec::Vec::new())
    }

    pub fn get_graph_gold(&self) -> &[i32] {
        &self.graph_gold
    }

    fn get_graph_gold_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_gold
    }

    fn mut_graph_gold_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_gold
    }

    // repeated int32 graph_xp = 2;

    pub fn clear_graph_xp(&mut self) {
        self.graph_xp.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_xp(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_xp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_xp(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_xp
    }

    // Take field
    pub fn take_graph_xp(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_xp, ::std::vec::Vec::new())
    }

    pub fn get_graph_xp(&self) -> &[i32] {
        &self.graph_xp
    }

    fn get_graph_xp_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_xp
    }

    fn mut_graph_xp_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_xp
    }

    // repeated int32 graph_kill = 3;

    pub fn clear_graph_kill(&mut self) {
        self.graph_kill.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_kill(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_kill = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_kill(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_kill
    }

    // Take field
    pub fn take_graph_kill(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_kill, ::std::vec::Vec::new())
    }

    pub fn get_graph_kill(&self) -> &[i32] {
        &self.graph_kill
    }

    fn get_graph_kill_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_kill
    }

    fn mut_graph_kill_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_kill
    }

    // repeated int32 graph_tower = 4;

    pub fn clear_graph_tower(&mut self) {
        self.graph_tower.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_tower(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_tower = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_tower(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_tower
    }

    // Take field
    pub fn take_graph_tower(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_tower, ::std::vec::Vec::new())
    }

    pub fn get_graph_tower(&self) -> &[i32] {
        &self.graph_tower
    }

    fn get_graph_tower_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_tower
    }

    fn mut_graph_tower_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_tower
    }

    // repeated int32 graph_rax = 5;

    pub fn clear_graph_rax(&mut self) {
        self.graph_rax.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_rax(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_rax = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_rax(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_rax
    }

    // Take field
    pub fn take_graph_rax(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_rax, ::std::vec::Vec::new())
    }

    pub fn get_graph_rax(&self) -> &[i32] {
        &self.graph_rax
    }

    fn get_graph_rax_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_rax
    }

    fn mut_graph_rax_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_rax
    }

    // repeated .CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats team_loc_stats = 6;

    pub fn clear_team_loc_stats(&mut self) {
        self.team_loc_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_loc_stats(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>) {
        self.team_loc_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_loc_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats> {
        &mut self.team_loc_stats
    }

    // Take field
    pub fn take_team_loc_stats(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats> {
        ::std::mem::replace(&mut self.team_loc_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_team_loc_stats(&self) -> &[CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats] {
        &self.team_loc_stats
    }

    fn get_team_loc_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats> {
        &self.team_loc_stats
    }

    fn mut_team_loc_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats> {
        &mut self.team_loc_stats
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_GraphData {
    fn is_initialized(&self) -> bool {
        for v in &self.team_loc_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_gold)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_xp)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_kill)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_tower)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_rax)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.team_loc_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.graph_gold {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.graph_xp {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.graph_kill {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.graph_tower {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.graph_rax {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.team_loc_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.graph_gold {
            os.write_int32(1, *v)?;
        };
        for v in &self.graph_xp {
            os.write_int32(2, *v)?;
        };
        for v in &self.graph_kill {
            os.write_int32(3, *v)?;
        };
        for v in &self.graph_tower {
            os.write_int32(4, *v)?;
        };
        for v in &self.graph_rax {
            os.write_int32(5, *v)?;
        };
        for v in &self.team_loc_stats {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_GraphData {
    fn new() -> CMsgDOTARealtimeGameStats_GraphData {
        CMsgDOTARealtimeGameStats_GraphData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_gold",
                    CMsgDOTARealtimeGameStats_GraphData::get_graph_gold_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_graph_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_xp",
                    CMsgDOTARealtimeGameStats_GraphData::get_graph_xp_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_graph_xp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_kill",
                    CMsgDOTARealtimeGameStats_GraphData::get_graph_kill_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_graph_kill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_tower",
                    CMsgDOTARealtimeGameStats_GraphData::get_graph_tower_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_graph_tower_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_rax",
                    CMsgDOTARealtimeGameStats_GraphData::get_graph_rax_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_graph_rax_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>>(
                    "team_loc_stats",
                    CMsgDOTARealtimeGameStats_GraphData::get_team_loc_stats_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData::mut_team_loc_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_GraphData>(
                    "CMsgDOTARealtimeGameStats_GraphData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_GraphData {
    fn clear(&mut self) {
        self.clear_graph_gold();
        self.clear_graph_xp();
        self.clear_graph_kill();
        self.clear_graph_tower();
        self.clear_graph_rax();
        self.clear_team_loc_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_GraphData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_GraphData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    // message fields
    stats: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_GraphData_LocationStats {}

impl CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    pub fn new() -> CMsgDOTARealtimeGameStats_GraphData_LocationStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_GraphData_LocationStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_GraphData_LocationStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_GraphData_LocationStats,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_GraphData_LocationStats::new)
        }
    }

    // repeated int32 stats = 1;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<i32>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    pub fn get_stats(&self) -> &[i32] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    fn new() -> CMsgDOTARealtimeGameStats_GraphData_LocationStats {
        CMsgDOTARealtimeGameStats_GraphData_LocationStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_LocationStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stats",
                    CMsgDOTARealtimeGameStats_GraphData_LocationStats::get_stats_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData_LocationStats::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_GraphData_LocationStats>(
                    "CMsgDOTARealtimeGameStats_GraphData_LocationStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    fn clear(&mut self) {
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    // message fields
    loc_stats: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {}

impl CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    pub fn new() -> CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::new)
        }
    }

    // repeated .CMsgDOTARealtimeGameStats.GraphData.LocationStats loc_stats = 1;

    pub fn clear_loc_stats(&mut self) {
        self.loc_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_loc_stats(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats>) {
        self.loc_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loc_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats> {
        &mut self.loc_stats
    }

    // Take field
    pub fn take_loc_stats(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats> {
        ::std::mem::replace(&mut self.loc_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_loc_stats(&self) -> &[CMsgDOTARealtimeGameStats_GraphData_LocationStats] {
        &self.loc_stats
    }

    fn get_loc_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats> {
        &self.loc_stats
    }

    fn mut_loc_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStats_GraphData_LocationStats> {
        &mut self.loc_stats
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    fn is_initialized(&self) -> bool {
        for v in &self.loc_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.loc_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.loc_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.loc_stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    fn new() -> CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
        CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStats_GraphData_LocationStats>>(
                    "loc_stats",
                    CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::get_loc_stats_for_reflect,
                    CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::mut_loc_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>(
                    "CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    fn clear(&mut self) {
        self.clear_loc_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTARealtimeGameStats_GraphData_eStat {
    CreepGoldEarned = 0,
    KillGoldEarned = 1,
    DeathAndBuybackGoldLost = 2,
    XPEarned = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTARealtimeGameStats_GraphData_eStat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_eStat> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eStat::CreepGoldEarned),
            1 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eStat::KillGoldEarned),
            2 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eStat::DeathAndBuybackGoldLost),
            3 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eStat::XPEarned),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTARealtimeGameStats_GraphData_eStat] = &[
            CMsgDOTARealtimeGameStats_GraphData_eStat::CreepGoldEarned,
            CMsgDOTARealtimeGameStats_GraphData_eStat::KillGoldEarned,
            CMsgDOTARealtimeGameStats_GraphData_eStat::DeathAndBuybackGoldLost,
            CMsgDOTARealtimeGameStats_GraphData_eStat::XPEarned,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_eStat>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTARealtimeGameStats_GraphData_eStat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTARealtimeGameStats_GraphData_eStat {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_GraphData_eStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTARealtimeGameStats_GraphData_eLocation {
    BotLane = 0,
    MidLane = 1,
    TopLane = 2,
    Jungle = 3,
    Ancients = 4,
    Other = 5,
}

impl ::protobuf::ProtobufEnum for CMsgDOTARealtimeGameStats_GraphData_eLocation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_eLocation> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::BotLane),
            1 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::MidLane),
            2 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::TopLane),
            3 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::Jungle),
            4 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::Ancients),
            5 => ::std::option::Option::Some(CMsgDOTARealtimeGameStats_GraphData_eLocation::Other),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTARealtimeGameStats_GraphData_eLocation] = &[
            CMsgDOTARealtimeGameStats_GraphData_eLocation::BotLane,
            CMsgDOTARealtimeGameStats_GraphData_eLocation::MidLane,
            CMsgDOTARealtimeGameStats_GraphData_eLocation::TopLane,
            CMsgDOTARealtimeGameStats_GraphData_eLocation::Jungle,
            CMsgDOTARealtimeGameStats_GraphData_eLocation::Ancients,
            CMsgDOTARealtimeGameStats_GraphData_eLocation::Other,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStats_GraphData_eLocation>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTARealtimeGameStats_GraphData_eLocation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTARealtimeGameStats_GraphData_eLocation {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStats_GraphData_eLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse {
    // message fields
    field_match: ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_MatchDetails>,
    teams: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails>,
    buildings: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>,
    graph_data: ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_GraphData>,
    delta_frame: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse {}

impl CMsgDOTARealtimeGameStatsTerse {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse::new)
        }
    }

    // optional .CMsgDOTARealtimeGameStatsTerse.MatchDetails match = 1;

    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: CMsgDOTARealtimeGameStatsTerse_MatchDetails) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        self.field_match.take().unwrap_or_else(|| CMsgDOTARealtimeGameStatsTerse_MatchDetails::new())
    }

    pub fn get_field_match(&self) -> &CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        self.field_match.as_ref().unwrap_or_else(|| CMsgDOTARealtimeGameStatsTerse_MatchDetails::default_instance())
    }

    fn get_field_match_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_MatchDetails> {
        &self.field_match
    }

    fn mut_field_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_MatchDetails> {
        &mut self.field_match
    }

    // repeated .CMsgDOTARealtimeGameStatsTerse.TeamDetails teams = 2;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgDOTARealtimeGameStatsTerse_TeamDetails] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_TeamDetails> {
        &mut self.teams
    }

    // repeated .CMsgDOTARealtimeGameStatsTerse.BuildingDetails buildings = 3;

    pub fn clear_buildings(&mut self) {
        self.buildings.clear();
    }

    // Param is passed by value, moved
    pub fn set_buildings(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>) {
        self.buildings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buildings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails> {
        &mut self.buildings
    }

    // Take field
    pub fn take_buildings(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails> {
        ::std::mem::replace(&mut self.buildings, ::protobuf::RepeatedField::new())
    }

    pub fn get_buildings(&self) -> &[CMsgDOTARealtimeGameStatsTerse_BuildingDetails] {
        &self.buildings
    }

    fn get_buildings_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails> {
        &self.buildings
    }

    fn mut_buildings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_BuildingDetails> {
        &mut self.buildings
    }

    // optional .CMsgDOTARealtimeGameStatsTerse.GraphData graph_data = 4;

    pub fn clear_graph_data(&mut self) {
        self.graph_data.clear();
    }

    pub fn has_graph_data(&self) -> bool {
        self.graph_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph_data(&mut self, v: CMsgDOTARealtimeGameStatsTerse_GraphData) {
        self.graph_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_data(&mut self) -> &mut CMsgDOTARealtimeGameStatsTerse_GraphData {
        if self.graph_data.is_none() {
            self.graph_data.set_default();
        }
        self.graph_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph_data(&mut self) -> CMsgDOTARealtimeGameStatsTerse_GraphData {
        self.graph_data.take().unwrap_or_else(|| CMsgDOTARealtimeGameStatsTerse_GraphData::new())
    }

    pub fn get_graph_data(&self) -> &CMsgDOTARealtimeGameStatsTerse_GraphData {
        self.graph_data.as_ref().unwrap_or_else(|| CMsgDOTARealtimeGameStatsTerse_GraphData::default_instance())
    }

    fn get_graph_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_GraphData> {
        &self.graph_data
    }

    fn mut_graph_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTARealtimeGameStatsTerse_GraphData> {
        &mut self.graph_data
    }

    // optional bool delta_frame = 5;

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }

    pub fn get_delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    fn get_delta_frame_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.delta_frame
    }

    fn mut_delta_frame_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.delta_frame
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buildings)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delta_frame = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.teams {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buildings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.graph_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse {
    fn new() -> CMsgDOTARealtimeGameStatsTerse {
        CMsgDOTARealtimeGameStatsTerse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStatsTerse_MatchDetails>>(
                    "match",
                    CMsgDOTARealtimeGameStatsTerse::get_field_match_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse::mut_field_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStatsTerse_TeamDetails>>(
                    "teams",
                    CMsgDOTARealtimeGameStatsTerse::get_teams_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse::mut_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>>(
                    "buildings",
                    CMsgDOTARealtimeGameStatsTerse::get_buildings_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse::mut_buildings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStatsTerse_GraphData>>(
                    "graph_data",
                    CMsgDOTARealtimeGameStatsTerse::get_graph_data_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse::mut_graph_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delta_frame",
                    CMsgDOTARealtimeGameStatsTerse::get_delta_frame_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse::mut_delta_frame_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse>(
                    "CMsgDOTARealtimeGameStatsTerse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse {
    fn clear(&mut self) {
        self.clear_field_match();
        self.clear_teams();
        self.clear_buildings();
        self.clear_graph_data();
        self.clear_delta_frame();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    // message fields
    team_number: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_logo: ::std::option::Option<u64>,
    score: ::std::option::Option<u32>,
    players: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse_TeamDetails {}

impl CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse_TeamDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse_TeamDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse_TeamDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse_TeamDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse_TeamDetails::new)
        }
    }

    // optional uint32 team_number = 1;

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: u32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    pub fn get_team_number(&self) -> u32 {
        self.team_number.unwrap_or(0)
    }

    fn get_team_number_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_number
    }

    fn mut_team_number_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_number
    }

    // optional uint32 team_id = 2;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 3;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional fixed64 team_logo = 4;

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    fn get_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_logo
    }

    fn mut_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_logo
    }

    // optional uint32 score = 5;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // repeated .CMsgDOTARealtimeGameStatsTerse.PlayerDetails players = 6;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgDOTARealtimeGameStatsTerse_PlayerDetails] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.team_logo = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_logo {
            my_size += 9;
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(5, v)?;
        }
        for v in &self.players {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    fn new() -> CMsgDOTARealtimeGameStatsTerse_TeamDetails {
        CMsgDOTARealtimeGameStatsTerse_TeamDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse_TeamDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_number",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_team_number_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_team_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_team_id_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_team_name_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "team_logo",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_team_logo_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_score_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>>(
                    "players",
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::get_players_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_TeamDetails::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse_TeamDetails>(
                    "CMsgDOTARealtimeGameStatsTerse_TeamDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    fn clear(&mut self) {
        self.clear_team_number();
        self.clear_team_id();
        self.clear_team_name();
        self.clear_team_logo();
        self.clear_score();
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    // message fields
    accountid: ::std::option::Option<u32>,
    playerid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    team: ::std::option::Option<u32>,
    heroid: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    kill_count: ::std::option::Option<u32>,
    death_count: ::std::option::Option<u32>,
    assists_count: ::std::option::Option<u32>,
    denies_count: ::std::option::Option<u32>,
    lh_count: ::std::option::Option<u32>,
    gold: ::std::option::Option<u32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {}

impl CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse_PlayerDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse_PlayerDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse_PlayerDetails::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint32 playerid = 2;

    pub fn clear_playerid(&mut self) {
        self.playerid = ::std::option::Option::None;
    }

    pub fn has_playerid(&self) -> bool {
        self.playerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid(&mut self, v: u32) {
        self.playerid = ::std::option::Option::Some(v);
    }

    pub fn get_playerid(&self) -> u32 {
        self.playerid.unwrap_or(0)
    }

    fn get_playerid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.playerid
    }

    fn mut_playerid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.playerid
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 team = 4;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 heroid = 5;

    pub fn clear_heroid(&mut self) {
        self.heroid = ::std::option::Option::None;
    }

    pub fn has_heroid(&self) -> bool {
        self.heroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heroid(&mut self, v: u32) {
        self.heroid = ::std::option::Option::Some(v);
    }

    pub fn get_heroid(&self) -> u32 {
        self.heroid.unwrap_or(0)
    }

    fn get_heroid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.heroid
    }

    fn mut_heroid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.heroid
    }

    // optional uint32 level = 6;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional uint32 kill_count = 7;

    pub fn clear_kill_count(&mut self) {
        self.kill_count = ::std::option::Option::None;
    }

    pub fn has_kill_count(&self) -> bool {
        self.kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_count(&mut self, v: u32) {
        self.kill_count = ::std::option::Option::Some(v);
    }

    pub fn get_kill_count(&self) -> u32 {
        self.kill_count.unwrap_or(0)
    }

    fn get_kill_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kill_count
    }

    fn mut_kill_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kill_count
    }

    // optional uint32 death_count = 8;

    pub fn clear_death_count(&mut self) {
        self.death_count = ::std::option::Option::None;
    }

    pub fn has_death_count(&self) -> bool {
        self.death_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_count(&mut self, v: u32) {
        self.death_count = ::std::option::Option::Some(v);
    }

    pub fn get_death_count(&self) -> u32 {
        self.death_count.unwrap_or(0)
    }

    fn get_death_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.death_count
    }

    fn mut_death_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.death_count
    }

    // optional uint32 assists_count = 9;

    pub fn clear_assists_count(&mut self) {
        self.assists_count = ::std::option::Option::None;
    }

    pub fn has_assists_count(&self) -> bool {
        self.assists_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists_count(&mut self, v: u32) {
        self.assists_count = ::std::option::Option::Some(v);
    }

    pub fn get_assists_count(&self) -> u32 {
        self.assists_count.unwrap_or(0)
    }

    fn get_assists_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists_count
    }

    fn mut_assists_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists_count
    }

    // optional uint32 denies_count = 10;

    pub fn clear_denies_count(&mut self) {
        self.denies_count = ::std::option::Option::None;
    }

    pub fn has_denies_count(&self) -> bool {
        self.denies_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies_count(&mut self, v: u32) {
        self.denies_count = ::std::option::Option::Some(v);
    }

    pub fn get_denies_count(&self) -> u32 {
        self.denies_count.unwrap_or(0)
    }

    fn get_denies_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies_count
    }

    fn mut_denies_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies_count
    }

    // optional uint32 lh_count = 11;

    pub fn clear_lh_count(&mut self) {
        self.lh_count = ::std::option::Option::None;
    }

    pub fn has_lh_count(&self) -> bool {
        self.lh_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lh_count(&mut self, v: u32) {
        self.lh_count = ::std::option::Option::Some(v);
    }

    pub fn get_lh_count(&self) -> u32 {
        self.lh_count.unwrap_or(0)
    }

    fn get_lh_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lh_count
    }

    fn mut_lh_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lh_count
    }

    // optional uint32 gold = 12;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional float x = 13;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 14;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.playerid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heroid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kill_count = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.death_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies_count = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lh_count = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heroid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kill_count {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lh_count {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.playerid {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.heroid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.kill_count {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.death_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.assists_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.denies_count {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.lh_count {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.gold {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    fn new() -> CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
        CMsgDOTARealtimeGameStatsTerse_PlayerDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_accountid_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "playerid",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_playerid_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_playerid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_name_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_team_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "heroid",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_heroid_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_heroid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_level_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kill_count",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_kill_count_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_kill_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "death_count",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_death_count_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_death_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists_count",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_assists_count_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_assists_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies_count",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_denies_count_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_denies_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lh_count",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_lh_count_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_lh_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_gold_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_x_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::get_y_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::mut_y_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>(
                    "CMsgDOTARealtimeGameStatsTerse_PlayerDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_playerid();
        self.clear_name();
        self.clear_team();
        self.clear_heroid();
        self.clear_level();
        self.clear_kill_count();
        self.clear_death_count();
        self.clear_assists_count();
        self.clear_denies_count();
        self.clear_lh_count();
        self.clear_gold();
        self.clear_x();
        self.clear_y();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    // message fields
    team: ::std::option::Option<u32>,
    heading: ::std::option::Option<f32>,
    field_type: ::std::option::Option<u32>,
    lane: ::std::option::Option<u32>,
    tier: ::std::option::Option<u32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    destroyed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {}

impl CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse_BuildingDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse_BuildingDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse_BuildingDetails::new)
        }
    }

    // optional uint32 team = 1;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional float heading = 2;

    pub fn clear_heading(&mut self) {
        self.heading = ::std::option::Option::None;
    }

    pub fn has_heading(&self) -> bool {
        self.heading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: f32) {
        self.heading = ::std::option::Option::Some(v);
    }

    pub fn get_heading(&self) -> f32 {
        self.heading.unwrap_or(0.)
    }

    fn get_heading_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.heading
    }

    fn mut_heading_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.heading
    }

    // optional uint32 type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // optional uint32 lane = 4;

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    pub fn get_lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    fn get_lane_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lane
    }

    fn mut_lane_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lane
    }

    // optional uint32 tier = 5;

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    pub fn get_tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    fn get_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tier
    }

    fn mut_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tier
    }

    // optional float x = 6;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 7;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }

    // optional bool destroyed = 8;

    pub fn clear_destroyed(&mut self) {
        self.destroyed = ::std::option::Option::None;
    }

    pub fn has_destroyed(&self) -> bool {
        self.destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroyed(&mut self, v: bool) {
        self.destroyed = ::std::option::Option::Some(v);
    }

    pub fn get_destroyed(&self) -> bool {
        self.destroyed.unwrap_or(false)
    }

    fn get_destroyed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.destroyed
    }

    fn mut_destroyed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.destroyed
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.heading = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lane = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tier = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.destroyed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heading {
            my_size += 5;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lane {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        if let Some(v) = self.destroyed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.heading {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.destroyed {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    fn new() -> CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
        CMsgDOTARealtimeGameStatsTerse_BuildingDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_team_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "heading",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_heading_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_heading_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_field_type_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lane",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_lane_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_lane_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tier",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_tier_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_x_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_y_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "destroyed",
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::get_destroyed_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::mut_destroyed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>(
                    "CMsgDOTARealtimeGameStatsTerse_BuildingDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_heading();
        self.clear_field_type();
        self.clear_lane();
        self.clear_tier();
        self.clear_x();
        self.clear_y();
        self.clear_destroyed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    // message fields
    server_steam_id: ::std::option::Option<u64>,
    matchid: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    game_time: ::std::option::Option<i32>,
    steam_broadcaster_account_ids: ::std::vec::Vec<u32>,
    game_mode: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse_MatchDetails {}

impl CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse_MatchDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse_MatchDetails,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse_MatchDetails::new)
        }
    }

    // optional fixed64 server_steam_id = 1;

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    fn get_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_steam_id
    }

    fn mut_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_steam_id
    }

    // optional uint64 matchid = 2;

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    fn get_matchid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.matchid
    }

    fn mut_matchid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.matchid
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional int32 game_time = 4;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: i32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> i32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.game_time
    }

    // repeated uint32 steam_broadcaster_account_ids = 6;

    pub fn clear_steam_broadcaster_account_ids(&mut self) {
        self.steam_broadcaster_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steam_broadcaster_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.steam_broadcaster_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steam_broadcaster_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.steam_broadcaster_account_ids
    }

    // Take field
    pub fn take_steam_broadcaster_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.steam_broadcaster_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_steam_broadcaster_account_ids(&self) -> &[u32] {
        &self.steam_broadcaster_account_ids
    }

    fn get_steam_broadcaster_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.steam_broadcaster_account_ids
    }

    fn mut_steam_broadcaster_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.steam_broadcaster_account_ids
    }

    // optional uint32 game_mode = 7;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_mode
    }

    // optional uint32 league_id = 8;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.steam_broadcaster_account_ids)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.steam_broadcaster_account_ids {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_int32(4, v)?;
        }
        for v in &self.steam_broadcaster_account_ids {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.game_mode {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    fn new() -> CMsgDOTARealtimeGameStatsTerse_MatchDetails {
        CMsgDOTARealtimeGameStatsTerse_MatchDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse_MatchDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "server_steam_id",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_server_steam_id_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_matchid_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_matchid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_timestamp_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_time",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_game_time_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "steam_broadcaster_account_ids",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_steam_broadcaster_account_ids_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_steam_broadcaster_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_mode",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_game_mode_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::get_league_id_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_MatchDetails::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse_MatchDetails>(
                    "CMsgDOTARealtimeGameStatsTerse_MatchDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    fn clear(&mut self) {
        self.clear_server_steam_id();
        self.clear_matchid();
        self.clear_timestamp();
        self.clear_game_time();
        self.clear_steam_broadcaster_account_ids();
        self.clear_game_mode();
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARealtimeGameStatsTerse_GraphData {
    // message fields
    graph_gold: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARealtimeGameStatsTerse_GraphData {}

impl CMsgDOTARealtimeGameStatsTerse_GraphData {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse_GraphData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse_GraphData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARealtimeGameStatsTerse_GraphData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARealtimeGameStatsTerse_GraphData,
        };
        unsafe {
            instance.get(CMsgDOTARealtimeGameStatsTerse_GraphData::new)
        }
    }

    // repeated int32 graph_gold = 1;

    pub fn clear_graph_gold(&mut self) {
        self.graph_gold.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_gold(&mut self, v: ::std::vec::Vec<i32>) {
        self.graph_gold = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_gold(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_gold
    }

    // Take field
    pub fn take_graph_gold(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.graph_gold, ::std::vec::Vec::new())
    }

    pub fn get_graph_gold(&self) -> &[i32] {
        &self.graph_gold
    }

    fn get_graph_gold_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.graph_gold
    }

    fn mut_graph_gold_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.graph_gold
    }
}

impl ::protobuf::Message for CMsgDOTARealtimeGameStatsTerse_GraphData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.graph_gold)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.graph_gold {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.graph_gold {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARealtimeGameStatsTerse_GraphData {
    fn new() -> CMsgDOTARealtimeGameStatsTerse_GraphData {
        CMsgDOTARealtimeGameStatsTerse_GraphData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARealtimeGameStatsTerse_GraphData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "graph_gold",
                    CMsgDOTARealtimeGameStatsTerse_GraphData::get_graph_gold_for_reflect,
                    CMsgDOTARealtimeGameStatsTerse_GraphData::mut_graph_gold_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARealtimeGameStatsTerse_GraphData>(
                    "CMsgDOTARealtimeGameStatsTerse_GraphData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARealtimeGameStatsTerse_GraphData {
    fn clear(&mut self) {
        self.clear_graph_gold();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARealtimeGameStatsTerse_GraphData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARealtimeGameStatsTerse_GraphData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientMatchGroupsVersion {
    // message fields
    matchgroups_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientMatchGroupsVersion {}

impl CMsgGCToClientMatchGroupsVersion {
    pub fn new() -> CMsgGCToClientMatchGroupsVersion {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientMatchGroupsVersion {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientMatchGroupsVersion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientMatchGroupsVersion,
        };
        unsafe {
            instance.get(CMsgGCToClientMatchGroupsVersion::new)
        }
    }

    // optional uint32 matchgroups_version = 1;

    pub fn clear_matchgroups_version(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
    }

    pub fn has_matchgroups_version(&self) -> bool {
        self.matchgroups_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups_version(&mut self, v: u32) {
        self.matchgroups_version = ::std::option::Option::Some(v);
    }

    pub fn get_matchgroups_version(&self) -> u32 {
        self.matchgroups_version.unwrap_or(0)
    }

    fn get_matchgroups_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matchgroups_version
    }

    fn mut_matchgroups_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matchgroups_version
    }
}

impl ::protobuf::Message for CMsgGCToClientMatchGroupsVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchgroups_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchgroups_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchgroups_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientMatchGroupsVersion {
    fn new() -> CMsgGCToClientMatchGroupsVersion {
        CMsgGCToClientMatchGroupsVersion::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientMatchGroupsVersion>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matchgroups_version",
                    CMsgGCToClientMatchGroupsVersion::get_matchgroups_version_for_reflect,
                    CMsgGCToClientMatchGroupsVersion::mut_matchgroups_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientMatchGroupsVersion>(
                    "CMsgGCToClientMatchGroupsVersion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientMatchGroupsVersion {
    fn clear(&mut self) {
        self.clear_matchgroups_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientMatchGroupsVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientMatchGroupsVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASDOHeroStatsHistory {
    // message fields
    match_id: ::std::option::Option<u64>,
    game_mode: ::std::option::Option<u32>,
    lobby_type: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    won: ::std::option::Option<bool>,
    gpm: ::std::option::Option<u32>,
    xpm: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASDOHeroStatsHistory {}

impl CMsgDOTASDOHeroStatsHistory {
    pub fn new() -> CMsgDOTASDOHeroStatsHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASDOHeroStatsHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASDOHeroStatsHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASDOHeroStatsHistory,
        };
        unsafe {
            instance.get(CMsgDOTASDOHeroStatsHistory::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 game_mode = 2;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_mode
    }

    // optional uint32 lobby_type = 3;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    fn get_lobby_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lobby_type
    }

    fn mut_lobby_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lobby_type
    }

    // optional uint32 start_time = 4;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional bool won = 5;

    pub fn clear_won(&mut self) {
        self.won = ::std::option::Option::None;
    }

    pub fn has_won(&self) -> bool {
        self.won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_won(&mut self, v: bool) {
        self.won = ::std::option::Option::Some(v);
    }

    pub fn get_won(&self) -> bool {
        self.won.unwrap_or(false)
    }

    fn get_won_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.won
    }

    fn mut_won_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.won
    }

    // optional uint32 gpm = 6;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gpm
    }

    // optional uint32 xpm = 7;

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    pub fn get_xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    fn get_xpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xpm
    }

    fn mut_xpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xpm
    }

    // optional uint32 kills = 8;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 9;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 assists = 10;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }
}

impl ::protobuf::Message for CMsgDOTASDOHeroStatsHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.won = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xpm = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.won {
            my_size += 2;
        }
        if let Some(v) = self.gpm {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xpm {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.won {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASDOHeroStatsHistory {
    fn new() -> CMsgDOTASDOHeroStatsHistory {
        CMsgDOTASDOHeroStatsHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASDOHeroStatsHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTASDOHeroStatsHistory::get_match_id_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_mode",
                    CMsgDOTASDOHeroStatsHistory::get_game_mode_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobby_type",
                    CMsgDOTASDOHeroStatsHistory::get_lobby_type_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_lobby_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTASDOHeroStatsHistory::get_start_time_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "won",
                    CMsgDOTASDOHeroStatsHistory::get_won_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gpm",
                    CMsgDOTASDOHeroStatsHistory::get_gpm_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xpm",
                    CMsgDOTASDOHeroStatsHistory::get_xpm_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_xpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgDOTASDOHeroStatsHistory::get_kills_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgDOTASDOHeroStatsHistory::get_deaths_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgDOTASDOHeroStatsHistory::get_assists_for_reflect,
                    CMsgDOTASDOHeroStatsHistory::mut_assists_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASDOHeroStatsHistory>(
                    "CMsgDOTASDOHeroStatsHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASDOHeroStatsHistory {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_game_mode();
        self.clear_lobby_type();
        self.clear_start_time();
        self.clear_won();
        self.clear_gpm();
        self.clear_xpm();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASDOHeroStatsHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASDOHeroStatsHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonRewards {
    // message fields
    rewards: ::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonRewards {}

impl CMsgDOTASeasonRewards {
    pub fn new() -> CMsgDOTASeasonRewards {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonRewards {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonRewards> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonRewards,
        };
        unsafe {
            instance.get(CMsgDOTASeasonRewards::new)
        }
    }

    // repeated .CMsgDOTASeasonRewards.Reward rewards = 1;

    pub fn clear_rewards(&mut self) {
        self.rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewards(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward>) {
        self.rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewards(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward> {
        &mut self.rewards
    }

    // Take field
    pub fn take_rewards(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward> {
        ::std::mem::replace(&mut self.rewards, ::protobuf::RepeatedField::new())
    }

    pub fn get_rewards(&self) -> &[CMsgDOTASeasonRewards_Reward] {
        &self.rewards
    }

    fn get_rewards_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward> {
        &self.rewards
    }

    fn mut_rewards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonRewards_Reward> {
        &mut self.rewards
    }
}

impl ::protobuf::Message for CMsgDOTASeasonRewards {
    fn is_initialized(&self) -> bool {
        for v in &self.rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rewards {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonRewards {
    fn new() -> CMsgDOTASeasonRewards {
        CMsgDOTASeasonRewards::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonRewards>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonRewards_Reward>>(
                    "rewards",
                    CMsgDOTASeasonRewards::get_rewards_for_reflect,
                    CMsgDOTASeasonRewards::mut_rewards_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonRewards>(
                    "CMsgDOTASeasonRewards",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonRewards {
    fn clear(&mut self) {
        self.clear_rewards();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonRewards {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonRewards {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonRewards_Reward {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    itemdef: ::std::option::Option<u32>,
    importance: ::std::option::Option<u32>,
    base_level: ::std::option::Option<u32>,
    repeat_level: ::std::option::Option<u32>,
    reward_type: ::std::option::Option<CMsgDOTASeasonRewards_ERewardType>,
    image: ::protobuf::SingularField<::std::string::String>,
    action_id: ::std::option::Option<u32>,
    effect_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonRewards_Reward {}

impl CMsgDOTASeasonRewards_Reward {
    pub fn new() -> CMsgDOTASeasonRewards_Reward {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonRewards_Reward {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonRewards_Reward> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonRewards_Reward,
        };
        unsafe {
            instance.get(CMsgDOTASeasonRewards_Reward::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 itemdef = 2;

    pub fn clear_itemdef(&mut self) {
        self.itemdef = ::std::option::Option::None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: u32) {
        self.itemdef = ::std::option::Option::Some(v);
    }

    pub fn get_itemdef(&self) -> u32 {
        self.itemdef.unwrap_or(0)
    }

    fn get_itemdef_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.itemdef
    }

    fn mut_itemdef_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.itemdef
    }

    // optional uint32 importance = 3;

    pub fn clear_importance(&mut self) {
        self.importance = ::std::option::Option::None;
    }

    pub fn has_importance(&self) -> bool {
        self.importance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_importance(&mut self, v: u32) {
        self.importance = ::std::option::Option::Some(v);
    }

    pub fn get_importance(&self) -> u32 {
        self.importance.unwrap_or(0)
    }

    fn get_importance_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.importance
    }

    fn mut_importance_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.importance
    }

    // optional uint32 base_level = 4;

    pub fn clear_base_level(&mut self) {
        self.base_level = ::std::option::Option::None;
    }

    pub fn has_base_level(&self) -> bool {
        self.base_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_level(&mut self, v: u32) {
        self.base_level = ::std::option::Option::Some(v);
    }

    pub fn get_base_level(&self) -> u32 {
        self.base_level.unwrap_or(0)
    }

    fn get_base_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_level
    }

    fn mut_base_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_level
    }

    // optional uint32 repeat_level = 5;

    pub fn clear_repeat_level(&mut self) {
        self.repeat_level = ::std::option::Option::None;
    }

    pub fn has_repeat_level(&self) -> bool {
        self.repeat_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat_level(&mut self, v: u32) {
        self.repeat_level = ::std::option::Option::Some(v);
    }

    pub fn get_repeat_level(&self) -> u32 {
        self.repeat_level.unwrap_or(0)
    }

    fn get_repeat_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.repeat_level
    }

    fn mut_repeat_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.repeat_level
    }

    // optional .CMsgDOTASeasonRewards.ERewardType reward_type = 6;

    pub fn clear_reward_type(&mut self) {
        self.reward_type = ::std::option::Option::None;
    }

    pub fn has_reward_type(&self) -> bool {
        self.reward_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_type(&mut self, v: CMsgDOTASeasonRewards_ERewardType) {
        self.reward_type = ::std::option::Option::Some(v);
    }

    pub fn get_reward_type(&self) -> CMsgDOTASeasonRewards_ERewardType {
        self.reward_type.unwrap_or(CMsgDOTASeasonRewards_ERewardType::EconItem)
    }

    fn get_reward_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonRewards_ERewardType> {
        &self.reward_type
    }

    fn mut_reward_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonRewards_ERewardType> {
        &mut self.reward_type
    }

    // optional string image = 7;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // optional uint32 action_id = 8;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional uint32 effect_index = 9;

    pub fn clear_effect_index(&mut self) {
        self.effect_index = ::std::option::Option::None;
    }

    pub fn has_effect_index(&self) -> bool {
        self.effect_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_index(&mut self, v: u32) {
        self.effect_index = ::std::option::Option::Some(v);
    }

    pub fn get_effect_index(&self) -> u32 {
        self.effect_index.unwrap_or(0)
    }

    fn get_effect_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.effect_index
    }

    fn mut_effect_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.effect_index
    }
}

impl ::protobuf::Message for CMsgDOTASeasonRewards_Reward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.itemdef = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.importance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeat_level = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.reward_type = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.effect_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.itemdef {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.importance {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeat_level {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_type {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.effect_index {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.itemdef {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.importance {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.base_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.repeat_level {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.reward_type {
            os.write_enum(6, v.value())?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.effect_index {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonRewards_Reward {
    fn new() -> CMsgDOTASeasonRewards_Reward {
        CMsgDOTASeasonRewards_Reward::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonRewards_Reward>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTASeasonRewards_Reward::get_name_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "itemdef",
                    CMsgDOTASeasonRewards_Reward::get_itemdef_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_itemdef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "importance",
                    CMsgDOTASeasonRewards_Reward::get_importance_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_importance_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_level",
                    CMsgDOTASeasonRewards_Reward::get_base_level_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_base_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "repeat_level",
                    CMsgDOTASeasonRewards_Reward::get_repeat_level_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_repeat_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonRewards_ERewardType>>(
                    "reward_type",
                    CMsgDOTASeasonRewards_Reward::get_reward_type_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_reward_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    CMsgDOTASeasonRewards_Reward::get_image_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgDOTASeasonRewards_Reward::get_action_id_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "effect_index",
                    CMsgDOTASeasonRewards_Reward::get_effect_index_for_reflect,
                    CMsgDOTASeasonRewards_Reward::mut_effect_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonRewards_Reward>(
                    "CMsgDOTASeasonRewards_Reward",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonRewards_Reward {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_itemdef();
        self.clear_importance();
        self.clear_base_level();
        self.clear_repeat_level();
        self.clear_reward_type();
        self.clear_image();
        self.clear_action_id();
        self.clear_effect_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonRewards_Reward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonRewards_Reward {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonRewards_ERewardType {
    EconItem = 0,
    MysteryWheel = 1,
    AbilityEffect = 2,
    Other = 3,
    MysteryWheelPointsBased = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonRewards_ERewardType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonRewards_ERewardType> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonRewards_ERewardType::EconItem),
            1 => ::std::option::Option::Some(CMsgDOTASeasonRewards_ERewardType::MysteryWheel),
            2 => ::std::option::Option::Some(CMsgDOTASeasonRewards_ERewardType::AbilityEffect),
            3 => ::std::option::Option::Some(CMsgDOTASeasonRewards_ERewardType::Other),
            4 => ::std::option::Option::Some(CMsgDOTASeasonRewards_ERewardType::MysteryWheelPointsBased),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonRewards_ERewardType] = &[
            CMsgDOTASeasonRewards_ERewardType::EconItem,
            CMsgDOTASeasonRewards_ERewardType::MysteryWheel,
            CMsgDOTASeasonRewards_ERewardType::AbilityEffect,
            CMsgDOTASeasonRewards_ERewardType::Other,
            CMsgDOTASeasonRewards_ERewardType::MysteryWheelPointsBased,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonRewards_ERewardType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonRewards_ERewardType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonRewards_ERewardType {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonRewards_ERewardType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonAchievements {
    // message fields
    achievements: ::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonAchievements {}

impl CMsgDOTASeasonAchievements {
    pub fn new() -> CMsgDOTASeasonAchievements {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonAchievements {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonAchievements> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonAchievements,
        };
        unsafe {
            instance.get(CMsgDOTASeasonAchievements::new)
        }
    }

    // repeated .CMsgDOTASeasonAchievements.Achievement achievements = 1;

    pub fn clear_achievements(&mut self) {
        self.achievements.clear();
    }

    // Param is passed by value, moved
    pub fn set_achievements(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement>) {
        self.achievements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_achievements(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement> {
        &mut self.achievements
    }

    // Take field
    pub fn take_achievements(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement> {
        ::std::mem::replace(&mut self.achievements, ::protobuf::RepeatedField::new())
    }

    pub fn get_achievements(&self) -> &[CMsgDOTASeasonAchievements_Achievement] {
        &self.achievements
    }

    fn get_achievements_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement> {
        &self.achievements
    }

    fn mut_achievements_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonAchievements_Achievement> {
        &mut self.achievements
    }
}

impl ::protobuf::Message for CMsgDOTASeasonAchievements {
    fn is_initialized(&self) -> bool {
        for v in &self.achievements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.achievements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.achievements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.achievements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonAchievements {
    fn new() -> CMsgDOTASeasonAchievements {
        CMsgDOTASeasonAchievements::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonAchievements>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonAchievements_Achievement>>(
                    "achievements",
                    CMsgDOTASeasonAchievements::get_achievements_for_reflect,
                    CMsgDOTASeasonAchievements::mut_achievements_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonAchievements>(
                    "CMsgDOTASeasonAchievements",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonAchievements {
    fn clear(&mut self) {
        self.clear_achievements();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonAchievements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonAchievements {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonAchievements_Achievement {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    action_id: ::std::option::Option<u32>,
    max_grants: ::std::option::Option<u32>,
    normal_points: ::std::option::Option<u32>,
    tracking_achievement: ::std::option::Option<u32>,
    achievement_goal: ::std::option::Option<u32>,
    achievement_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonAchievements_Achievement {}

impl CMsgDOTASeasonAchievements_Achievement {
    pub fn new() -> CMsgDOTASeasonAchievements_Achievement {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonAchievements_Achievement {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonAchievements_Achievement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonAchievements_Achievement,
        };
        unsafe {
            instance.get(CMsgDOTASeasonAchievements_Achievement::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string description = 2;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_description_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.description
    }

    fn mut_description_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.description
    }

    // optional string image = 3;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // optional uint32 action_id = 4;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional uint32 max_grants = 5;

    pub fn clear_max_grants(&mut self) {
        self.max_grants = ::std::option::Option::None;
    }

    pub fn has_max_grants(&self) -> bool {
        self.max_grants.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_grants(&mut self, v: u32) {
        self.max_grants = ::std::option::Option::Some(v);
    }

    pub fn get_max_grants(&self) -> u32 {
        self.max_grants.unwrap_or(0)
    }

    fn get_max_grants_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_grants
    }

    fn mut_max_grants_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_grants
    }

    // optional uint32 normal_points = 6;

    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    pub fn get_normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }

    fn get_normal_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.normal_points
    }

    fn mut_normal_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.normal_points
    }

    // optional uint32 tracking_achievement = 7;

    pub fn clear_tracking_achievement(&mut self) {
        self.tracking_achievement = ::std::option::Option::None;
    }

    pub fn has_tracking_achievement(&self) -> bool {
        self.tracking_achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracking_achievement(&mut self, v: u32) {
        self.tracking_achievement = ::std::option::Option::Some(v);
    }

    pub fn get_tracking_achievement(&self) -> u32 {
        self.tracking_achievement.unwrap_or(0)
    }

    fn get_tracking_achievement_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tracking_achievement
    }

    fn mut_tracking_achievement_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tracking_achievement
    }

    // optional uint32 achievement_goal = 8;

    pub fn clear_achievement_goal(&mut self) {
        self.achievement_goal = ::std::option::Option::None;
    }

    pub fn has_achievement_goal(&self) -> bool {
        self.achievement_goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_goal(&mut self, v: u32) {
        self.achievement_goal = ::std::option::Option::Some(v);
    }

    pub fn get_achievement_goal(&self) -> u32 {
        self.achievement_goal.unwrap_or(0)
    }

    fn get_achievement_goal_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.achievement_goal
    }

    fn mut_achievement_goal_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.achievement_goal
    }

    // optional uint32 achievement_level = 9;

    pub fn clear_achievement_level(&mut self) {
        self.achievement_level = ::std::option::Option::None;
    }

    pub fn has_achievement_level(&self) -> bool {
        self.achievement_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_level(&mut self, v: u32) {
        self.achievement_level = ::std::option::Option::Some(v);
    }

    pub fn get_achievement_level(&self) -> u32 {
        self.achievement_level.unwrap_or(0)
    }

    fn get_achievement_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.achievement_level
    }

    fn mut_achievement_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.achievement_level
    }
}

impl ::protobuf::Message for CMsgDOTASeasonAchievements_Achievement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_grants = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.normal_points = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tracking_achievement = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.achievement_goal = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.achievement_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_grants {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tracking_achievement {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.achievement_goal {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.achievement_level {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.max_grants {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tracking_achievement {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.achievement_goal {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.achievement_level {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonAchievements_Achievement {
    fn new() -> CMsgDOTASeasonAchievements_Achievement {
        CMsgDOTASeasonAchievements_Achievement::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonAchievements_Achievement>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTASeasonAchievements_Achievement::get_name_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    CMsgDOTASeasonAchievements_Achievement::get_description_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_description_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    CMsgDOTASeasonAchievements_Achievement::get_image_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgDOTASeasonAchievements_Achievement::get_action_id_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_grants",
                    CMsgDOTASeasonAchievements_Achievement::get_max_grants_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_max_grants_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "normal_points",
                    CMsgDOTASeasonAchievements_Achievement::get_normal_points_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_normal_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tracking_achievement",
                    CMsgDOTASeasonAchievements_Achievement::get_tracking_achievement_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_tracking_achievement_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "achievement_goal",
                    CMsgDOTASeasonAchievements_Achievement::get_achievement_goal_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_achievement_goal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "achievement_level",
                    CMsgDOTASeasonAchievements_Achievement::get_achievement_level_for_reflect,
                    CMsgDOTASeasonAchievements_Achievement::mut_achievement_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonAchievements_Achievement>(
                    "CMsgDOTASeasonAchievements_Achievement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonAchievements_Achievement {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_description();
        self.clear_image();
        self.clear_action_id();
        self.clear_max_grants();
        self.clear_normal_points();
        self.clear_tracking_achievement();
        self.clear_achievement_goal();
        self.clear_achievement_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonAchievements_Achievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonAchievements_Achievement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions {
    // message fields
    predictions: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction>,
    in_game_predictions: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction>,
    in_game_prediction_count_per_game: ::std::option::Option<u32>,
    in_game_prediction_voting_period_minutes: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions {}

impl CMsgDOTASeasonPredictions {
    pub fn new() -> CMsgDOTASeasonPredictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions::new)
        }
    }

    // repeated .CMsgDOTASeasonPredictions.Prediction predictions = 1;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction>) {
        self.predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction> {
        &mut self.predictions
    }

    // Take field
    pub fn take_predictions(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction> {
        ::std::mem::replace(&mut self.predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_predictions(&self) -> &[CMsgDOTASeasonPredictions_Prediction] {
        &self.predictions
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Prediction> {
        &mut self.predictions
    }

    // repeated .CMsgDOTASeasonPredictions.InGamePrediction in_game_predictions = 2;

    pub fn clear_in_game_predictions(&mut self) {
        self.in_game_predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_game_predictions(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction>) {
        self.in_game_predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_game_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction> {
        &mut self.in_game_predictions
    }

    // Take field
    pub fn take_in_game_predictions(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction> {
        ::std::mem::replace(&mut self.in_game_predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_in_game_predictions(&self) -> &[CMsgDOTASeasonPredictions_InGamePrediction] {
        &self.in_game_predictions
    }

    fn get_in_game_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction> {
        &self.in_game_predictions
    }

    fn mut_in_game_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_InGamePrediction> {
        &mut self.in_game_predictions
    }

    // optional uint32 in_game_prediction_count_per_game = 3;

    pub fn clear_in_game_prediction_count_per_game(&mut self) {
        self.in_game_prediction_count_per_game = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_count_per_game(&self) -> bool {
        self.in_game_prediction_count_per_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_count_per_game(&mut self, v: u32) {
        self.in_game_prediction_count_per_game = ::std::option::Option::Some(v);
    }

    pub fn get_in_game_prediction_count_per_game(&self) -> u32 {
        self.in_game_prediction_count_per_game.unwrap_or(0)
    }

    fn get_in_game_prediction_count_per_game_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.in_game_prediction_count_per_game
    }

    fn mut_in_game_prediction_count_per_game_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.in_game_prediction_count_per_game
    }

    // optional uint32 in_game_prediction_voting_period_minutes = 4;

    pub fn clear_in_game_prediction_voting_period_minutes(&mut self) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_voting_period_minutes(&self) -> bool {
        self.in_game_prediction_voting_period_minutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_voting_period_minutes(&mut self, v: u32) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(v);
    }

    pub fn get_in_game_prediction_voting_period_minutes(&self) -> u32 {
        self.in_game_prediction_voting_period_minutes.unwrap_or(0)
    }

    fn get_in_game_prediction_voting_period_minutes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.in_game_prediction_voting_period_minutes
    }

    fn mut_in_game_prediction_voting_period_minutes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.in_game_prediction_voting_period_minutes
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions {
    fn is_initialized(&self) -> bool {
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_game_predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predictions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.in_game_predictions)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_game_prediction_count_per_game = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.in_game_predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.predictions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.in_game_predictions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions {
    fn new() -> CMsgDOTASeasonPredictions {
        CMsgDOTASeasonPredictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_Prediction>>(
                    "predictions",
                    CMsgDOTASeasonPredictions::get_predictions_for_reflect,
                    CMsgDOTASeasonPredictions::mut_predictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_InGamePrediction>>(
                    "in_game_predictions",
                    CMsgDOTASeasonPredictions::get_in_game_predictions_for_reflect,
                    CMsgDOTASeasonPredictions::mut_in_game_predictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "in_game_prediction_count_per_game",
                    CMsgDOTASeasonPredictions::get_in_game_prediction_count_per_game_for_reflect,
                    CMsgDOTASeasonPredictions::mut_in_game_prediction_count_per_game_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "in_game_prediction_voting_period_minutes",
                    CMsgDOTASeasonPredictions::get_in_game_prediction_voting_period_minutes_for_reflect,
                    CMsgDOTASeasonPredictions::mut_in_game_prediction_voting_period_minutes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions>(
                    "CMsgDOTASeasonPredictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions {
    fn clear(&mut self) {
        self.clear_predictions();
        self.clear_in_game_predictions();
        self.clear_in_game_prediction_count_per_game();
        self.clear_in_game_prediction_voting_period_minutes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions_Choice {
    // message fields
    value: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    min_raw_value: ::std::option::Option<u32>,
    max_raw_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions_Choice {}

impl CMsgDOTASeasonPredictions_Choice {
    pub fn new() -> CMsgDOTASeasonPredictions_Choice {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions_Choice {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions_Choice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions_Choice,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions_Choice::new)
        }
    }

    // optional uint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 min_raw_value = 3;

    pub fn clear_min_raw_value(&mut self) {
        self.min_raw_value = ::std::option::Option::None;
    }

    pub fn has_min_raw_value(&self) -> bool {
        self.min_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_raw_value(&mut self, v: u32) {
        self.min_raw_value = ::std::option::Option::Some(v);
    }

    pub fn get_min_raw_value(&self) -> u32 {
        self.min_raw_value.unwrap_or(0)
    }

    fn get_min_raw_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.min_raw_value
    }

    fn mut_min_raw_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.min_raw_value
    }

    // optional uint32 max_raw_value = 4;

    pub fn clear_max_raw_value(&mut self) {
        self.max_raw_value = ::std::option::Option::None;
    }

    pub fn has_max_raw_value(&self) -> bool {
        self.max_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_raw_value(&mut self, v: u32) {
        self.max_raw_value = ::std::option::Option::Some(v);
    }

    pub fn get_max_raw_value(&self) -> u32 {
        self.max_raw_value.unwrap_or(0)
    }

    fn get_max_raw_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_raw_value
    }

    fn mut_max_raw_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_raw_value
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions_Choice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_raw_value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_raw_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.min_raw_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_raw_value {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.min_raw_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_raw_value {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions_Choice {
    fn new() -> CMsgDOTASeasonPredictions_Choice {
        CMsgDOTASeasonPredictions_Choice::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_Choice>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CMsgDOTASeasonPredictions_Choice::get_value_for_reflect,
                    CMsgDOTASeasonPredictions_Choice::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTASeasonPredictions_Choice::get_name_for_reflect,
                    CMsgDOTASeasonPredictions_Choice::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "min_raw_value",
                    CMsgDOTASeasonPredictions_Choice::get_min_raw_value_for_reflect,
                    CMsgDOTASeasonPredictions_Choice::mut_min_raw_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_raw_value",
                    CMsgDOTASeasonPredictions_Choice::get_max_raw_value_for_reflect,
                    CMsgDOTASeasonPredictions_Choice::mut_max_raw_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions_Choice>(
                    "CMsgDOTASeasonPredictions_Choice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions_Choice {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_name();
        self.clear_min_raw_value();
        self.clear_max_raw_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions_Choice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_Choice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions_Answers {
    // message fields
    answer_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions_Answers {}

impl CMsgDOTASeasonPredictions_Answers {
    pub fn new() -> CMsgDOTASeasonPredictions_Answers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions_Answers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions_Answers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions_Answers,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions_Answers::new)
        }
    }

    // optional uint32 answer_id = 1;

    pub fn clear_answer_id(&mut self) {
        self.answer_id = ::std::option::Option::None;
    }

    pub fn has_answer_id(&self) -> bool {
        self.answer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_id(&mut self, v: u32) {
        self.answer_id = ::std::option::Option::Some(v);
    }

    pub fn get_answer_id(&self) -> u32 {
        self.answer_id.unwrap_or(0)
    }

    fn get_answer_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.answer_id
    }

    fn mut_answer_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.answer_id
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions_Answers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.answer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.answer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.answer_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions_Answers {
    fn new() -> CMsgDOTASeasonPredictions_Answers {
        CMsgDOTASeasonPredictions_Answers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_Answers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "answer_id",
                    CMsgDOTASeasonPredictions_Answers::get_answer_id_for_reflect,
                    CMsgDOTASeasonPredictions_Answers::mut_answer_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions_Answers>(
                    "CMsgDOTASeasonPredictions_Answers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions_Answers {
    fn clear(&mut self) {
        self.clear_answer_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions_Answers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_Answers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions_QueryKeyValues {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions_QueryKeyValues {}

impl CMsgDOTASeasonPredictions_QueryKeyValues {
    pub fn new() -> CMsgDOTASeasonPredictions_QueryKeyValues {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions_QueryKeyValues {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions_QueryKeyValues> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions_QueryKeyValues,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions_QueryKeyValues::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions_QueryKeyValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions_QueryKeyValues {
    fn new() -> CMsgDOTASeasonPredictions_QueryKeyValues {
        CMsgDOTASeasonPredictions_QueryKeyValues::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_QueryKeyValues>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTASeasonPredictions_QueryKeyValues::get_name_for_reflect,
                    CMsgDOTASeasonPredictions_QueryKeyValues::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CMsgDOTASeasonPredictions_QueryKeyValues::get_value_for_reflect,
                    CMsgDOTASeasonPredictions_QueryKeyValues::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions_QueryKeyValues>(
                    "CMsgDOTASeasonPredictions_QueryKeyValues",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions_QueryKeyValues {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions_QueryKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_QueryKeyValues {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions_Prediction {
    // message fields
    field_type: ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType>,
    question: ::protobuf::SingularField<::std::string::String>,
    choices: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice>,
    selection_id: ::std::option::Option<u32>,
    start_date: ::std::option::Option<u32>,
    lock_date: ::std::option::Option<u32>,
    reward: ::std::option::Option<u32>,
    answer_type: ::std::option::Option<CMsgDOTASeasonPredictions_eAnswerType>,
    answer_id: ::std::option::Option<u32>,
    answers: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers>,
    query_name: ::protobuf::SingularField<::std::string::String>,
    query_bind_params: ::std::vec::Vec<u32>,
    lock_on_selection_id: ::std::option::Option<u32>,
    lock_on_selection_value: ::std::option::Option<u32>,
    lock_on_selection_set: ::std::option::Option<bool>,
    use_answer_value_ranges: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions_Prediction {}

impl CMsgDOTASeasonPredictions_Prediction {
    pub fn new() -> CMsgDOTASeasonPredictions_Prediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions_Prediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions_Prediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions_Prediction,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions_Prediction::new)
        }
    }

    // optional .CMsgDOTASeasonPredictions.ePredictionType type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CMsgDOTASeasonPredictions_ePredictionType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> CMsgDOTASeasonPredictions_ePredictionType {
        self.field_type.unwrap_or(CMsgDOTASeasonPredictions_ePredictionType::Generic)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType> {
        &mut self.field_type
    }

    // optional string question = 2;

    pub fn clear_question(&mut self) {
        self.question.clear();
    }

    pub fn has_question(&self) -> bool {
        self.question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question(&mut self, v: ::std::string::String) {
        self.question = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question(&mut self) -> &mut ::std::string::String {
        if self.question.is_none() {
            self.question.set_default();
        }
        self.question.as_mut().unwrap()
    }

    // Take field
    pub fn take_question(&mut self) -> ::std::string::String {
        self.question.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_question(&self) -> &str {
        match self.question.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_question_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.question
    }

    fn mut_question_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.question
    }

    // repeated .CMsgDOTASeasonPredictions.Choice choices = 3;

    pub fn clear_choices(&mut self) {
        self.choices.clear();
    }

    // Param is passed by value, moved
    pub fn set_choices(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice>) {
        self.choices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choices(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &mut self.choices
    }

    // Take field
    pub fn take_choices(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        ::std::mem::replace(&mut self.choices, ::protobuf::RepeatedField::new())
    }

    pub fn get_choices(&self) -> &[CMsgDOTASeasonPredictions_Choice] {
        &self.choices
    }

    fn get_choices_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &self.choices
    }

    fn mut_choices_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &mut self.choices
    }

    // optional uint32 selection_id = 4;

    pub fn clear_selection_id(&mut self) {
        self.selection_id = ::std::option::Option::None;
    }

    pub fn has_selection_id(&self) -> bool {
        self.selection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_id(&mut self, v: u32) {
        self.selection_id = ::std::option::Option::Some(v);
    }

    pub fn get_selection_id(&self) -> u32 {
        self.selection_id.unwrap_or(0)
    }

    fn get_selection_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection_id
    }

    fn mut_selection_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection_id
    }

    // optional uint32 start_date = 5;

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: u32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    pub fn get_start_date(&self) -> u32 {
        self.start_date.unwrap_or(0)
    }

    fn get_start_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_date
    }

    fn mut_start_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_date
    }

    // optional uint32 lock_date = 6;

    pub fn clear_lock_date(&mut self) {
        self.lock_date = ::std::option::Option::None;
    }

    pub fn has_lock_date(&self) -> bool {
        self.lock_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_date(&mut self, v: u32) {
        self.lock_date = ::std::option::Option::Some(v);
    }

    pub fn get_lock_date(&self) -> u32 {
        self.lock_date.unwrap_or(0)
    }

    fn get_lock_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lock_date
    }

    fn mut_lock_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lock_date
    }

    // optional uint32 reward = 7;

    pub fn clear_reward(&mut self) {
        self.reward = ::std::option::Option::None;
    }

    pub fn has_reward(&self) -> bool {
        self.reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward(&mut self, v: u32) {
        self.reward = ::std::option::Option::Some(v);
    }

    pub fn get_reward(&self) -> u32 {
        self.reward.unwrap_or(0)
    }

    fn get_reward_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward
    }

    fn mut_reward_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward
    }

    // optional .CMsgDOTASeasonPredictions.eAnswerType answer_type = 8;

    pub fn clear_answer_type(&mut self) {
        self.answer_type = ::std::option::Option::None;
    }

    pub fn has_answer_type(&self) -> bool {
        self.answer_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_type(&mut self, v: CMsgDOTASeasonPredictions_eAnswerType) {
        self.answer_type = ::std::option::Option::Some(v);
    }

    pub fn get_answer_type(&self) -> CMsgDOTASeasonPredictions_eAnswerType {
        self.answer_type.unwrap_or(CMsgDOTASeasonPredictions_eAnswerType::SingleInt)
    }

    fn get_answer_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_eAnswerType> {
        &self.answer_type
    }

    fn mut_answer_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_eAnswerType> {
        &mut self.answer_type
    }

    // optional uint32 answer_id = 9;

    pub fn clear_answer_id(&mut self) {
        self.answer_id = ::std::option::Option::None;
    }

    pub fn has_answer_id(&self) -> bool {
        self.answer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_id(&mut self, v: u32) {
        self.answer_id = ::std::option::Option::Some(v);
    }

    pub fn get_answer_id(&self) -> u32 {
        self.answer_id.unwrap_or(0)
    }

    fn get_answer_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.answer_id
    }

    fn mut_answer_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.answer_id
    }

    // repeated .CMsgDOTASeasonPredictions.Answers answers = 10;

    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }

    pub fn get_answers(&self) -> &[CMsgDOTASeasonPredictions_Answers] {
        &self.answers
    }

    fn get_answers_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers> {
        &self.answers
    }

    fn mut_answers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Answers> {
        &mut self.answers
    }

    // optional string query_name = 11;

    pub fn clear_query_name(&mut self) {
        self.query_name.clear();
    }

    pub fn has_query_name(&self) -> bool {
        self.query_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_name(&mut self, v: ::std::string::String) {
        self.query_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
        if self.query_name.is_none() {
            self.query_name.set_default();
        }
        self.query_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_name(&mut self) -> ::std::string::String {
        self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_query_name(&self) -> &str {
        match self.query_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_query_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.query_name
    }

    fn mut_query_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.query_name
    }

    // repeated uint32 query_bind_params = 12;

    pub fn clear_query_bind_params(&mut self) {
        self.query_bind_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_bind_params(&mut self, v: ::std::vec::Vec<u32>) {
        self.query_bind_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_bind_params(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.query_bind_params
    }

    // Take field
    pub fn take_query_bind_params(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.query_bind_params, ::std::vec::Vec::new())
    }

    pub fn get_query_bind_params(&self) -> &[u32] {
        &self.query_bind_params
    }

    fn get_query_bind_params_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.query_bind_params
    }

    fn mut_query_bind_params_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.query_bind_params
    }

    // optional uint32 lock_on_selection_id = 13;

    pub fn clear_lock_on_selection_id(&mut self) {
        self.lock_on_selection_id = ::std::option::Option::None;
    }

    pub fn has_lock_on_selection_id(&self) -> bool {
        self.lock_on_selection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_on_selection_id(&mut self, v: u32) {
        self.lock_on_selection_id = ::std::option::Option::Some(v);
    }

    pub fn get_lock_on_selection_id(&self) -> u32 {
        self.lock_on_selection_id.unwrap_or(0)
    }

    fn get_lock_on_selection_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lock_on_selection_id
    }

    fn mut_lock_on_selection_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lock_on_selection_id
    }

    // optional uint32 lock_on_selection_value = 14;

    pub fn clear_lock_on_selection_value(&mut self) {
        self.lock_on_selection_value = ::std::option::Option::None;
    }

    pub fn has_lock_on_selection_value(&self) -> bool {
        self.lock_on_selection_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_on_selection_value(&mut self, v: u32) {
        self.lock_on_selection_value = ::std::option::Option::Some(v);
    }

    pub fn get_lock_on_selection_value(&self) -> u32 {
        self.lock_on_selection_value.unwrap_or(0)
    }

    fn get_lock_on_selection_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lock_on_selection_value
    }

    fn mut_lock_on_selection_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lock_on_selection_value
    }

    // optional bool lock_on_selection_set = 15;

    pub fn clear_lock_on_selection_set(&mut self) {
        self.lock_on_selection_set = ::std::option::Option::None;
    }

    pub fn has_lock_on_selection_set(&self) -> bool {
        self.lock_on_selection_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_on_selection_set(&mut self, v: bool) {
        self.lock_on_selection_set = ::std::option::Option::Some(v);
    }

    pub fn get_lock_on_selection_set(&self) -> bool {
        self.lock_on_selection_set.unwrap_or(false)
    }

    fn get_lock_on_selection_set_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.lock_on_selection_set
    }

    fn mut_lock_on_selection_set_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.lock_on_selection_set
    }

    // optional bool use_answer_value_ranges = 16;

    pub fn clear_use_answer_value_ranges(&mut self) {
        self.use_answer_value_ranges = ::std::option::Option::None;
    }

    pub fn has_use_answer_value_ranges(&self) -> bool {
        self.use_answer_value_ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_answer_value_ranges(&mut self, v: bool) {
        self.use_answer_value_ranges = ::std::option::Option::Some(v);
    }

    pub fn get_use_answer_value_ranges(&self) -> bool {
        self.use_answer_value_ranges.unwrap_or(false)
    }

    fn get_use_answer_value_ranges_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.use_answer_value_ranges
    }

    fn mut_use_answer_value_ranges_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.use_answer_value_ranges
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions_Prediction {
    fn is_initialized(&self) -> bool {
        for v in &self.choices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.question)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choices)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_date = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lock_date = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.answer_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.answer_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query_name)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.query_bind_params)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lock_on_selection_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lock_on_selection_value = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lock_on_selection_set = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_answer_value_ranges = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.question.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.selection_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_date {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lock_date {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.answer_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.answer_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.query_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.query_bind_params {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.lock_on_selection_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lock_on_selection_value {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lock_on_selection_set {
            my_size += 2;
        }
        if let Some(v) = self.use_answer_value_ranges {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.question.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.choices {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.selection_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_date {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.lock_date {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.reward {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.answer_type {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.answer_id {
            os.write_uint32(9, v)?;
        }
        for v in &self.answers {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.query_name.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.query_bind_params {
            os.write_uint32(12, *v)?;
        };
        if let Some(v) = self.lock_on_selection_id {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.lock_on_selection_value {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.lock_on_selection_set {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.use_answer_value_ranges {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions_Prediction {
    fn new() -> CMsgDOTASeasonPredictions_Prediction {
        CMsgDOTASeasonPredictions_Prediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_Prediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_ePredictionType>>(
                    "type",
                    CMsgDOTASeasonPredictions_Prediction::get_field_type_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "question",
                    CMsgDOTASeasonPredictions_Prediction::get_question_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_question_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_Choice>>(
                    "choices",
                    CMsgDOTASeasonPredictions_Prediction::get_choices_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_choices_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection_id",
                    CMsgDOTASeasonPredictions_Prediction::get_selection_id_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_selection_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_date",
                    CMsgDOTASeasonPredictions_Prediction::get_start_date_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_start_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lock_date",
                    CMsgDOTASeasonPredictions_Prediction::get_lock_date_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_lock_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward",
                    CMsgDOTASeasonPredictions_Prediction::get_reward_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_reward_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_eAnswerType>>(
                    "answer_type",
                    CMsgDOTASeasonPredictions_Prediction::get_answer_type_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_answer_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "answer_id",
                    CMsgDOTASeasonPredictions_Prediction::get_answer_id_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_answer_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_Answers>>(
                    "answers",
                    CMsgDOTASeasonPredictions_Prediction::get_answers_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_answers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query_name",
                    CMsgDOTASeasonPredictions_Prediction::get_query_name_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_query_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "query_bind_params",
                    CMsgDOTASeasonPredictions_Prediction::get_query_bind_params_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_query_bind_params_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lock_on_selection_id",
                    CMsgDOTASeasonPredictions_Prediction::get_lock_on_selection_id_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_lock_on_selection_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lock_on_selection_value",
                    CMsgDOTASeasonPredictions_Prediction::get_lock_on_selection_value_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_lock_on_selection_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "lock_on_selection_set",
                    CMsgDOTASeasonPredictions_Prediction::get_lock_on_selection_set_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_lock_on_selection_set_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_answer_value_ranges",
                    CMsgDOTASeasonPredictions_Prediction::get_use_answer_value_ranges_for_reflect,
                    CMsgDOTASeasonPredictions_Prediction::mut_use_answer_value_ranges_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions_Prediction>(
                    "CMsgDOTASeasonPredictions_Prediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions_Prediction {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_question();
        self.clear_choices();
        self.clear_selection_id();
        self.clear_start_date();
        self.clear_lock_date();
        self.clear_reward();
        self.clear_answer_type();
        self.clear_answer_id();
        self.clear_answers();
        self.clear_query_name();
        self.clear_query_bind_params();
        self.clear_lock_on_selection_id();
        self.clear_lock_on_selection_value();
        self.clear_lock_on_selection_set();
        self.clear_use_answer_value_ranges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions_Prediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_Prediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASeasonPredictions_InGamePrediction {
    // message fields
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType>,
    group: ::std::option::Option<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t>,
    question: ::protobuf::SingularField<::std::string::String>,
    choices: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice>,
    required_heroes: ::protobuf::RepeatedField<::std::string::String>,
    query_name: ::protobuf::SingularField<::std::string::String>,
    query_values: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues>,
    answer_resolution_type: ::std::option::Option<CMsgDOTASeasonPredictions_eResolutionType_t>,
    points_to_grant: ::std::option::Option<u32>,
    reward_action: ::std::option::Option<u32>,
    debug_force_selection: ::std::option::Option<u32>,
    raw_value_type: ::std::option::Option<CMsgDOTASeasonPredictions_eRawValueType_t>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASeasonPredictions_InGamePrediction {}

impl CMsgDOTASeasonPredictions_InGamePrediction {
    pub fn new() -> CMsgDOTASeasonPredictions_InGamePrediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASeasonPredictions_InGamePrediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASeasonPredictions_InGamePrediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASeasonPredictions_InGamePrediction,
        };
        unsafe {
            instance.get(CMsgDOTASeasonPredictions_InGamePrediction::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .CMsgDOTASeasonPredictions.ePredictionType type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CMsgDOTASeasonPredictions_ePredictionType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> CMsgDOTASeasonPredictions_ePredictionType {
        self.field_type.unwrap_or(CMsgDOTASeasonPredictions_ePredictionType::Generic)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType> {
        &mut self.field_type
    }

    // optional .CMsgDOTASeasonPredictions.eRandomSelectionGroup_t group = 4;

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: CMsgDOTASeasonPredictions_eRandomSelectionGroup_t) {
        self.group = ::std::option::Option::Some(v);
    }

    pub fn get_group(&self) -> CMsgDOTASeasonPredictions_eRandomSelectionGroup_t {
        self.group.unwrap_or(CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::EarlyGame)
    }

    fn get_group_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t> {
        &self.group
    }

    fn mut_group_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t> {
        &mut self.group
    }

    // optional string question = 5;

    pub fn clear_question(&mut self) {
        self.question.clear();
    }

    pub fn has_question(&self) -> bool {
        self.question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question(&mut self, v: ::std::string::String) {
        self.question = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question(&mut self) -> &mut ::std::string::String {
        if self.question.is_none() {
            self.question.set_default();
        }
        self.question.as_mut().unwrap()
    }

    // Take field
    pub fn take_question(&mut self) -> ::std::string::String {
        self.question.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_question(&self) -> &str {
        match self.question.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_question_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.question
    }

    fn mut_question_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.question
    }

    // repeated .CMsgDOTASeasonPredictions.Choice choices = 6;

    pub fn clear_choices(&mut self) {
        self.choices.clear();
    }

    // Param is passed by value, moved
    pub fn set_choices(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice>) {
        self.choices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choices(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &mut self.choices
    }

    // Take field
    pub fn take_choices(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        ::std::mem::replace(&mut self.choices, ::protobuf::RepeatedField::new())
    }

    pub fn get_choices(&self) -> &[CMsgDOTASeasonPredictions_Choice] {
        &self.choices
    }

    fn get_choices_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &self.choices
    }

    fn mut_choices_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_Choice> {
        &mut self.choices
    }

    // repeated string required_heroes = 7;

    pub fn clear_required_heroes(&mut self) {
        self.required_heroes.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_heroes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.required_heroes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_heroes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_heroes
    }

    // Take field
    pub fn take_required_heroes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.required_heroes, ::protobuf::RepeatedField::new())
    }

    pub fn get_required_heroes(&self) -> &[::std::string::String] {
        &self.required_heroes
    }

    fn get_required_heroes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.required_heroes
    }

    fn mut_required_heroes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_heroes
    }

    // optional string query_name = 8;

    pub fn clear_query_name(&mut self) {
        self.query_name.clear();
    }

    pub fn has_query_name(&self) -> bool {
        self.query_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_name(&mut self, v: ::std::string::String) {
        self.query_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
        if self.query_name.is_none() {
            self.query_name.set_default();
        }
        self.query_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_name(&mut self) -> ::std::string::String {
        self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_query_name(&self) -> &str {
        match self.query_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_query_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.query_name
    }

    fn mut_query_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.query_name
    }

    // repeated .CMsgDOTASeasonPredictions.QueryKeyValues query_values = 9;

    pub fn clear_query_values(&mut self) {
        self.query_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_values(&mut self, v: ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues>) {
        self.query_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_values(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues> {
        &mut self.query_values
    }

    // Take field
    pub fn take_query_values(&mut self) -> ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues> {
        ::std::mem::replace(&mut self.query_values, ::protobuf::RepeatedField::new())
    }

    pub fn get_query_values(&self) -> &[CMsgDOTASeasonPredictions_QueryKeyValues] {
        &self.query_values
    }

    fn get_query_values_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues> {
        &self.query_values
    }

    fn mut_query_values_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTASeasonPredictions_QueryKeyValues> {
        &mut self.query_values
    }

    // optional .CMsgDOTASeasonPredictions.eResolutionType_t answer_resolution_type = 10;

    pub fn clear_answer_resolution_type(&mut self) {
        self.answer_resolution_type = ::std::option::Option::None;
    }

    pub fn has_answer_resolution_type(&self) -> bool {
        self.answer_resolution_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_resolution_type(&mut self, v: CMsgDOTASeasonPredictions_eResolutionType_t) {
        self.answer_resolution_type = ::std::option::Option::Some(v);
    }

    pub fn get_answer_resolution_type(&self) -> CMsgDOTASeasonPredictions_eResolutionType_t {
        self.answer_resolution_type.unwrap_or(CMsgDOTASeasonPredictions_eResolutionType_t::InvalidQuery)
    }

    fn get_answer_resolution_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_eResolutionType_t> {
        &self.answer_resolution_type
    }

    fn mut_answer_resolution_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_eResolutionType_t> {
        &mut self.answer_resolution_type
    }

    // optional uint32 points_to_grant = 11;

    pub fn clear_points_to_grant(&mut self) {
        self.points_to_grant = ::std::option::Option::None;
    }

    pub fn has_points_to_grant(&self) -> bool {
        self.points_to_grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_to_grant(&mut self, v: u32) {
        self.points_to_grant = ::std::option::Option::Some(v);
    }

    pub fn get_points_to_grant(&self) -> u32 {
        self.points_to_grant.unwrap_or(0)
    }

    fn get_points_to_grant_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_to_grant
    }

    fn mut_points_to_grant_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_to_grant
    }

    // optional uint32 reward_action = 12;

    pub fn clear_reward_action(&mut self) {
        self.reward_action = ::std::option::Option::None;
    }

    pub fn has_reward_action(&self) -> bool {
        self.reward_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_action(&mut self, v: u32) {
        self.reward_action = ::std::option::Option::Some(v);
    }

    pub fn get_reward_action(&self) -> u32 {
        self.reward_action.unwrap_or(0)
    }

    fn get_reward_action_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_action
    }

    fn mut_reward_action_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_action
    }

    // optional uint32 debug_force_selection = 13;

    pub fn clear_debug_force_selection(&mut self) {
        self.debug_force_selection = ::std::option::Option::None;
    }

    pub fn has_debug_force_selection(&self) -> bool {
        self.debug_force_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_force_selection(&mut self, v: u32) {
        self.debug_force_selection = ::std::option::Option::Some(v);
    }

    pub fn get_debug_force_selection(&self) -> u32 {
        self.debug_force_selection.unwrap_or(0)
    }

    fn get_debug_force_selection_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.debug_force_selection
    }

    fn mut_debug_force_selection_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.debug_force_selection
    }

    // optional .CMsgDOTASeasonPredictions.eRawValueType_t raw_value_type = 14;

    pub fn clear_raw_value_type(&mut self) {
        self.raw_value_type = ::std::option::Option::None;
    }

    pub fn has_raw_value_type(&self) -> bool {
        self.raw_value_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_value_type(&mut self, v: CMsgDOTASeasonPredictions_eRawValueType_t) {
        self.raw_value_type = ::std::option::Option::Some(v);
    }

    pub fn get_raw_value_type(&self) -> CMsgDOTASeasonPredictions_eRawValueType_t {
        self.raw_value_type.unwrap_or(CMsgDOTASeasonPredictions_eRawValueType_t::Number)
    }

    fn get_raw_value_type_for_reflect(&self) -> &::std::option::Option<CMsgDOTASeasonPredictions_eRawValueType_t> {
        &self.raw_value_type
    }

    fn mut_raw_value_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASeasonPredictions_eRawValueType_t> {
        &mut self.raw_value_type
    }
}

impl ::protobuf::Message for CMsgDOTASeasonPredictions_InGamePrediction {
    fn is_initialized(&self) -> bool {
        for v in &self.choices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.group = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.question)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choices)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_heroes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query_name)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query_values)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.answer_resolution_type = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_to_grant = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_action = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.debug_force_selection = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.raw_value_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.group {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.question.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.required_heroes {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.query_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.query_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.answer_resolution_type {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        if let Some(v) = self.points_to_grant {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_action {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.debug_force_selection {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_value_type {
            my_size += ::protobuf::rt::enum_size(14, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.group {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.question.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.choices {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.required_heroes {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.query_name.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.query_values {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.answer_resolution_type {
            os.write_enum(10, v.value())?;
        }
        if let Some(v) = self.points_to_grant {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_action {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.debug_force_selection {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.raw_value_type {
            os.write_enum(14, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASeasonPredictions_InGamePrediction {
    fn new() -> CMsgDOTASeasonPredictions_InGamePrediction {
        CMsgDOTASeasonPredictions_InGamePrediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_InGamePrediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_id_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_name_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_ePredictionType>>(
                    "type",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_field_type_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t>>(
                    "group",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_group_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_group_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "question",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_question_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_question_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_Choice>>(
                    "choices",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_choices_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_choices_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "required_heroes",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_required_heroes_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_required_heroes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query_name",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_query_name_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_query_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTASeasonPredictions_QueryKeyValues>>(
                    "query_values",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_query_values_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_query_values_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_eResolutionType_t>>(
                    "answer_resolution_type",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_answer_resolution_type_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_answer_resolution_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_to_grant",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_points_to_grant_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_points_to_grant_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_action",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_reward_action_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_reward_action_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "debug_force_selection",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_debug_force_selection_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_debug_force_selection_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASeasonPredictions_eRawValueType_t>>(
                    "raw_value_type",
                    CMsgDOTASeasonPredictions_InGamePrediction::get_raw_value_type_for_reflect,
                    CMsgDOTASeasonPredictions_InGamePrediction::mut_raw_value_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASeasonPredictions_InGamePrediction>(
                    "CMsgDOTASeasonPredictions_InGamePrediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASeasonPredictions_InGamePrediction {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.clear_field_type();
        self.clear_group();
        self.clear_question();
        self.clear_choices();
        self.clear_required_heroes();
        self.clear_query_name();
        self.clear_query_values();
        self.clear_answer_resolution_type();
        self.clear_points_to_grant();
        self.clear_reward_action();
        self.clear_debug_force_selection();
        self.clear_raw_value_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASeasonPredictions_InGamePrediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_InGamePrediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonPredictions_ePredictionType {
    Generic = 0,
    Hero = 1,
    Team = 2,
    Player = 3,
    Special = 4,
    YesNo = 5,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonPredictions_ePredictionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::Generic),
            1 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::Hero),
            2 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::Team),
            3 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::Player),
            4 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::Special),
            5 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_ePredictionType::YesNo),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonPredictions_ePredictionType] = &[
            CMsgDOTASeasonPredictions_ePredictionType::Generic,
            CMsgDOTASeasonPredictions_ePredictionType::Hero,
            CMsgDOTASeasonPredictions_ePredictionType::Team,
            CMsgDOTASeasonPredictions_ePredictionType::Player,
            CMsgDOTASeasonPredictions_ePredictionType::Special,
            CMsgDOTASeasonPredictions_ePredictionType::YesNo,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_ePredictionType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonPredictions_ePredictionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonPredictions_ePredictionType {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_ePredictionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonPredictions_eAnswerType {
    SingleInt = 0,
    SingleFloat = 1,
    MultipleInt = 2,
    MultipleFloat = 3,
    AnswerTeam = 4,
    SingleTime = 5,
    MultipleTime = 6,
    NoAnswer = 7,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonPredictions_eAnswerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonPredictions_eAnswerType> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::SingleInt),
            1 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::SingleFloat),
            2 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::MultipleInt),
            3 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::MultipleFloat),
            4 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::AnswerTeam),
            5 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::SingleTime),
            6 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::MultipleTime),
            7 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eAnswerType::NoAnswer),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonPredictions_eAnswerType] = &[
            CMsgDOTASeasonPredictions_eAnswerType::SingleInt,
            CMsgDOTASeasonPredictions_eAnswerType::SingleFloat,
            CMsgDOTASeasonPredictions_eAnswerType::MultipleInt,
            CMsgDOTASeasonPredictions_eAnswerType::MultipleFloat,
            CMsgDOTASeasonPredictions_eAnswerType::AnswerTeam,
            CMsgDOTASeasonPredictions_eAnswerType::SingleTime,
            CMsgDOTASeasonPredictions_eAnswerType::MultipleTime,
            CMsgDOTASeasonPredictions_eAnswerType::NoAnswer,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_eAnswerType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonPredictions_eAnswerType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonPredictions_eAnswerType {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_eAnswerType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonPredictions_eResolutionType_t {
    InvalidQuery = 0,
    FirstToPassQuery = 1,
    LastToPassQuery = 2,
    LastRemainingQuery = 3,
    MaxToPassQuery = 4,
    MinToPassQuery = 5,
    SumQuery = 6,
    MaxTeamSumToPassQuery = 7,
    MinTeamSumToPassQuery = 8,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonPredictions_eResolutionType_t {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonPredictions_eResolutionType_t> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::InvalidQuery),
            1 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::FirstToPassQuery),
            2 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::LastToPassQuery),
            3 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::LastRemainingQuery),
            4 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::MaxToPassQuery),
            5 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::MinToPassQuery),
            6 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::SumQuery),
            7 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::MaxTeamSumToPassQuery),
            8 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eResolutionType_t::MinTeamSumToPassQuery),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonPredictions_eResolutionType_t] = &[
            CMsgDOTASeasonPredictions_eResolutionType_t::InvalidQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::FirstToPassQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::LastToPassQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::LastRemainingQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::MaxToPassQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::MinToPassQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::SumQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::MaxTeamSumToPassQuery,
            CMsgDOTASeasonPredictions_eResolutionType_t::MinTeamSumToPassQuery,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_eResolutionType_t>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonPredictions_eResolutionType_t", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonPredictions_eResolutionType_t {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_eResolutionType_t {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonPredictions_eRandomSelectionGroup_t {
    EarlyGame = 0,
    MidGame = 1,
    LateGame = 2,
    Count = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonPredictions_eRandomSelectionGroup_t {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::EarlyGame),
            1 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::MidGame),
            2 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::LateGame),
            3 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::Count),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonPredictions_eRandomSelectionGroup_t] = &[
            CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::EarlyGame,
            CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::MidGame,
            CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::LateGame,
            CMsgDOTASeasonPredictions_eRandomSelectionGroup_t::Count,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_eRandomSelectionGroup_t>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonPredictions_eRandomSelectionGroup_t", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonPredictions_eRandomSelectionGroup_t {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_eRandomSelectionGroup_t {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASeasonPredictions_eRawValueType_t {
    Number = 0,
    Time = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASeasonPredictions_eRawValueType_t {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASeasonPredictions_eRawValueType_t> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRawValueType_t::Number),
            1 => ::std::option::Option::Some(CMsgDOTASeasonPredictions_eRawValueType_t::Time),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASeasonPredictions_eRawValueType_t] = &[
            CMsgDOTASeasonPredictions_eRawValueType_t::Number,
            CMsgDOTASeasonPredictions_eRawValueType_t::Time,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASeasonPredictions_eRawValueType_t>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASeasonPredictions_eRawValueType_t", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASeasonPredictions_eRawValueType_t {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASeasonPredictions_eRawValueType_t {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch {
    // message fields
    duration: ::std::option::Option<u32>,
    startTime: ::std::option::Option<u32>,
    players: ::protobuf::RepeatedField<CMsgDOTAMatch_Player>,
    match_id: ::std::option::Option<u64>,
    tower_status: ::std::vec::Vec<u32>,
    barracks_status: ::std::vec::Vec<u32>,
    cluster: ::std::option::Option<u32>,
    first_blood_time: ::std::option::Option<u32>,
    replay_salt: ::std::option::Option<u32>,
    server_ip: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    lobby_type: ::std::option::Option<u32>,
    human_players: ::std::option::Option<u32>,
    average_skill: ::std::option::Option<u32>,
    game_balance: ::std::option::Option<f32>,
    radiant_team_id: ::std::option::Option<u32>,
    dire_team_id: ::std::option::Option<u32>,
    leagueid: ::std::option::Option<u32>,
    radiant_team_name: ::protobuf::SingularField<::std::string::String>,
    dire_team_name: ::protobuf::SingularField<::std::string::String>,
    radiant_team_logo: ::std::option::Option<u64>,
    dire_team_logo: ::std::option::Option<u64>,
    radiant_team_complete: ::std::option::Option<u32>,
    dire_team_complete: ::std::option::Option<u32>,
    positive_votes: ::std::option::Option<u32>,
    negative_votes: ::std::option::Option<u32>,
    game_mode: ::std::option::Option<super::dota_shared_enums::DOTA_GameMode>,
    picks_bans: ::protobuf::RepeatedField<CMatchHeroSelectEvent>,
    match_seq_num: ::std::option::Option<u64>,
    replay_state: ::std::option::Option<CMsgDOTAMatch_ReplayState>,
    radiant_guild_id: ::std::option::Option<u32>,
    dire_guild_id: ::std::option::Option<u32>,
    radiant_team_tag: ::protobuf::SingularField<::std::string::String>,
    dire_team_tag: ::protobuf::SingularField<::std::string::String>,
    series_id: ::std::option::Option<u32>,
    series_type: ::std::option::Option<u32>,
    broadcaster_channels: ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel>,
    engine: ::std::option::Option<u32>,
    custom_game_data: ::protobuf::SingularPtrField<CMsgDOTAMatch_CustomGameData>,
    match_flags: ::std::option::Option<u32>,
    private_metadata_key: ::std::option::Option<u32>,
    radiant_team_score: ::std::option::Option<u32>,
    dire_team_score: ::std::option::Option<u32>,
    match_outcome: ::std::option::Option<super::dota_shared_enums::EMatchOutcome>,
    tournament_id: ::std::option::Option<u32>,
    tournament_round: ::std::option::Option<u32>,
    pre_game_duration: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch {}

impl CMsgDOTAMatch {
    pub fn new() -> CMsgDOTAMatch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch,
        };
        unsafe {
            instance.get(CMsgDOTAMatch::new)
        }
    }

    // optional uint32 duration = 3;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.duration
    }

    // optional fixed32 startTime = 4;

    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u32) {
        self.startTime = ::std::option::Option::Some(v);
    }

    pub fn get_startTime(&self) -> u32 {
        self.startTime.unwrap_or(0)
    }

    fn get_startTime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.startTime
    }

    fn mut_startTime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.startTime
    }

    // repeated .CMsgDOTAMatch.Player players = 5;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAMatch_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAMatch_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgDOTAMatch_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAMatch_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_Player> {
        &mut self.players
    }

    // optional uint64 match_id = 6;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // repeated uint32 tower_status = 8;

    pub fn clear_tower_status(&mut self) {
        self.tower_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_tower_status(&mut self, v: ::std::vec::Vec<u32>) {
        self.tower_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tower_status(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tower_status
    }

    // Take field
    pub fn take_tower_status(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tower_status, ::std::vec::Vec::new())
    }

    pub fn get_tower_status(&self) -> &[u32] {
        &self.tower_status
    }

    fn get_tower_status_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.tower_status
    }

    fn mut_tower_status_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tower_status
    }

    // repeated uint32 barracks_status = 9;

    pub fn clear_barracks_status(&mut self) {
        self.barracks_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_barracks_status(&mut self, v: ::std::vec::Vec<u32>) {
        self.barracks_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_barracks_status(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.barracks_status
    }

    // Take field
    pub fn take_barracks_status(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.barracks_status, ::std::vec::Vec::new())
    }

    pub fn get_barracks_status(&self) -> &[u32] {
        &self.barracks_status
    }

    fn get_barracks_status_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.barracks_status
    }

    fn mut_barracks_status_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.barracks_status
    }

    // optional uint32 cluster = 10;

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    pub fn get_cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    fn get_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cluster
    }

    fn mut_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cluster
    }

    // optional uint32 first_blood_time = 12;

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    fn get_first_blood_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_time
    }

    fn mut_first_blood_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_time
    }

    // optional fixed32 replay_salt = 13;

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    pub fn get_replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    fn get_replay_salt_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replay_salt
    }

    fn mut_replay_salt_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replay_salt
    }

    // optional fixed32 server_ip = 14;

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    fn get_server_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_ip
    }

    fn mut_server_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_ip
    }

    // optional uint32 server_port = 15;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    fn get_server_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_port
    }

    fn mut_server_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_port
    }

    // optional uint32 lobby_type = 16;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    fn get_lobby_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lobby_type
    }

    fn mut_lobby_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lobby_type
    }

    // optional uint32 human_players = 17;

    pub fn clear_human_players(&mut self) {
        self.human_players = ::std::option::Option::None;
    }

    pub fn has_human_players(&self) -> bool {
        self.human_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_human_players(&mut self, v: u32) {
        self.human_players = ::std::option::Option::Some(v);
    }

    pub fn get_human_players(&self) -> u32 {
        self.human_players.unwrap_or(0)
    }

    fn get_human_players_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.human_players
    }

    fn mut_human_players_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.human_players
    }

    // optional uint32 average_skill = 18;

    pub fn clear_average_skill(&mut self) {
        self.average_skill = ::std::option::Option::None;
    }

    pub fn has_average_skill(&self) -> bool {
        self.average_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_skill(&mut self, v: u32) {
        self.average_skill = ::std::option::Option::Some(v);
    }

    pub fn get_average_skill(&self) -> u32 {
        self.average_skill.unwrap_or(0)
    }

    fn get_average_skill_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.average_skill
    }

    fn mut_average_skill_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.average_skill
    }

    // optional float game_balance = 19;

    pub fn clear_game_balance(&mut self) {
        self.game_balance = ::std::option::Option::None;
    }

    pub fn has_game_balance(&self) -> bool {
        self.game_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_balance(&mut self, v: f32) {
        self.game_balance = ::std::option::Option::Some(v);
    }

    pub fn get_game_balance(&self) -> f32 {
        self.game_balance.unwrap_or(0.)
    }

    fn get_game_balance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.game_balance
    }

    fn mut_game_balance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.game_balance
    }

    // optional uint32 radiant_team_id = 20;

    pub fn clear_radiant_team_id(&mut self) {
        self.radiant_team_id = ::std::option::Option::None;
    }

    pub fn has_radiant_team_id(&self) -> bool {
        self.radiant_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_id(&mut self, v: u32) {
        self.radiant_team_id = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_team_id(&self) -> u32 {
        self.radiant_team_id.unwrap_or(0)
    }

    fn get_radiant_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_team_id
    }

    fn mut_radiant_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_team_id
    }

    // optional uint32 dire_team_id = 21;

    pub fn clear_dire_team_id(&mut self) {
        self.dire_team_id = ::std::option::Option::None;
    }

    pub fn has_dire_team_id(&self) -> bool {
        self.dire_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_id(&mut self, v: u32) {
        self.dire_team_id = ::std::option::Option::Some(v);
    }

    pub fn get_dire_team_id(&self) -> u32 {
        self.dire_team_id.unwrap_or(0)
    }

    fn get_dire_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_team_id
    }

    fn mut_dire_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_team_id
    }

    // optional uint32 leagueid = 22;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }

    // optional string radiant_team_name = 23;

    pub fn clear_radiant_team_name(&mut self) {
        self.radiant_team_name.clear();
    }

    pub fn has_radiant_team_name(&self) -> bool {
        self.radiant_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_name(&mut self, v: ::std::string::String) {
        self.radiant_team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_name(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_name.is_none() {
            self.radiant_team_name.set_default();
        }
        self.radiant_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_name(&mut self) -> ::std::string::String {
        self.radiant_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_radiant_team_name(&self) -> &str {
        match self.radiant_team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_radiant_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.radiant_team_name
    }

    fn mut_radiant_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.radiant_team_name
    }

    // optional string dire_team_name = 24;

    pub fn clear_dire_team_name(&mut self) {
        self.dire_team_name.clear();
    }

    pub fn has_dire_team_name(&self) -> bool {
        self.dire_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_name(&mut self, v: ::std::string::String) {
        self.dire_team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_name(&mut self) -> &mut ::std::string::String {
        if self.dire_team_name.is_none() {
            self.dire_team_name.set_default();
        }
        self.dire_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_name(&mut self) -> ::std::string::String {
        self.dire_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dire_team_name(&self) -> &str {
        match self.dire_team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dire_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dire_team_name
    }

    fn mut_dire_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dire_team_name
    }

    // optional uint64 radiant_team_logo = 25;

    pub fn clear_radiant_team_logo(&mut self) {
        self.radiant_team_logo = ::std::option::Option::None;
    }

    pub fn has_radiant_team_logo(&self) -> bool {
        self.radiant_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_logo(&mut self, v: u64) {
        self.radiant_team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_team_logo(&self) -> u64 {
        self.radiant_team_logo.unwrap_or(0)
    }

    fn get_radiant_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.radiant_team_logo
    }

    fn mut_radiant_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.radiant_team_logo
    }

    // optional uint64 dire_team_logo = 26;

    pub fn clear_dire_team_logo(&mut self) {
        self.dire_team_logo = ::std::option::Option::None;
    }

    pub fn has_dire_team_logo(&self) -> bool {
        self.dire_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_logo(&mut self, v: u64) {
        self.dire_team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_dire_team_logo(&self) -> u64 {
        self.dire_team_logo.unwrap_or(0)
    }

    fn get_dire_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dire_team_logo
    }

    fn mut_dire_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dire_team_logo
    }

    // optional uint32 radiant_team_complete = 27;

    pub fn clear_radiant_team_complete(&mut self) {
        self.radiant_team_complete = ::std::option::Option::None;
    }

    pub fn has_radiant_team_complete(&self) -> bool {
        self.radiant_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_complete(&mut self, v: u32) {
        self.radiant_team_complete = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_team_complete(&self) -> u32 {
        self.radiant_team_complete.unwrap_or(0)
    }

    fn get_radiant_team_complete_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_team_complete
    }

    fn mut_radiant_team_complete_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_team_complete
    }

    // optional uint32 dire_team_complete = 28;

    pub fn clear_dire_team_complete(&mut self) {
        self.dire_team_complete = ::std::option::Option::None;
    }

    pub fn has_dire_team_complete(&self) -> bool {
        self.dire_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_complete(&mut self, v: u32) {
        self.dire_team_complete = ::std::option::Option::Some(v);
    }

    pub fn get_dire_team_complete(&self) -> u32 {
        self.dire_team_complete.unwrap_or(0)
    }

    fn get_dire_team_complete_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_team_complete
    }

    fn mut_dire_team_complete_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_team_complete
    }

    // optional uint32 positive_votes = 29;

    pub fn clear_positive_votes(&mut self) {
        self.positive_votes = ::std::option::Option::None;
    }

    pub fn has_positive_votes(&self) -> bool {
        self.positive_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_votes(&mut self, v: u32) {
        self.positive_votes = ::std::option::Option::Some(v);
    }

    pub fn get_positive_votes(&self) -> u32 {
        self.positive_votes.unwrap_or(0)
    }

    fn get_positive_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.positive_votes
    }

    fn mut_positive_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.positive_votes
    }

    // optional uint32 negative_votes = 30;

    pub fn clear_negative_votes(&mut self) {
        self.negative_votes = ::std::option::Option::None;
    }

    pub fn has_negative_votes(&self) -> bool {
        self.negative_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_votes(&mut self, v: u32) {
        self.negative_votes = ::std::option::Option::Some(v);
    }

    pub fn get_negative_votes(&self) -> u32 {
        self.negative_votes.unwrap_or(0)
    }

    fn get_negative_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.negative_votes
    }

    fn mut_negative_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.negative_votes
    }

    // optional .DOTA_GameMode game_mode = 31;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        self.game_mode.unwrap_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTA_GameMode> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTA_GameMode> {
        &mut self.game_mode
    }

    // repeated .CMatchHeroSelectEvent picks_bans = 32;

    pub fn clear_picks_bans(&mut self) {
        self.picks_bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks_bans(&mut self, v: ::protobuf::RepeatedField<CMatchHeroSelectEvent>) {
        self.picks_bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks_bans(&mut self) -> &mut ::protobuf::RepeatedField<CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }

    // Take field
    pub fn take_picks_bans(&mut self) -> ::protobuf::RepeatedField<CMatchHeroSelectEvent> {
        ::std::mem::replace(&mut self.picks_bans, ::protobuf::RepeatedField::new())
    }

    pub fn get_picks_bans(&self) -> &[CMatchHeroSelectEvent] {
        &self.picks_bans
    }

    fn get_picks_bans_for_reflect(&self) -> &::protobuf::RepeatedField<CMatchHeroSelectEvent> {
        &self.picks_bans
    }

    fn mut_picks_bans_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }

    // optional uint64 match_seq_num = 33;

    pub fn clear_match_seq_num(&mut self) {
        self.match_seq_num = ::std::option::Option::None;
    }

    pub fn has_match_seq_num(&self) -> bool {
        self.match_seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_seq_num(&mut self, v: u64) {
        self.match_seq_num = ::std::option::Option::Some(v);
    }

    pub fn get_match_seq_num(&self) -> u64 {
        self.match_seq_num.unwrap_or(0)
    }

    fn get_match_seq_num_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_seq_num
    }

    fn mut_match_seq_num_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_seq_num
    }

    // optional .CMsgDOTAMatch.ReplayState replay_state = 34;

    pub fn clear_replay_state(&mut self) {
        self.replay_state = ::std::option::Option::None;
    }

    pub fn has_replay_state(&self) -> bool {
        self.replay_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_state(&mut self, v: CMsgDOTAMatch_ReplayState) {
        self.replay_state = ::std::option::Option::Some(v);
    }

    pub fn get_replay_state(&self) -> CMsgDOTAMatch_ReplayState {
        self.replay_state.unwrap_or(CMsgDOTAMatch_ReplayState::REPLAY_AVAILABLE)
    }

    fn get_replay_state_for_reflect(&self) -> &::std::option::Option<CMsgDOTAMatch_ReplayState> {
        &self.replay_state
    }

    fn mut_replay_state_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAMatch_ReplayState> {
        &mut self.replay_state
    }

    // optional uint32 radiant_guild_id = 35;

    pub fn clear_radiant_guild_id(&mut self) {
        self.radiant_guild_id = ::std::option::Option::None;
    }

    pub fn has_radiant_guild_id(&self) -> bool {
        self.radiant_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_guild_id(&mut self, v: u32) {
        self.radiant_guild_id = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_guild_id(&self) -> u32 {
        self.radiant_guild_id.unwrap_or(0)
    }

    fn get_radiant_guild_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_guild_id
    }

    fn mut_radiant_guild_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_guild_id
    }

    // optional uint32 dire_guild_id = 36;

    pub fn clear_dire_guild_id(&mut self) {
        self.dire_guild_id = ::std::option::Option::None;
    }

    pub fn has_dire_guild_id(&self) -> bool {
        self.dire_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_guild_id(&mut self, v: u32) {
        self.dire_guild_id = ::std::option::Option::Some(v);
    }

    pub fn get_dire_guild_id(&self) -> u32 {
        self.dire_guild_id.unwrap_or(0)
    }

    fn get_dire_guild_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_guild_id
    }

    fn mut_dire_guild_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_guild_id
    }

    // optional string radiant_team_tag = 37;

    pub fn clear_radiant_team_tag(&mut self) {
        self.radiant_team_tag.clear();
    }

    pub fn has_radiant_team_tag(&self) -> bool {
        self.radiant_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_tag(&mut self, v: ::std::string::String) {
        self.radiant_team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_tag(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_tag.is_none() {
            self.radiant_team_tag.set_default();
        }
        self.radiant_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_tag(&mut self) -> ::std::string::String {
        self.radiant_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_radiant_team_tag(&self) -> &str {
        match self.radiant_team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_radiant_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.radiant_team_tag
    }

    fn mut_radiant_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.radiant_team_tag
    }

    // optional string dire_team_tag = 38;

    pub fn clear_dire_team_tag(&mut self) {
        self.dire_team_tag.clear();
    }

    pub fn has_dire_team_tag(&self) -> bool {
        self.dire_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_tag(&mut self, v: ::std::string::String) {
        self.dire_team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_tag(&mut self) -> &mut ::std::string::String {
        if self.dire_team_tag.is_none() {
            self.dire_team_tag.set_default();
        }
        self.dire_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_tag(&mut self) -> ::std::string::String {
        self.dire_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dire_team_tag(&self) -> &str {
        match self.dire_team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dire_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dire_team_tag
    }

    fn mut_dire_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dire_team_tag
    }

    // optional uint32 series_id = 39;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 series_type = 40;

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    pub fn get_series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    fn get_series_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_type
    }

    fn mut_series_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_type
    }

    // repeated .CMsgDOTAMatch.BroadcasterChannel broadcaster_channels = 43;

    pub fn clear_broadcaster_channels(&mut self) {
        self.broadcaster_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_channels(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel>) {
        self.broadcaster_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcaster_channels(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel> {
        &mut self.broadcaster_channels
    }

    // Take field
    pub fn take_broadcaster_channels(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel> {
        ::std::mem::replace(&mut self.broadcaster_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_broadcaster_channels(&self) -> &[CMsgDOTAMatch_BroadcasterChannel] {
        &self.broadcaster_channels
    }

    fn get_broadcaster_channels_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel> {
        &self.broadcaster_channels
    }

    fn mut_broadcaster_channels_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterChannel> {
        &mut self.broadcaster_channels
    }

    // optional uint32 engine = 44;

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    pub fn get_engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    fn get_engine_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.engine
    }

    fn mut_engine_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.engine
    }

    // optional .CMsgDOTAMatch.CustomGameData custom_game_data = 45;

    pub fn clear_custom_game_data(&mut self) {
        self.custom_game_data.clear();
    }

    pub fn has_custom_game_data(&self) -> bool {
        self.custom_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_data(&mut self, v: CMsgDOTAMatch_CustomGameData) {
        self.custom_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_data(&mut self) -> &mut CMsgDOTAMatch_CustomGameData {
        if self.custom_game_data.is_none() {
            self.custom_game_data.set_default();
        }
        self.custom_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_data(&mut self) -> CMsgDOTAMatch_CustomGameData {
        self.custom_game_data.take().unwrap_or_else(|| CMsgDOTAMatch_CustomGameData::new())
    }

    pub fn get_custom_game_data(&self) -> &CMsgDOTAMatch_CustomGameData {
        self.custom_game_data.as_ref().unwrap_or_else(|| CMsgDOTAMatch_CustomGameData::default_instance())
    }

    fn get_custom_game_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAMatch_CustomGameData> {
        &self.custom_game_data
    }

    fn mut_custom_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAMatch_CustomGameData> {
        &mut self.custom_game_data
    }

    // optional uint32 match_flags = 46;

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    pub fn get_match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    fn get_match_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_flags
    }

    fn mut_match_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_flags
    }

    // optional fixed32 private_metadata_key = 47;

    pub fn clear_private_metadata_key(&mut self) {
        self.private_metadata_key = ::std::option::Option::None;
    }

    pub fn has_private_metadata_key(&self) -> bool {
        self.private_metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_metadata_key(&mut self, v: u32) {
        self.private_metadata_key = ::std::option::Option::Some(v);
    }

    pub fn get_private_metadata_key(&self) -> u32 {
        self.private_metadata_key.unwrap_or(0)
    }

    fn get_private_metadata_key_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.private_metadata_key
    }

    fn mut_private_metadata_key_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.private_metadata_key
    }

    // optional uint32 radiant_team_score = 48;

    pub fn clear_radiant_team_score(&mut self) {
        self.radiant_team_score = ::std::option::Option::None;
    }

    pub fn has_radiant_team_score(&self) -> bool {
        self.radiant_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_score(&mut self, v: u32) {
        self.radiant_team_score = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_team_score(&self) -> u32 {
        self.radiant_team_score.unwrap_or(0)
    }

    fn get_radiant_team_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_team_score
    }

    fn mut_radiant_team_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_team_score
    }

    // optional uint32 dire_team_score = 49;

    pub fn clear_dire_team_score(&mut self) {
        self.dire_team_score = ::std::option::Option::None;
    }

    pub fn has_dire_team_score(&self) -> bool {
        self.dire_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_score(&mut self, v: u32) {
        self.dire_team_score = ::std::option::Option::Some(v);
    }

    pub fn get_dire_team_score(&self) -> u32 {
        self.dire_team_score.unwrap_or(0)
    }

    fn get_dire_team_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_team_score
    }

    fn mut_dire_team_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_team_score
    }

    // optional .EMatchOutcome match_outcome = 50;

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(v);
    }

    pub fn get_match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        self.match_outcome.unwrap_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown)
    }

    fn get_match_outcome_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EMatchOutcome> {
        &self.match_outcome
    }

    fn mut_match_outcome_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EMatchOutcome> {
        &mut self.match_outcome
    }

    // optional uint32 tournament_id = 51;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    fn get_tournament_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_id
    }

    fn mut_tournament_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_id
    }

    // optional uint32 tournament_round = 52;

    pub fn clear_tournament_round(&mut self) {
        self.tournament_round = ::std::option::Option::None;
    }

    pub fn has_tournament_round(&self) -> bool {
        self.tournament_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_round(&mut self, v: u32) {
        self.tournament_round = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_round(&self) -> u32 {
        self.tournament_round.unwrap_or(0)
    }

    fn get_tournament_round_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_round
    }

    fn mut_tournament_round_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_round
    }

    // optional uint32 pre_game_duration = 53;

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }

    pub fn get_pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    fn get_pre_game_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pre_game_duration
    }

    fn mut_pre_game_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pre_game_duration
    }
}

impl ::protobuf::Message for CMsgDOTAMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.picks_bans {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.broadcaster_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tower_status)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.barracks_status)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.replay_salt = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.human_players = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.average_skill = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.game_balance = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_team_id = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_team_id = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.radiant_team_name)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dire_team_name)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.radiant_team_logo = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dire_team_logo = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_team_complete = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_team_complete = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.positive_votes = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.negative_votes = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                32 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks_bans)?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_seq_num = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.replay_state = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_guild_id = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_guild_id = ::std::option::Option::Some(tmp);
                },
                37 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.radiant_team_tag)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dire_team_tag)?;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_type = ::std::option::Option::Some(tmp);
                },
                43 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.broadcaster_channels)?;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.engine = ::std::option::Option::Some(tmp);
                },
                45 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.custom_game_data)?;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_flags = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.private_metadata_key = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_team_score = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_team_score = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.match_outcome = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_id = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_round = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pre_game_duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startTime {
            my_size += 5;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tower_status {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.barracks_status {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_salt {
            my_size += 5;
        }
        if let Some(v) = self.server_ip {
            my_size += 5;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.human_players {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average_skill {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_balance {
            my_size += 6;
        }
        if let Some(v) = self.radiant_team_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_team_id {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.radiant_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(ref v) = self.dire_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.radiant_team_logo {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_team_logo {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radiant_team_complete {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_team_complete {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.positive_votes {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.negative_votes {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::enum_size(31, v);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_seq_num {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_state {
            my_size += ::protobuf::rt::enum_size(34, v);
        }
        if let Some(v) = self.radiant_guild_id {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_guild_id {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.radiant_team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(ref v) = self.dire_team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.broadcaster_channels {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.private_metadata_key {
            my_size += 6;
        }
        if let Some(v) = self.radiant_team_score {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_team_score {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::enum_size(50, v);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_round {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pre_game_duration {
            my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.startTime {
            os.write_fixed32(4, v)?;
        }
        for v in &self.players {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(6, v)?;
        }
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_fixed32(14, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.human_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.average_skill {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.game_balance {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.radiant_team_id {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dire_team_id {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(22, v)?;
        }
        if let Some(ref v) = self.radiant_team_name.as_ref() {
            os.write_string(23, &v)?;
        }
        if let Some(ref v) = self.dire_team_name.as_ref() {
            os.write_string(24, &v)?;
        }
        if let Some(v) = self.radiant_team_logo {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.dire_team_logo {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.radiant_team_complete {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.dire_team_complete {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.positive_votes {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.negative_votes {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(31, v.value())?;
        }
        for v in &self.picks_bans {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_seq_num {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.replay_state {
            os.write_enum(34, v.value())?;
        }
        if let Some(v) = self.radiant_guild_id {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.dire_guild_id {
            os.write_uint32(36, v)?;
        }
        if let Some(ref v) = self.radiant_team_tag.as_ref() {
            os.write_string(37, &v)?;
        }
        if let Some(ref v) = self.dire_team_tag.as_ref() {
            os.write_string(38, &v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(40, v)?;
        }
        for v in &self.broadcaster_channels {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.engine {
            os.write_uint32(44, v)?;
        }
        if let Some(ref v) = self.custom_game_data.as_ref() {
            os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.private_metadata_key {
            os.write_fixed32(47, v)?;
        }
        if let Some(v) = self.radiant_team_score {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.dire_team_score {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(50, v.value())?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.tournament_round {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(53, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch {
    fn new() -> CMsgDOTAMatch {
        CMsgDOTAMatch::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration",
                    CMsgDOTAMatch::get_duration_for_reflect,
                    CMsgDOTAMatch::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "startTime",
                    CMsgDOTAMatch::get_startTime_for_reflect,
                    CMsgDOTAMatch::mut_startTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatch_Player>>(
                    "players",
                    CMsgDOTAMatch::get_players_for_reflect,
                    CMsgDOTAMatch::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAMatch::get_match_id_for_reflect,
                    CMsgDOTAMatch::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_status",
                    CMsgDOTAMatch::get_tower_status_for_reflect,
                    CMsgDOTAMatch::mut_tower_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "barracks_status",
                    CMsgDOTAMatch::get_barracks_status_for_reflect,
                    CMsgDOTAMatch::mut_barracks_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cluster",
                    CMsgDOTAMatch::get_cluster_for_reflect,
                    CMsgDOTAMatch::mut_cluster_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_time",
                    CMsgDOTAMatch::get_first_blood_time_for_reflect,
                    CMsgDOTAMatch::mut_first_blood_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "replay_salt",
                    CMsgDOTAMatch::get_replay_salt_for_reflect,
                    CMsgDOTAMatch::mut_replay_salt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "server_ip",
                    CMsgDOTAMatch::get_server_ip_for_reflect,
                    CMsgDOTAMatch::mut_server_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    CMsgDOTAMatch::get_server_port_for_reflect,
                    CMsgDOTAMatch::mut_server_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobby_type",
                    CMsgDOTAMatch::get_lobby_type_for_reflect,
                    CMsgDOTAMatch::mut_lobby_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "human_players",
                    CMsgDOTAMatch::get_human_players_for_reflect,
                    CMsgDOTAMatch::mut_human_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "average_skill",
                    CMsgDOTAMatch::get_average_skill_for_reflect,
                    CMsgDOTAMatch::mut_average_skill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "game_balance",
                    CMsgDOTAMatch::get_game_balance_for_reflect,
                    CMsgDOTAMatch::mut_game_balance_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_team_id",
                    CMsgDOTAMatch::get_radiant_team_id_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_team_id",
                    CMsgDOTAMatch::get_dire_team_id_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgDOTAMatch::get_leagueid_for_reflect,
                    CMsgDOTAMatch::mut_leagueid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "radiant_team_name",
                    CMsgDOTAMatch::get_radiant_team_name_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dire_team_name",
                    CMsgDOTAMatch::get_dire_team_name_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "radiant_team_logo",
                    CMsgDOTAMatch::get_radiant_team_logo_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dire_team_logo",
                    CMsgDOTAMatch::get_dire_team_logo_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_team_complete",
                    CMsgDOTAMatch::get_radiant_team_complete_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_complete_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_team_complete",
                    CMsgDOTAMatch::get_dire_team_complete_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_complete_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "positive_votes",
                    CMsgDOTAMatch::get_positive_votes_for_reflect,
                    CMsgDOTAMatch::mut_positive_votes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "negative_votes",
                    CMsgDOTAMatch::get_negative_votes_for_reflect,
                    CMsgDOTAMatch::mut_negative_votes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTA_GameMode>>(
                    "game_mode",
                    CMsgDOTAMatch::get_game_mode_for_reflect,
                    CMsgDOTAMatch::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMatchHeroSelectEvent>>(
                    "picks_bans",
                    CMsgDOTAMatch::get_picks_bans_for_reflect,
                    CMsgDOTAMatch::mut_picks_bans_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_seq_num",
                    CMsgDOTAMatch::get_match_seq_num_for_reflect,
                    CMsgDOTAMatch::mut_match_seq_num_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAMatch_ReplayState>>(
                    "replay_state",
                    CMsgDOTAMatch::get_replay_state_for_reflect,
                    CMsgDOTAMatch::mut_replay_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_guild_id",
                    CMsgDOTAMatch::get_radiant_guild_id_for_reflect,
                    CMsgDOTAMatch::mut_radiant_guild_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_guild_id",
                    CMsgDOTAMatch::get_dire_guild_id_for_reflect,
                    CMsgDOTAMatch::mut_dire_guild_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "radiant_team_tag",
                    CMsgDOTAMatch::get_radiant_team_tag_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dire_team_tag",
                    CMsgDOTAMatch::get_dire_team_tag_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgDOTAMatch::get_series_id_for_reflect,
                    CMsgDOTAMatch::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_type",
                    CMsgDOTAMatch::get_series_type_for_reflect,
                    CMsgDOTAMatch::mut_series_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatch_BroadcasterChannel>>(
                    "broadcaster_channels",
                    CMsgDOTAMatch::get_broadcaster_channels_for_reflect,
                    CMsgDOTAMatch::mut_broadcaster_channels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "engine",
                    CMsgDOTAMatch::get_engine_for_reflect,
                    CMsgDOTAMatch::mut_engine_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatch_CustomGameData>>(
                    "custom_game_data",
                    CMsgDOTAMatch::get_custom_game_data_for_reflect,
                    CMsgDOTAMatch::mut_custom_game_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_flags",
                    CMsgDOTAMatch::get_match_flags_for_reflect,
                    CMsgDOTAMatch::mut_match_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "private_metadata_key",
                    CMsgDOTAMatch::get_private_metadata_key_for_reflect,
                    CMsgDOTAMatch::mut_private_metadata_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_team_score",
                    CMsgDOTAMatch::get_radiant_team_score_for_reflect,
                    CMsgDOTAMatch::mut_radiant_team_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_team_score",
                    CMsgDOTAMatch::get_dire_team_score_for_reflect,
                    CMsgDOTAMatch::mut_dire_team_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EMatchOutcome>>(
                    "match_outcome",
                    CMsgDOTAMatch::get_match_outcome_for_reflect,
                    CMsgDOTAMatch::mut_match_outcome_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_id",
                    CMsgDOTAMatch::get_tournament_id_for_reflect,
                    CMsgDOTAMatch::mut_tournament_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_round",
                    CMsgDOTAMatch::get_tournament_round_for_reflect,
                    CMsgDOTAMatch::mut_tournament_round_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pre_game_duration",
                    CMsgDOTAMatch::get_pre_game_duration_for_reflect,
                    CMsgDOTAMatch::mut_pre_game_duration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch>(
                    "CMsgDOTAMatch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch {
    fn clear(&mut self) {
        self.clear_duration();
        self.clear_startTime();
        self.clear_players();
        self.clear_match_id();
        self.clear_tower_status();
        self.clear_barracks_status();
        self.clear_cluster();
        self.clear_first_blood_time();
        self.clear_replay_salt();
        self.clear_server_ip();
        self.clear_server_port();
        self.clear_lobby_type();
        self.clear_human_players();
        self.clear_average_skill();
        self.clear_game_balance();
        self.clear_radiant_team_id();
        self.clear_dire_team_id();
        self.clear_leagueid();
        self.clear_radiant_team_name();
        self.clear_dire_team_name();
        self.clear_radiant_team_logo();
        self.clear_dire_team_logo();
        self.clear_radiant_team_complete();
        self.clear_dire_team_complete();
        self.clear_positive_votes();
        self.clear_negative_votes();
        self.clear_game_mode();
        self.clear_picks_bans();
        self.clear_match_seq_num();
        self.clear_replay_state();
        self.clear_radiant_guild_id();
        self.clear_dire_guild_id();
        self.clear_radiant_team_tag();
        self.clear_dire_team_tag();
        self.clear_series_id();
        self.clear_series_type();
        self.clear_broadcaster_channels();
        self.clear_engine();
        self.clear_custom_game_data();
        self.clear_match_flags();
        self.clear_private_metadata_key();
        self.clear_radiant_team_score();
        self.clear_dire_team_score();
        self.clear_match_outcome();
        self.clear_tournament_id();
        self.clear_tournament_round();
        self.clear_pre_game_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    player_slot: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    item_0: ::std::option::Option<u32>,
    item_1: ::std::option::Option<u32>,
    item_2: ::std::option::Option<u32>,
    item_3: ::std::option::Option<u32>,
    item_4: ::std::option::Option<u32>,
    item_5: ::std::option::Option<u32>,
    item_6: ::std::option::Option<u32>,
    item_7: ::std::option::Option<u32>,
    item_8: ::std::option::Option<u32>,
    expected_team_contribution: ::std::option::Option<f32>,
    scaled_metric: ::std::option::Option<f32>,
    previous_rank: ::std::option::Option<u32>,
    rank_change: ::std::option::Option<i32>,
    solo_rank: ::std::option::Option<bool>,
    seasonal_rank: ::std::option::Option<bool>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    leaver_status: ::std::option::Option<u32>,
    gold: ::std::option::Option<u32>,
    last_hits: ::std::option::Option<u32>,
    denies: ::std::option::Option<u32>,
    gold_per_min: ::std::option::Option<u32>,
    XP_per_min: ::std::option::Option<u32>,
    gold_spent: ::std::option::Option<u32>,
    hero_damage: ::std::option::Option<u32>,
    tower_damage: ::std::option::Option<u32>,
    hero_healing: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    time_last_seen: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    support_ability_value: ::std::option::Option<u32>,
    feeding_detected: ::std::option::Option<bool>,
    search_rank: ::std::option::Option<u32>,
    search_rank_uncertainty: ::std::option::Option<u32>,
    rank_uncertainty_change: ::std::option::Option<i32>,
    hero_play_count: ::std::option::Option<u32>,
    party_id: ::std::option::Option<u64>,
    scaled_hero_damage: ::std::option::Option<u32>,
    scaled_tower_damage: ::std::option::Option<u32>,
    scaled_hero_healing: ::std::option::Option<u32>,
    scaled_kills: ::std::option::Option<f32>,
    scaled_deaths: ::std::option::Option<f32>,
    scaled_assists: ::std::option::Option<f32>,
    claimed_farm_gold: ::std::option::Option<u32>,
    support_gold: ::std::option::Option<u32>,
    claimed_denies: ::std::option::Option<u32>,
    claimed_misses: ::std::option::Option<u32>,
    misses: ::std::option::Option<u32>,
    ability_upgrades: ::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade>,
    additional_units_inventory: ::protobuf::RepeatedField<CMatchAdditionalUnitInventory>,
    permanent_buffs: ::protobuf::RepeatedField<CMatchPlayerPermanentBuff>,
    custom_game_data: ::protobuf::SingularPtrField<CMsgDOTAMatch_Player_CustomGameData>,
    active_battle_pass: ::std::option::Option<bool>,
    net_worth: ::std::option::Option<u32>,
    bot_difficulty: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch_Player {}

impl CMsgDOTAMatch_Player {
    pub fn new() -> CMsgDOTAMatch_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch_Player,
        };
        unsafe {
            instance.get(CMsgDOTAMatch_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 player_slot = 2;

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    pub fn get_player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    fn get_player_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_slot
    }

    fn mut_player_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_slot
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 item_0 = 4;

    pub fn clear_item_0(&mut self) {
        self.item_0 = ::std::option::Option::None;
    }

    pub fn has_item_0(&self) -> bool {
        self.item_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_0(&mut self, v: u32) {
        self.item_0 = ::std::option::Option::Some(v);
    }

    pub fn get_item_0(&self) -> u32 {
        self.item_0.unwrap_or(0)
    }

    fn get_item_0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_0
    }

    fn mut_item_0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_0
    }

    // optional uint32 item_1 = 5;

    pub fn clear_item_1(&mut self) {
        self.item_1 = ::std::option::Option::None;
    }

    pub fn has_item_1(&self) -> bool {
        self.item_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_1(&mut self, v: u32) {
        self.item_1 = ::std::option::Option::Some(v);
    }

    pub fn get_item_1(&self) -> u32 {
        self.item_1.unwrap_or(0)
    }

    fn get_item_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_1
    }

    fn mut_item_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_1
    }

    // optional uint32 item_2 = 6;

    pub fn clear_item_2(&mut self) {
        self.item_2 = ::std::option::Option::None;
    }

    pub fn has_item_2(&self) -> bool {
        self.item_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_2(&mut self, v: u32) {
        self.item_2 = ::std::option::Option::Some(v);
    }

    pub fn get_item_2(&self) -> u32 {
        self.item_2.unwrap_or(0)
    }

    fn get_item_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_2
    }

    fn mut_item_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_2
    }

    // optional uint32 item_3 = 7;

    pub fn clear_item_3(&mut self) {
        self.item_3 = ::std::option::Option::None;
    }

    pub fn has_item_3(&self) -> bool {
        self.item_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_3(&mut self, v: u32) {
        self.item_3 = ::std::option::Option::Some(v);
    }

    pub fn get_item_3(&self) -> u32 {
        self.item_3.unwrap_or(0)
    }

    fn get_item_3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_3
    }

    fn mut_item_3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_3
    }

    // optional uint32 item_4 = 8;

    pub fn clear_item_4(&mut self) {
        self.item_4 = ::std::option::Option::None;
    }

    pub fn has_item_4(&self) -> bool {
        self.item_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_4(&mut self, v: u32) {
        self.item_4 = ::std::option::Option::Some(v);
    }

    pub fn get_item_4(&self) -> u32 {
        self.item_4.unwrap_or(0)
    }

    fn get_item_4_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_4
    }

    fn mut_item_4_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_4
    }

    // optional uint32 item_5 = 9;

    pub fn clear_item_5(&mut self) {
        self.item_5 = ::std::option::Option::None;
    }

    pub fn has_item_5(&self) -> bool {
        self.item_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_5(&mut self, v: u32) {
        self.item_5 = ::std::option::Option::Some(v);
    }

    pub fn get_item_5(&self) -> u32 {
        self.item_5.unwrap_or(0)
    }

    fn get_item_5_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_5
    }

    fn mut_item_5_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_5
    }

    // optional uint32 item_6 = 59;

    pub fn clear_item_6(&mut self) {
        self.item_6 = ::std::option::Option::None;
    }

    pub fn has_item_6(&self) -> bool {
        self.item_6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_6(&mut self, v: u32) {
        self.item_6 = ::std::option::Option::Some(v);
    }

    pub fn get_item_6(&self) -> u32 {
        self.item_6.unwrap_or(0)
    }

    fn get_item_6_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_6
    }

    fn mut_item_6_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_6
    }

    // optional uint32 item_7 = 60;

    pub fn clear_item_7(&mut self) {
        self.item_7 = ::std::option::Option::None;
    }

    pub fn has_item_7(&self) -> bool {
        self.item_7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_7(&mut self, v: u32) {
        self.item_7 = ::std::option::Option::Some(v);
    }

    pub fn get_item_7(&self) -> u32 {
        self.item_7.unwrap_or(0)
    }

    fn get_item_7_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_7
    }

    fn mut_item_7_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_7
    }

    // optional uint32 item_8 = 61;

    pub fn clear_item_8(&mut self) {
        self.item_8 = ::std::option::Option::None;
    }

    pub fn has_item_8(&self) -> bool {
        self.item_8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_8(&mut self, v: u32) {
        self.item_8 = ::std::option::Option::Some(v);
    }

    pub fn get_item_8(&self) -> u32 {
        self.item_8.unwrap_or(0)
    }

    fn get_item_8_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_8
    }

    fn mut_item_8_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_8
    }

    // optional float expected_team_contribution = 10;

    pub fn clear_expected_team_contribution(&mut self) {
        self.expected_team_contribution = ::std::option::Option::None;
    }

    pub fn has_expected_team_contribution(&self) -> bool {
        self.expected_team_contribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_team_contribution(&mut self, v: f32) {
        self.expected_team_contribution = ::std::option::Option::Some(v);
    }

    pub fn get_expected_team_contribution(&self) -> f32 {
        self.expected_team_contribution.unwrap_or(0.)
    }

    fn get_expected_team_contribution_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.expected_team_contribution
    }

    fn mut_expected_team_contribution_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.expected_team_contribution
    }

    // optional float scaled_metric = 11;

    pub fn clear_scaled_metric(&mut self) {
        self.scaled_metric = ::std::option::Option::None;
    }

    pub fn has_scaled_metric(&self) -> bool {
        self.scaled_metric.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_metric(&mut self, v: f32) {
        self.scaled_metric = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_metric(&self) -> f32 {
        self.scaled_metric.unwrap_or(0.)
    }

    fn get_scaled_metric_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_metric
    }

    fn mut_scaled_metric_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_metric
    }

    // optional uint32 previous_rank = 12;

    pub fn clear_previous_rank(&mut self) {
        self.previous_rank = ::std::option::Option::None;
    }

    pub fn has_previous_rank(&self) -> bool {
        self.previous_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_rank(&mut self, v: u32) {
        self.previous_rank = ::std::option::Option::Some(v);
    }

    pub fn get_previous_rank(&self) -> u32 {
        self.previous_rank.unwrap_or(0)
    }

    fn get_previous_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.previous_rank
    }

    fn mut_previous_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.previous_rank
    }

    // optional sint32 rank_change = 13;

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    pub fn get_rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    fn get_rank_change_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.rank_change
    }

    fn mut_rank_change_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.rank_change
    }

    // optional bool solo_rank = 49;

    pub fn clear_solo_rank(&mut self) {
        self.solo_rank = ::std::option::Option::None;
    }

    pub fn has_solo_rank(&self) -> bool {
        self.solo_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_rank(&mut self, v: bool) {
        self.solo_rank = ::std::option::Option::Some(v);
    }

    pub fn get_solo_rank(&self) -> bool {
        self.solo_rank.unwrap_or(false)
    }

    fn get_solo_rank_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.solo_rank
    }

    fn mut_solo_rank_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.solo_rank
    }

    // optional bool seasonal_rank = 53;

    pub fn clear_seasonal_rank(&mut self) {
        self.seasonal_rank = ::std::option::Option::None;
    }

    pub fn has_seasonal_rank(&self) -> bool {
        self.seasonal_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seasonal_rank(&mut self, v: bool) {
        self.seasonal_rank = ::std::option::Option::Some(v);
    }

    pub fn get_seasonal_rank(&self) -> bool {
        self.seasonal_rank.unwrap_or(false)
    }

    fn get_seasonal_rank_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.seasonal_rank
    }

    fn mut_seasonal_rank_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.seasonal_rank
    }

    // optional uint32 kills = 14;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 15;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 assists = 16;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }

    // optional uint32 leaver_status = 17;

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: u32) {
        self.leaver_status = ::std::option::Option::Some(v);
    }

    pub fn get_leaver_status(&self) -> u32 {
        self.leaver_status.unwrap_or(0)
    }

    fn get_leaver_status_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leaver_status
    }

    fn mut_leaver_status_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leaver_status
    }

    // optional uint32 gold = 18;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional uint32 last_hits = 19;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 denies = 20;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies
    }

    // optional uint32 gold_per_min = 21;

    pub fn clear_gold_per_min(&mut self) {
        self.gold_per_min = ::std::option::Option::None;
    }

    pub fn has_gold_per_min(&self) -> bool {
        self.gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_per_min(&mut self, v: u32) {
        self.gold_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_gold_per_min(&self) -> u32 {
        self.gold_per_min.unwrap_or(0)
    }

    fn get_gold_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_per_min
    }

    fn mut_gold_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_per_min
    }

    // optional uint32 XP_per_min = 22;

    pub fn clear_XP_per_min(&mut self) {
        self.XP_per_min = ::std::option::Option::None;
    }

    pub fn has_XP_per_min(&self) -> bool {
        self.XP_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_XP_per_min(&mut self, v: u32) {
        self.XP_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_XP_per_min(&self) -> u32 {
        self.XP_per_min.unwrap_or(0)
    }

    fn get_XP_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.XP_per_min
    }

    fn mut_XP_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.XP_per_min
    }

    // optional uint32 gold_spent = 23;

    pub fn clear_gold_spent(&mut self) {
        self.gold_spent = ::std::option::Option::None;
    }

    pub fn has_gold_spent(&self) -> bool {
        self.gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_spent(&mut self, v: u32) {
        self.gold_spent = ::std::option::Option::Some(v);
    }

    pub fn get_gold_spent(&self) -> u32 {
        self.gold_spent.unwrap_or(0)
    }

    fn get_gold_spent_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_spent
    }

    fn mut_gold_spent_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_spent
    }

    // optional uint32 hero_damage = 24;

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    fn get_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_damage
    }

    fn mut_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_damage
    }

    // optional uint32 tower_damage = 25;

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    fn get_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_damage
    }

    fn mut_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_damage
    }

    // optional uint32 hero_healing = 26;

    pub fn clear_hero_healing(&mut self) {
        self.hero_healing = ::std::option::Option::None;
    }

    pub fn has_hero_healing(&self) -> bool {
        self.hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_healing(&mut self, v: u32) {
        self.hero_healing = ::std::option::Option::Some(v);
    }

    pub fn get_hero_healing(&self) -> u32 {
        self.hero_healing.unwrap_or(0)
    }

    fn get_hero_healing_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_healing
    }

    fn mut_hero_healing_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_healing
    }

    // optional uint32 level = 27;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional uint32 time_last_seen = 28;

    pub fn clear_time_last_seen(&mut self) {
        self.time_last_seen = ::std::option::Option::None;
    }

    pub fn has_time_last_seen(&self) -> bool {
        self.time_last_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_seen(&mut self, v: u32) {
        self.time_last_seen = ::std::option::Option::Some(v);
    }

    pub fn get_time_last_seen(&self) -> u32 {
        self.time_last_seen.unwrap_or(0)
    }

    fn get_time_last_seen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_last_seen
    }

    fn mut_time_last_seen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_last_seen
    }

    // optional string player_name = 29;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional uint32 support_ability_value = 30;

    pub fn clear_support_ability_value(&mut self) {
        self.support_ability_value = ::std::option::Option::None;
    }

    pub fn has_support_ability_value(&self) -> bool {
        self.support_ability_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_ability_value(&mut self, v: u32) {
        self.support_ability_value = ::std::option::Option::Some(v);
    }

    pub fn get_support_ability_value(&self) -> u32 {
        self.support_ability_value.unwrap_or(0)
    }

    fn get_support_ability_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.support_ability_value
    }

    fn mut_support_ability_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.support_ability_value
    }

    // optional bool feeding_detected = 32;

    pub fn clear_feeding_detected(&mut self) {
        self.feeding_detected = ::std::option::Option::None;
    }

    pub fn has_feeding_detected(&self) -> bool {
        self.feeding_detected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feeding_detected(&mut self, v: bool) {
        self.feeding_detected = ::std::option::Option::Some(v);
    }

    pub fn get_feeding_detected(&self) -> bool {
        self.feeding_detected.unwrap_or(false)
    }

    fn get_feeding_detected_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.feeding_detected
    }

    fn mut_feeding_detected_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.feeding_detected
    }

    // optional uint32 search_rank = 34;

    pub fn clear_search_rank(&mut self) {
        self.search_rank = ::std::option::Option::None;
    }

    pub fn has_search_rank(&self) -> bool {
        self.search_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_rank(&mut self, v: u32) {
        self.search_rank = ::std::option::Option::Some(v);
    }

    pub fn get_search_rank(&self) -> u32 {
        self.search_rank.unwrap_or(0)
    }

    fn get_search_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.search_rank
    }

    fn mut_search_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.search_rank
    }

    // optional uint32 search_rank_uncertainty = 35;

    pub fn clear_search_rank_uncertainty(&mut self) {
        self.search_rank_uncertainty = ::std::option::Option::None;
    }

    pub fn has_search_rank_uncertainty(&self) -> bool {
        self.search_rank_uncertainty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_rank_uncertainty(&mut self, v: u32) {
        self.search_rank_uncertainty = ::std::option::Option::Some(v);
    }

    pub fn get_search_rank_uncertainty(&self) -> u32 {
        self.search_rank_uncertainty.unwrap_or(0)
    }

    fn get_search_rank_uncertainty_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.search_rank_uncertainty
    }

    fn mut_search_rank_uncertainty_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.search_rank_uncertainty
    }

    // optional int32 rank_uncertainty_change = 36;

    pub fn clear_rank_uncertainty_change(&mut self) {
        self.rank_uncertainty_change = ::std::option::Option::None;
    }

    pub fn has_rank_uncertainty_change(&self) -> bool {
        self.rank_uncertainty_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_uncertainty_change(&mut self, v: i32) {
        self.rank_uncertainty_change = ::std::option::Option::Some(v);
    }

    pub fn get_rank_uncertainty_change(&self) -> i32 {
        self.rank_uncertainty_change.unwrap_or(0)
    }

    fn get_rank_uncertainty_change_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.rank_uncertainty_change
    }

    fn mut_rank_uncertainty_change_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.rank_uncertainty_change
    }

    // optional uint32 hero_play_count = 37;

    pub fn clear_hero_play_count(&mut self) {
        self.hero_play_count = ::std::option::Option::None;
    }

    pub fn has_hero_play_count(&self) -> bool {
        self.hero_play_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_play_count(&mut self, v: u32) {
        self.hero_play_count = ::std::option::Option::Some(v);
    }

    pub fn get_hero_play_count(&self) -> u32 {
        self.hero_play_count.unwrap_or(0)
    }

    fn get_hero_play_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_play_count
    }

    fn mut_hero_play_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_play_count
    }

    // optional fixed64 party_id = 38;

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    fn get_party_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.party_id
    }

    fn mut_party_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.party_id
    }

    // optional uint32 scaled_hero_damage = 54;

    pub fn clear_scaled_hero_damage(&mut self) {
        self.scaled_hero_damage = ::std::option::Option::None;
    }

    pub fn has_scaled_hero_damage(&self) -> bool {
        self.scaled_hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_hero_damage(&mut self, v: u32) {
        self.scaled_hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_hero_damage(&self) -> u32 {
        self.scaled_hero_damage.unwrap_or(0)
    }

    fn get_scaled_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_hero_damage
    }

    fn mut_scaled_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_hero_damage
    }

    // optional uint32 scaled_tower_damage = 55;

    pub fn clear_scaled_tower_damage(&mut self) {
        self.scaled_tower_damage = ::std::option::Option::None;
    }

    pub fn has_scaled_tower_damage(&self) -> bool {
        self.scaled_tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_tower_damage(&mut self, v: u32) {
        self.scaled_tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_tower_damage(&self) -> u32 {
        self.scaled_tower_damage.unwrap_or(0)
    }

    fn get_scaled_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_tower_damage
    }

    fn mut_scaled_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_tower_damage
    }

    // optional uint32 scaled_hero_healing = 56;

    pub fn clear_scaled_hero_healing(&mut self) {
        self.scaled_hero_healing = ::std::option::Option::None;
    }

    pub fn has_scaled_hero_healing(&self) -> bool {
        self.scaled_hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_hero_healing(&mut self, v: u32) {
        self.scaled_hero_healing = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_hero_healing(&self) -> u32 {
        self.scaled_hero_healing.unwrap_or(0)
    }

    fn get_scaled_hero_healing_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_hero_healing
    }

    fn mut_scaled_hero_healing_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_hero_healing
    }

    // optional float scaled_kills = 39;

    pub fn clear_scaled_kills(&mut self) {
        self.scaled_kills = ::std::option::Option::None;
    }

    pub fn has_scaled_kills(&self) -> bool {
        self.scaled_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_kills(&mut self, v: f32) {
        self.scaled_kills = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_kills(&self) -> f32 {
        self.scaled_kills.unwrap_or(0.)
    }

    fn get_scaled_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_kills
    }

    fn mut_scaled_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_kills
    }

    // optional float scaled_deaths = 40;

    pub fn clear_scaled_deaths(&mut self) {
        self.scaled_deaths = ::std::option::Option::None;
    }

    pub fn has_scaled_deaths(&self) -> bool {
        self.scaled_deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_deaths(&mut self, v: f32) {
        self.scaled_deaths = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_deaths(&self) -> f32 {
        self.scaled_deaths.unwrap_or(0.)
    }

    fn get_scaled_deaths_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_deaths
    }

    fn mut_scaled_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_deaths
    }

    // optional float scaled_assists = 41;

    pub fn clear_scaled_assists(&mut self) {
        self.scaled_assists = ::std::option::Option::None;
    }

    pub fn has_scaled_assists(&self) -> bool {
        self.scaled_assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_assists(&mut self, v: f32) {
        self.scaled_assists = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_assists(&self) -> f32 {
        self.scaled_assists.unwrap_or(0.)
    }

    fn get_scaled_assists_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_assists
    }

    fn mut_scaled_assists_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_assists
    }

    // optional uint32 claimed_farm_gold = 42;

    pub fn clear_claimed_farm_gold(&mut self) {
        self.claimed_farm_gold = ::std::option::Option::None;
    }

    pub fn has_claimed_farm_gold(&self) -> bool {
        self.claimed_farm_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_farm_gold(&mut self, v: u32) {
        self.claimed_farm_gold = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_farm_gold(&self) -> u32 {
        self.claimed_farm_gold.unwrap_or(0)
    }

    fn get_claimed_farm_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_farm_gold
    }

    fn mut_claimed_farm_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_farm_gold
    }

    // optional uint32 support_gold = 43;

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }

    pub fn get_support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    fn get_support_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.support_gold
    }

    fn mut_support_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.support_gold
    }

    // optional uint32 claimed_denies = 44;

    pub fn clear_claimed_denies(&mut self) {
        self.claimed_denies = ::std::option::Option::None;
    }

    pub fn has_claimed_denies(&self) -> bool {
        self.claimed_denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_denies(&mut self, v: u32) {
        self.claimed_denies = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_denies(&self) -> u32 {
        self.claimed_denies.unwrap_or(0)
    }

    fn get_claimed_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_denies
    }

    fn mut_claimed_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_denies
    }

    // optional uint32 claimed_misses = 45;

    pub fn clear_claimed_misses(&mut self) {
        self.claimed_misses = ::std::option::Option::None;
    }

    pub fn has_claimed_misses(&self) -> bool {
        self.claimed_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_misses(&mut self, v: u32) {
        self.claimed_misses = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_misses(&self) -> u32 {
        self.claimed_misses.unwrap_or(0)
    }

    fn get_claimed_misses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_misses
    }

    fn mut_claimed_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_misses
    }

    // optional uint32 misses = 46;

    pub fn clear_misses(&mut self) {
        self.misses = ::std::option::Option::None;
    }

    pub fn has_misses(&self) -> bool {
        self.misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misses(&mut self, v: u32) {
        self.misses = ::std::option::Option::Some(v);
    }

    pub fn get_misses(&self) -> u32 {
        self.misses.unwrap_or(0)
    }

    fn get_misses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.misses
    }

    fn mut_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.misses
    }

    // repeated .CMatchPlayerAbilityUpgrade ability_upgrades = 47;

    pub fn clear_ability_upgrades(&mut self) {
        self.ability_upgrades.clear();
    }

    // Param is passed by value, moved
    pub fn set_ability_upgrades(&mut self, v: ::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade>) {
        self.ability_upgrades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ability_upgrades(&mut self) -> &mut ::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade> {
        &mut self.ability_upgrades
    }

    // Take field
    pub fn take_ability_upgrades(&mut self) -> ::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade> {
        ::std::mem::replace(&mut self.ability_upgrades, ::protobuf::RepeatedField::new())
    }

    pub fn get_ability_upgrades(&self) -> &[CMatchPlayerAbilityUpgrade] {
        &self.ability_upgrades
    }

    fn get_ability_upgrades_for_reflect(&self) -> &::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade> {
        &self.ability_upgrades
    }

    fn mut_ability_upgrades_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMatchPlayerAbilityUpgrade> {
        &mut self.ability_upgrades
    }

    // repeated .CMatchAdditionalUnitInventory additional_units_inventory = 48;

    pub fn clear_additional_units_inventory(&mut self) {
        self.additional_units_inventory.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_units_inventory(&mut self, v: ::protobuf::RepeatedField<CMatchAdditionalUnitInventory>) {
        self.additional_units_inventory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_units_inventory(&mut self) -> &mut ::protobuf::RepeatedField<CMatchAdditionalUnitInventory> {
        &mut self.additional_units_inventory
    }

    // Take field
    pub fn take_additional_units_inventory(&mut self) -> ::protobuf::RepeatedField<CMatchAdditionalUnitInventory> {
        ::std::mem::replace(&mut self.additional_units_inventory, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_units_inventory(&self) -> &[CMatchAdditionalUnitInventory] {
        &self.additional_units_inventory
    }

    fn get_additional_units_inventory_for_reflect(&self) -> &::protobuf::RepeatedField<CMatchAdditionalUnitInventory> {
        &self.additional_units_inventory
    }

    fn mut_additional_units_inventory_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMatchAdditionalUnitInventory> {
        &mut self.additional_units_inventory
    }

    // repeated .CMatchPlayerPermanentBuff permanent_buffs = 57;

    pub fn clear_permanent_buffs(&mut self) {
        self.permanent_buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_permanent_buffs(&mut self, v: ::protobuf::RepeatedField<CMatchPlayerPermanentBuff>) {
        self.permanent_buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permanent_buffs(&mut self) -> &mut ::protobuf::RepeatedField<CMatchPlayerPermanentBuff> {
        &mut self.permanent_buffs
    }

    // Take field
    pub fn take_permanent_buffs(&mut self) -> ::protobuf::RepeatedField<CMatchPlayerPermanentBuff> {
        ::std::mem::replace(&mut self.permanent_buffs, ::protobuf::RepeatedField::new())
    }

    pub fn get_permanent_buffs(&self) -> &[CMatchPlayerPermanentBuff] {
        &self.permanent_buffs
    }

    fn get_permanent_buffs_for_reflect(&self) -> &::protobuf::RepeatedField<CMatchPlayerPermanentBuff> {
        &self.permanent_buffs
    }

    fn mut_permanent_buffs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMatchPlayerPermanentBuff> {
        &mut self.permanent_buffs
    }

    // optional .CMsgDOTAMatch.Player.CustomGameData custom_game_data = 50;

    pub fn clear_custom_game_data(&mut self) {
        self.custom_game_data.clear();
    }

    pub fn has_custom_game_data(&self) -> bool {
        self.custom_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_data(&mut self, v: CMsgDOTAMatch_Player_CustomGameData) {
        self.custom_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_data(&mut self) -> &mut CMsgDOTAMatch_Player_CustomGameData {
        if self.custom_game_data.is_none() {
            self.custom_game_data.set_default();
        }
        self.custom_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_data(&mut self) -> CMsgDOTAMatch_Player_CustomGameData {
        self.custom_game_data.take().unwrap_or_else(|| CMsgDOTAMatch_Player_CustomGameData::new())
    }

    pub fn get_custom_game_data(&self) -> &CMsgDOTAMatch_Player_CustomGameData {
        self.custom_game_data.as_ref().unwrap_or_else(|| CMsgDOTAMatch_Player_CustomGameData::default_instance())
    }

    fn get_custom_game_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAMatch_Player_CustomGameData> {
        &self.custom_game_data
    }

    fn mut_custom_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAMatch_Player_CustomGameData> {
        &mut self.custom_game_data
    }

    // optional bool active_battle_pass = 51;

    pub fn clear_active_battle_pass(&mut self) {
        self.active_battle_pass = ::std::option::Option::None;
    }

    pub fn has_active_battle_pass(&self) -> bool {
        self.active_battle_pass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_battle_pass(&mut self, v: bool) {
        self.active_battle_pass = ::std::option::Option::Some(v);
    }

    pub fn get_active_battle_pass(&self) -> bool {
        self.active_battle_pass.unwrap_or(false)
    }

    fn get_active_battle_pass_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.active_battle_pass
    }

    fn mut_active_battle_pass_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.active_battle_pass
    }

    // optional uint32 net_worth = 52;

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    pub fn get_net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    fn get_net_worth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_worth
    }

    fn mut_net_worth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_worth
    }

    // optional uint32 bot_difficulty = 58;

    pub fn clear_bot_difficulty(&mut self) {
        self.bot_difficulty = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty(&self) -> bool {
        self.bot_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty(&mut self, v: u32) {
        self.bot_difficulty = ::std::option::Option::Some(v);
    }

    pub fn get_bot_difficulty(&self) -> u32 {
        self.bot_difficulty.unwrap_or(0)
    }

    fn get_bot_difficulty_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bot_difficulty
    }

    fn mut_bot_difficulty_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bot_difficulty
    }
}

impl ::protobuf::Message for CMsgDOTAMatch_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.ability_upgrades {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_units_inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permanent_buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_slot = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_0 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_1 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_2 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_3 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_4 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_5 = ::std::option::Option::Some(tmp);
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_6 = ::std::option::Option::Some(tmp);
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_7 = ::std::option::Option::Some(tmp);
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_8 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.expected_team_contribution = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_metric = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.previous_rank = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.solo_rank = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.seasonal_rank = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leaver_status = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_per_min = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.XP_per_min = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_spent = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_damage = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_damage = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_healing = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_seen = ::std::option::Option::Some(tmp);
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_ability_value = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.feeding_detected = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_rank = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_rank_uncertainty = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_uncertainty_change = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_play_count = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_hero_damage = ::std::option::Option::Some(tmp);
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_tower_damage = ::std::option::Option::Some(tmp);
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_hero_healing = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_kills = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_deaths = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_assists = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_farm_gold = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_gold = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_denies = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_misses = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.misses = ::std::option::Option::Some(tmp);
                },
                47 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ability_upgrades)?;
                },
                48 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_units_inventory)?;
                },
                57 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permanent_buffs)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.custom_game_data)?;
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_battle_pass = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_worth = ::std::option::Option::Some(tmp);
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bot_difficulty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_0 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_1 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_2 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_3 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_4 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_5 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_6 {
            my_size += ::protobuf::rt::value_size(59, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_7 {
            my_size += ::protobuf::rt::value_size(60, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_8 {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expected_team_contribution {
            my_size += 5;
        }
        if let Some(v) = self.scaled_metric {
            my_size += 5;
        }
        if let Some(v) = self.previous_rank {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, v);
        }
        if let Some(v) = self.solo_rank {
            my_size += 3;
        }
        if let Some(v) = self.seasonal_rank {
            my_size += 3;
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaver_status {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_per_min {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.XP_per_min {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_spent {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_healing {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_seen {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.support_ability_value {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.feeding_detected {
            my_size += 3;
        }
        if let Some(v) = self.search_rank {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_rank_uncertainty {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_uncertainty_change {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_play_count {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.party_id {
            my_size += 10;
        }
        if let Some(v) = self.scaled_hero_damage {
            my_size += ::protobuf::rt::value_size(54, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_tower_damage {
            my_size += ::protobuf::rt::value_size(55, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_hero_healing {
            my_size += ::protobuf::rt::value_size(56, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_kills {
            my_size += 6;
        }
        if let Some(v) = self.scaled_deaths {
            my_size += 6;
        }
        if let Some(v) = self.scaled_assists {
            my_size += 6;
        }
        if let Some(v) = self.claimed_farm_gold {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_gold {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.claimed_denies {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.claimed_misses {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.misses {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ability_upgrades {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.additional_units_inventory {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.permanent_buffs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.active_battle_pass {
            my_size += 3;
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bot_difficulty {
            my_size += ::protobuf::rt::value_size(58, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_0 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_1 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.item_2 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_3 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.item_4 {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.item_5 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.item_6 {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.item_7 {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.item_8 {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.expected_team_contribution {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.scaled_metric {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.previous_rank {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_sint32(13, v)?;
        }
        if let Some(v) = self.solo_rank {
            os.write_bool(49, v)?;
        }
        if let Some(v) = self.seasonal_rank {
            os.write_bool(53, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.gold_per_min {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.XP_per_min {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.gold_spent {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.hero_healing {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.time_last_seen {
            os.write_uint32(28, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(29, &v)?;
        }
        if let Some(v) = self.support_ability_value {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.feeding_detected {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.search_rank {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.search_rank_uncertainty {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.rank_uncertainty_change {
            os.write_int32(36, v)?;
        }
        if let Some(v) = self.hero_play_count {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_fixed64(38, v)?;
        }
        if let Some(v) = self.scaled_hero_damage {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.scaled_tower_damage {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.scaled_hero_healing {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.scaled_kills {
            os.write_float(39, v)?;
        }
        if let Some(v) = self.scaled_deaths {
            os.write_float(40, v)?;
        }
        if let Some(v) = self.scaled_assists {
            os.write_float(41, v)?;
        }
        if let Some(v) = self.claimed_farm_gold {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.claimed_denies {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.claimed_misses {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.misses {
            os.write_uint32(46, v)?;
        }
        for v in &self.ability_upgrades {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.additional_units_inventory {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.permanent_buffs {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.custom_game_data.as_ref() {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.active_battle_pass {
            os.write_bool(51, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.bot_difficulty {
            os.write_uint32(58, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch_Player {
    fn new() -> CMsgDOTAMatch_Player {
        CMsgDOTAMatch_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAMatch_Player::get_account_id_for_reflect,
                    CMsgDOTAMatch_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_slot",
                    CMsgDOTAMatch_Player::get_player_slot_for_reflect,
                    CMsgDOTAMatch_Player::mut_player_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAMatch_Player::get_hero_id_for_reflect,
                    CMsgDOTAMatch_Player::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_0",
                    CMsgDOTAMatch_Player::get_item_0_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_1",
                    CMsgDOTAMatch_Player::get_item_1_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_2",
                    CMsgDOTAMatch_Player::get_item_2_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_3",
                    CMsgDOTAMatch_Player::get_item_3_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_4",
                    CMsgDOTAMatch_Player::get_item_4_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_4_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_5",
                    CMsgDOTAMatch_Player::get_item_5_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_5_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_6",
                    CMsgDOTAMatch_Player::get_item_6_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_6_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_7",
                    CMsgDOTAMatch_Player::get_item_7_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_7_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_8",
                    CMsgDOTAMatch_Player::get_item_8_for_reflect,
                    CMsgDOTAMatch_Player::mut_item_8_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "expected_team_contribution",
                    CMsgDOTAMatch_Player::get_expected_team_contribution_for_reflect,
                    CMsgDOTAMatch_Player::mut_expected_team_contribution_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_metric",
                    CMsgDOTAMatch_Player::get_scaled_metric_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_metric_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "previous_rank",
                    CMsgDOTAMatch_Player::get_previous_rank_for_reflect,
                    CMsgDOTAMatch_Player::mut_previous_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "rank_change",
                    CMsgDOTAMatch_Player::get_rank_change_for_reflect,
                    CMsgDOTAMatch_Player::mut_rank_change_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "solo_rank",
                    CMsgDOTAMatch_Player::get_solo_rank_for_reflect,
                    CMsgDOTAMatch_Player::mut_solo_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "seasonal_rank",
                    CMsgDOTAMatch_Player::get_seasonal_rank_for_reflect,
                    CMsgDOTAMatch_Player::mut_seasonal_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgDOTAMatch_Player::get_kills_for_reflect,
                    CMsgDOTAMatch_Player::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgDOTAMatch_Player::get_deaths_for_reflect,
                    CMsgDOTAMatch_Player::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgDOTAMatch_Player::get_assists_for_reflect,
                    CMsgDOTAMatch_Player::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leaver_status",
                    CMsgDOTAMatch_Player::get_leaver_status_for_reflect,
                    CMsgDOTAMatch_Player::mut_leaver_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgDOTAMatch_Player::get_gold_for_reflect,
                    CMsgDOTAMatch_Player::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CMsgDOTAMatch_Player::get_last_hits_for_reflect,
                    CMsgDOTAMatch_Player::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies",
                    CMsgDOTAMatch_Player::get_denies_for_reflect,
                    CMsgDOTAMatch_Player::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_per_min",
                    CMsgDOTAMatch_Player::get_gold_per_min_for_reflect,
                    CMsgDOTAMatch_Player::mut_gold_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "XP_per_min",
                    CMsgDOTAMatch_Player::get_XP_per_min_for_reflect,
                    CMsgDOTAMatch_Player::mut_XP_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_spent",
                    CMsgDOTAMatch_Player::get_gold_spent_for_reflect,
                    CMsgDOTAMatch_Player::mut_gold_spent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_damage",
                    CMsgDOTAMatch_Player::get_hero_damage_for_reflect,
                    CMsgDOTAMatch_Player::mut_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_damage",
                    CMsgDOTAMatch_Player::get_tower_damage_for_reflect,
                    CMsgDOTAMatch_Player::mut_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_healing",
                    CMsgDOTAMatch_Player::get_hero_healing_for_reflect,
                    CMsgDOTAMatch_Player::mut_hero_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgDOTAMatch_Player::get_level_for_reflect,
                    CMsgDOTAMatch_Player::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_seen",
                    CMsgDOTAMatch_Player::get_time_last_seen_for_reflect,
                    CMsgDOTAMatch_Player::mut_time_last_seen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    CMsgDOTAMatch_Player::get_player_name_for_reflect,
                    CMsgDOTAMatch_Player::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "support_ability_value",
                    CMsgDOTAMatch_Player::get_support_ability_value_for_reflect,
                    CMsgDOTAMatch_Player::mut_support_ability_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "feeding_detected",
                    CMsgDOTAMatch_Player::get_feeding_detected_for_reflect,
                    CMsgDOTAMatch_Player::mut_feeding_detected_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_rank",
                    CMsgDOTAMatch_Player::get_search_rank_for_reflect,
                    CMsgDOTAMatch_Player::mut_search_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_rank_uncertainty",
                    CMsgDOTAMatch_Player::get_search_rank_uncertainty_for_reflect,
                    CMsgDOTAMatch_Player::mut_search_rank_uncertainty_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank_uncertainty_change",
                    CMsgDOTAMatch_Player::get_rank_uncertainty_change_for_reflect,
                    CMsgDOTAMatch_Player::mut_rank_uncertainty_change_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_play_count",
                    CMsgDOTAMatch_Player::get_hero_play_count_for_reflect,
                    CMsgDOTAMatch_Player::mut_hero_play_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "party_id",
                    CMsgDOTAMatch_Player::get_party_id_for_reflect,
                    CMsgDOTAMatch_Player::mut_party_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_hero_damage",
                    CMsgDOTAMatch_Player::get_scaled_hero_damage_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_tower_damage",
                    CMsgDOTAMatch_Player::get_scaled_tower_damage_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_hero_healing",
                    CMsgDOTAMatch_Player::get_scaled_hero_healing_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_hero_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_kills",
                    CMsgDOTAMatch_Player::get_scaled_kills_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_deaths",
                    CMsgDOTAMatch_Player::get_scaled_deaths_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_assists",
                    CMsgDOTAMatch_Player::get_scaled_assists_for_reflect,
                    CMsgDOTAMatch_Player::mut_scaled_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_farm_gold",
                    CMsgDOTAMatch_Player::get_claimed_farm_gold_for_reflect,
                    CMsgDOTAMatch_Player::mut_claimed_farm_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "support_gold",
                    CMsgDOTAMatch_Player::get_support_gold_for_reflect,
                    CMsgDOTAMatch_Player::mut_support_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_denies",
                    CMsgDOTAMatch_Player::get_claimed_denies_for_reflect,
                    CMsgDOTAMatch_Player::mut_claimed_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_misses",
                    CMsgDOTAMatch_Player::get_claimed_misses_for_reflect,
                    CMsgDOTAMatch_Player::mut_claimed_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "misses",
                    CMsgDOTAMatch_Player::get_misses_for_reflect,
                    CMsgDOTAMatch_Player::mut_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMatchPlayerAbilityUpgrade>>(
                    "ability_upgrades",
                    CMsgDOTAMatch_Player::get_ability_upgrades_for_reflect,
                    CMsgDOTAMatch_Player::mut_ability_upgrades_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMatchAdditionalUnitInventory>>(
                    "additional_units_inventory",
                    CMsgDOTAMatch_Player::get_additional_units_inventory_for_reflect,
                    CMsgDOTAMatch_Player::mut_additional_units_inventory_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMatchPlayerPermanentBuff>>(
                    "permanent_buffs",
                    CMsgDOTAMatch_Player::get_permanent_buffs_for_reflect,
                    CMsgDOTAMatch_Player::mut_permanent_buffs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatch_Player_CustomGameData>>(
                    "custom_game_data",
                    CMsgDOTAMatch_Player::get_custom_game_data_for_reflect,
                    CMsgDOTAMatch_Player::mut_custom_game_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active_battle_pass",
                    CMsgDOTAMatch_Player::get_active_battle_pass_for_reflect,
                    CMsgDOTAMatch_Player::mut_active_battle_pass_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_worth",
                    CMsgDOTAMatch_Player::get_net_worth_for_reflect,
                    CMsgDOTAMatch_Player::mut_net_worth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bot_difficulty",
                    CMsgDOTAMatch_Player::get_bot_difficulty_for_reflect,
                    CMsgDOTAMatch_Player::mut_bot_difficulty_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch_Player>(
                    "CMsgDOTAMatch_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_player_slot();
        self.clear_hero_id();
        self.clear_item_0();
        self.clear_item_1();
        self.clear_item_2();
        self.clear_item_3();
        self.clear_item_4();
        self.clear_item_5();
        self.clear_item_6();
        self.clear_item_7();
        self.clear_item_8();
        self.clear_expected_team_contribution();
        self.clear_scaled_metric();
        self.clear_previous_rank();
        self.clear_rank_change();
        self.clear_solo_rank();
        self.clear_seasonal_rank();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_leaver_status();
        self.clear_gold();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gold_per_min();
        self.clear_XP_per_min();
        self.clear_gold_spent();
        self.clear_hero_damage();
        self.clear_tower_damage();
        self.clear_hero_healing();
        self.clear_level();
        self.clear_time_last_seen();
        self.clear_player_name();
        self.clear_support_ability_value();
        self.clear_feeding_detected();
        self.clear_search_rank();
        self.clear_search_rank_uncertainty();
        self.clear_rank_uncertainty_change();
        self.clear_hero_play_count();
        self.clear_party_id();
        self.clear_scaled_hero_damage();
        self.clear_scaled_tower_damage();
        self.clear_scaled_hero_healing();
        self.clear_scaled_kills();
        self.clear_scaled_deaths();
        self.clear_scaled_assists();
        self.clear_claimed_farm_gold();
        self.clear_support_gold();
        self.clear_claimed_denies();
        self.clear_claimed_misses();
        self.clear_misses();
        self.clear_ability_upgrades();
        self.clear_additional_units_inventory();
        self.clear_permanent_buffs();
        self.clear_custom_game_data();
        self.clear_active_battle_pass();
        self.clear_net_worth();
        self.clear_bot_difficulty();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch_Player_CustomGameData {
    // message fields
    dota_team: ::std::option::Option<u32>,
    winner: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch_Player_CustomGameData {}

impl CMsgDOTAMatch_Player_CustomGameData {
    pub fn new() -> CMsgDOTAMatch_Player_CustomGameData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch_Player_CustomGameData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch_Player_CustomGameData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch_Player_CustomGameData,
        };
        unsafe {
            instance.get(CMsgDOTAMatch_Player_CustomGameData::new)
        }
    }

    // optional uint32 dota_team = 1;

    pub fn clear_dota_team(&mut self) {
        self.dota_team = ::std::option::Option::None;
    }

    pub fn has_dota_team(&self) -> bool {
        self.dota_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_team(&mut self, v: u32) {
        self.dota_team = ::std::option::Option::Some(v);
    }

    pub fn get_dota_team(&self) -> u32 {
        self.dota_team.unwrap_or(0)
    }

    fn get_dota_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dota_team
    }

    fn mut_dota_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dota_team
    }

    // optional bool winner = 2;

    pub fn clear_winner(&mut self) {
        self.winner = ::std::option::Option::None;
    }

    pub fn has_winner(&self) -> bool {
        self.winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner(&mut self, v: bool) {
        self.winner = ::std::option::Option::Some(v);
    }

    pub fn get_winner(&self) -> bool {
        self.winner.unwrap_or(false)
    }

    fn get_winner_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.winner
    }

    fn mut_winner_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.winner
    }
}

impl ::protobuf::Message for CMsgDOTAMatch_Player_CustomGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dota_team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.winner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dota_team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winner {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dota_team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.winner {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch_Player_CustomGameData {
    fn new() -> CMsgDOTAMatch_Player_CustomGameData {
        CMsgDOTAMatch_Player_CustomGameData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_Player_CustomGameData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dota_team",
                    CMsgDOTAMatch_Player_CustomGameData::get_dota_team_for_reflect,
                    CMsgDOTAMatch_Player_CustomGameData::mut_dota_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "winner",
                    CMsgDOTAMatch_Player_CustomGameData::get_winner_for_reflect,
                    CMsgDOTAMatch_Player_CustomGameData::mut_winner_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch_Player_CustomGameData>(
                    "CMsgDOTAMatch_Player_CustomGameData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch_Player_CustomGameData {
    fn clear(&mut self) {
        self.clear_dota_team();
        self.clear_winner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch_Player_CustomGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_Player_CustomGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch_BroadcasterInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch_BroadcasterInfo {}

impl CMsgDOTAMatch_BroadcasterInfo {
    pub fn new() -> CMsgDOTAMatch_BroadcasterInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch_BroadcasterInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch_BroadcasterInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch_BroadcasterInfo,
        };
        unsafe {
            instance.get(CMsgDOTAMatch_BroadcasterInfo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for CMsgDOTAMatch_BroadcasterInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch_BroadcasterInfo {
    fn new() -> CMsgDOTAMatch_BroadcasterInfo {
        CMsgDOTAMatch_BroadcasterInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_BroadcasterInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAMatch_BroadcasterInfo::get_account_id_for_reflect,
                    CMsgDOTAMatch_BroadcasterInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTAMatch_BroadcasterInfo::get_name_for_reflect,
                    CMsgDOTAMatch_BroadcasterInfo::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch_BroadcasterInfo>(
                    "CMsgDOTAMatch_BroadcasterInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch_BroadcasterInfo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch_BroadcasterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_BroadcasterInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch_BroadcasterChannel {
    // message fields
    country_code: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    broadcaster_infos: ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo>,
    language_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch_BroadcasterChannel {}

impl CMsgDOTAMatch_BroadcasterChannel {
    pub fn new() -> CMsgDOTAMatch_BroadcasterChannel {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch_BroadcasterChannel {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch_BroadcasterChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch_BroadcasterChannel,
        };
        unsafe {
            instance.get(CMsgDOTAMatch_BroadcasterChannel::new)
        }
    }

    // optional string country_code = 1;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional string description = 2;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_description_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.description
    }

    fn mut_description_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.description
    }

    // repeated .CMsgDOTAMatch.BroadcasterInfo broadcaster_infos = 3;

    pub fn clear_broadcaster_infos(&mut self) {
        self.broadcaster_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_infos(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo>) {
        self.broadcaster_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcaster_infos(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo> {
        &mut self.broadcaster_infos
    }

    // Take field
    pub fn take_broadcaster_infos(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo> {
        ::std::mem::replace(&mut self.broadcaster_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_broadcaster_infos(&self) -> &[CMsgDOTAMatch_BroadcasterInfo] {
        &self.broadcaster_infos
    }

    fn get_broadcaster_infos_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo> {
        &self.broadcaster_infos
    }

    fn mut_broadcaster_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatch_BroadcasterInfo> {
        &mut self.broadcaster_infos
    }

    // optional string language_code = 4;

    pub fn clear_language_code(&mut self) {
        self.language_code.clear();
    }

    pub fn has_language_code(&self) -> bool {
        self.language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        if self.language_code.is_none() {
            self.language_code.set_default();
        }
        self.language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language_code(&self) -> &str {
        match self.language_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_language_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.language_code
    }

    fn mut_language_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.language_code
    }
}

impl ::protobuf::Message for CMsgDOTAMatch_BroadcasterChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.broadcaster_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.broadcaster_infos)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.broadcaster_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.language_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.broadcaster_infos {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.language_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch_BroadcasterChannel {
    fn new() -> CMsgDOTAMatch_BroadcasterChannel {
        CMsgDOTAMatch_BroadcasterChannel::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_BroadcasterChannel>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CMsgDOTAMatch_BroadcasterChannel::get_country_code_for_reflect,
                    CMsgDOTAMatch_BroadcasterChannel::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    CMsgDOTAMatch_BroadcasterChannel::get_description_for_reflect,
                    CMsgDOTAMatch_BroadcasterChannel::mut_description_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatch_BroadcasterInfo>>(
                    "broadcaster_infos",
                    CMsgDOTAMatch_BroadcasterChannel::get_broadcaster_infos_for_reflect,
                    CMsgDOTAMatch_BroadcasterChannel::mut_broadcaster_infos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language_code",
                    CMsgDOTAMatch_BroadcasterChannel::get_language_code_for_reflect,
                    CMsgDOTAMatch_BroadcasterChannel::mut_language_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch_BroadcasterChannel>(
                    "CMsgDOTAMatch_BroadcasterChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch_BroadcasterChannel {
    fn clear(&mut self) {
        self.clear_country_code();
        self.clear_description();
        self.clear_broadcaster_infos();
        self.clear_language_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch_BroadcasterChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_BroadcasterChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatch_CustomGameData {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    map_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatch_CustomGameData {}

impl CMsgDOTAMatch_CustomGameData {
    pub fn new() -> CMsgDOTAMatch_CustomGameData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatch_CustomGameData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatch_CustomGameData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatch_CustomGameData,
        };
        unsafe {
            instance.get(CMsgDOTAMatch_CustomGameData::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // optional string map_name = 2;

    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_map_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.map_name
    }

    fn mut_map_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.map_name
    }
}

impl ::protobuf::Message for CMsgDOTAMatch_CustomGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatch_CustomGameData {
    fn new() -> CMsgDOTAMatch_CustomGameData {
        CMsgDOTAMatch_CustomGameData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_CustomGameData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgDOTAMatch_CustomGameData::get_custom_game_id_for_reflect,
                    CMsgDOTAMatch_CustomGameData::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map_name",
                    CMsgDOTAMatch_CustomGameData::get_map_name_for_reflect,
                    CMsgDOTAMatch_CustomGameData::mut_map_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatch_CustomGameData>(
                    "CMsgDOTAMatch_CustomGameData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatch_CustomGameData {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.clear_map_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatch_CustomGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_CustomGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAMatch_ReplayState {
    REPLAY_AVAILABLE = 0,
    REPLAY_NOT_RECORDED = 1,
    REPLAY_EXPIRED = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAMatch_ReplayState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAMatch_ReplayState> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAMatch_ReplayState::REPLAY_AVAILABLE),
            1 => ::std::option::Option::Some(CMsgDOTAMatch_ReplayState::REPLAY_NOT_RECORDED),
            2 => ::std::option::Option::Some(CMsgDOTAMatch_ReplayState::REPLAY_EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAMatch_ReplayState] = &[
            CMsgDOTAMatch_ReplayState::REPLAY_AVAILABLE,
            CMsgDOTAMatch_ReplayState::REPLAY_NOT_RECORDED,
            CMsgDOTAMatch_ReplayState::REPLAY_EXPIRED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAMatch_ReplayState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAMatch_ReplayState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAMatch_ReplayState {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatch_ReplayState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    stat_modifier: ::protobuf::RepeatedField<CMsgPlayerCard_StatModifier>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPlayerCard {}

impl CMsgPlayerCard {
    pub fn new() -> CMsgPlayerCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPlayerCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPlayerCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPlayerCard,
        };
        unsafe {
            instance.get(CMsgPlayerCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgPlayerCard.StatModifier stat_modifier = 2;

    pub fn clear_stat_modifier(&mut self) {
        self.stat_modifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_modifier(&mut self, v: ::protobuf::RepeatedField<CMsgPlayerCard_StatModifier>) {
        self.stat_modifier = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_modifier(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPlayerCard_StatModifier> {
        &mut self.stat_modifier
    }

    // Take field
    pub fn take_stat_modifier(&mut self) -> ::protobuf::RepeatedField<CMsgPlayerCard_StatModifier> {
        ::std::mem::replace(&mut self.stat_modifier, ::protobuf::RepeatedField::new())
    }

    pub fn get_stat_modifier(&self) -> &[CMsgPlayerCard_StatModifier] {
        &self.stat_modifier
    }

    fn get_stat_modifier_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPlayerCard_StatModifier> {
        &self.stat_modifier
    }

    fn mut_stat_modifier_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPlayerCard_StatModifier> {
        &mut self.stat_modifier
    }
}

impl ::protobuf::Message for CMsgPlayerCard {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_modifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_modifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stat_modifier {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stat_modifier {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPlayerCard {
    fn new() -> CMsgPlayerCard {
        CMsgPlayerCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPlayerCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgPlayerCard::get_account_id_for_reflect,
                    CMsgPlayerCard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPlayerCard_StatModifier>>(
                    "stat_modifier",
                    CMsgPlayerCard::get_stat_modifier_for_reflect,
                    CMsgPlayerCard::mut_stat_modifier_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPlayerCard>(
                    "CMsgPlayerCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPlayerCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_stat_modifier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerCard_StatModifier {
    // message fields
    stat: ::std::option::Option<u32>,
    value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPlayerCard_StatModifier {}

impl CMsgPlayerCard_StatModifier {
    pub fn new() -> CMsgPlayerCard_StatModifier {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPlayerCard_StatModifier {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPlayerCard_StatModifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPlayerCard_StatModifier,
        };
        unsafe {
            instance.get(CMsgPlayerCard_StatModifier::new)
        }
    }

    // optional uint32 stat = 1;

    pub fn clear_stat(&mut self) {
        self.stat = ::std::option::Option::None;
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: u32) {
        self.stat = ::std::option::Option::Some(v);
    }

    pub fn get_stat(&self) -> u32 {
        self.stat.unwrap_or(0)
    }

    fn get_stat_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stat
    }

    // optional uint32 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CMsgPlayerCard_StatModifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPlayerCard_StatModifier {
    fn new() -> CMsgPlayerCard_StatModifier {
        CMsgPlayerCard_StatModifier::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPlayerCard_StatModifier>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stat",
                    CMsgPlayerCard_StatModifier::get_stat_for_reflect,
                    CMsgPlayerCard_StatModifier::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CMsgPlayerCard_StatModifier::get_value_for_reflect,
                    CMsgPlayerCard_StatModifier::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPlayerCard_StatModifier>(
                    "CMsgPlayerCard_StatModifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPlayerCard_StatModifier {
    fn clear(&mut self) {
        self.clear_stat();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerCard_StatModifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerCard_StatModifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerStats {
    // message fields
    player_account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    match_completed: ::std::option::Option<bool>,
    team_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    delay: ::std::option::Option<u32>,
    series_id: ::std::option::Option<u32>,
    series_type: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    cs: ::std::option::Option<u32>,
    gpm: ::std::option::Option<f32>,
    tower_kills: ::std::option::Option<u32>,
    roshan_kills: ::std::option::Option<u32>,
    teamfight_participation: ::std::option::Option<f32>,
    wards_placed: ::std::option::Option<u32>,
    camps_stacked: ::std::option::Option<u32>,
    runes_grabbed: ::std::option::Option<u32>,
    first_blood: ::std::option::Option<u32>,
    stuns: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerStats {}

impl CMsgDOTAFantasyPlayerStats {
    pub fn new() -> CMsgDOTAFantasyPlayerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerStats,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerStats::new)
        }
    }

    // optional uint32 player_account_id = 1;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional bool match_completed = 3;

    pub fn clear_match_completed(&mut self) {
        self.match_completed = ::std::option::Option::None;
    }

    pub fn has_match_completed(&self) -> bool {
        self.match_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_completed(&mut self, v: bool) {
        self.match_completed = ::std::option::Option::Some(v);
    }

    pub fn get_match_completed(&self) -> bool {
        self.match_completed.unwrap_or(false)
    }

    fn get_match_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.match_completed
    }

    fn mut_match_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.match_completed
    }

    // optional uint32 team_id = 4;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional uint32 league_id = 5;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 delay = 6;

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: u32) {
        self.delay = ::std::option::Option::Some(v);
    }

    pub fn get_delay(&self) -> u32 {
        self.delay.unwrap_or(0)
    }

    fn get_delay_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.delay
    }

    fn mut_delay_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.delay
    }

    // optional uint32 series_id = 7;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 series_type = 8;

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    pub fn get_series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    fn get_series_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_type
    }

    fn mut_series_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_type
    }

    // optional uint32 kills = 10;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 11;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 cs = 12;

    pub fn clear_cs(&mut self) {
        self.cs = ::std::option::Option::None;
    }

    pub fn has_cs(&self) -> bool {
        self.cs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cs(&mut self, v: u32) {
        self.cs = ::std::option::Option::Some(v);
    }

    pub fn get_cs(&self) -> u32 {
        self.cs.unwrap_or(0)
    }

    fn get_cs_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cs
    }

    fn mut_cs_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cs
    }

    // optional float gpm = 13;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.gpm
    }

    // optional uint32 tower_kills = 14;

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    pub fn get_tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    fn get_tower_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_kills
    }

    fn mut_tower_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_kills
    }

    // optional uint32 roshan_kills = 15;

    pub fn clear_roshan_kills(&mut self) {
        self.roshan_kills = ::std::option::Option::None;
    }

    pub fn has_roshan_kills(&self) -> bool {
        self.roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills(&mut self, v: u32) {
        self.roshan_kills = ::std::option::Option::Some(v);
    }

    pub fn get_roshan_kills(&self) -> u32 {
        self.roshan_kills.unwrap_or(0)
    }

    fn get_roshan_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.roshan_kills
    }

    fn mut_roshan_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.roshan_kills
    }

    // optional float teamfight_participation = 16;

    pub fn clear_teamfight_participation(&mut self) {
        self.teamfight_participation = ::std::option::Option::None;
    }

    pub fn has_teamfight_participation(&self) -> bool {
        self.teamfight_participation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamfight_participation(&mut self, v: f32) {
        self.teamfight_participation = ::std::option::Option::Some(v);
    }

    pub fn get_teamfight_participation(&self) -> f32 {
        self.teamfight_participation.unwrap_or(0.)
    }

    fn get_teamfight_participation_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.teamfight_participation
    }

    fn mut_teamfight_participation_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.teamfight_participation
    }

    // optional uint32 wards_placed = 17;

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    pub fn get_wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    fn get_wards_placed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wards_placed
    }

    fn mut_wards_placed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wards_placed
    }

    // optional uint32 camps_stacked = 18;

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    pub fn get_camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    fn get_camps_stacked_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.camps_stacked
    }

    fn mut_camps_stacked_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.camps_stacked
    }

    // optional uint32 runes_grabbed = 19;

    pub fn clear_runes_grabbed(&mut self) {
        self.runes_grabbed = ::std::option::Option::None;
    }

    pub fn has_runes_grabbed(&self) -> bool {
        self.runes_grabbed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_grabbed(&mut self, v: u32) {
        self.runes_grabbed = ::std::option::Option::Some(v);
    }

    pub fn get_runes_grabbed(&self) -> u32 {
        self.runes_grabbed.unwrap_or(0)
    }

    fn get_runes_grabbed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.runes_grabbed
    }

    fn mut_runes_grabbed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.runes_grabbed
    }

    // optional uint32 first_blood = 20;

    pub fn clear_first_blood(&mut self) {
        self.first_blood = ::std::option::Option::None;
    }

    pub fn has_first_blood(&self) -> bool {
        self.first_blood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood(&mut self, v: u32) {
        self.first_blood = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood(&self) -> u32 {
        self.first_blood.unwrap_or(0)
    }

    fn get_first_blood_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood
    }

    fn mut_first_blood_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood
    }

    // optional float stuns = 21;

    pub fn clear_stuns(&mut self) {
        self.stuns = ::std::option::Option::None;
    }

    pub fn has_stuns(&self) -> bool {
        self.stuns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stuns(&mut self, v: f32) {
        self.stuns = ::std::option::Option::Some(v);
    }

    pub fn get_stuns(&self) -> f32 {
        self.stuns.unwrap_or(0.)
    }

    fn get_stuns_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.stuns
    }

    fn mut_stuns_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.stuns
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_completed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_type = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cs = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_kills = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.roshan_kills = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.teamfight_participation = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wards_placed = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.camps_stacked = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.runes_grabbed = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stuns = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_completed {
            my_size += 2;
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cs {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gpm {
            my_size += 5;
        }
        if let Some(v) = self.tower_kills {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.roshan_kills {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamfight_participation {
            my_size += 6;
        }
        if let Some(v) = self.wards_placed {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runes_grabbed {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stuns {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.match_completed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.delay {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.cs {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.tower_kills {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.roshan_kills {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.teamfight_participation {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.runes_grabbed {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.first_blood {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stuns {
            os.write_float(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerStats {
    fn new() -> CMsgDOTAFantasyPlayerStats {
        CMsgDOTAFantasyPlayerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyPlayerStats::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAFantasyPlayerStats::get_match_id_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "match_completed",
                    CMsgDOTAFantasyPlayerStats::get_match_completed_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_match_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAFantasyPlayerStats::get_team_id_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAFantasyPlayerStats::get_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "delay",
                    CMsgDOTAFantasyPlayerStats::get_delay_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_delay_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgDOTAFantasyPlayerStats::get_series_id_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_type",
                    CMsgDOTAFantasyPlayerStats::get_series_type_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_series_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgDOTAFantasyPlayerStats::get_kills_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgDOTAFantasyPlayerStats::get_deaths_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cs",
                    CMsgDOTAFantasyPlayerStats::get_cs_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_cs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gpm",
                    CMsgDOTAFantasyPlayerStats::get_gpm_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_kills",
                    CMsgDOTAFantasyPlayerStats::get_tower_kills_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_tower_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "roshan_kills",
                    CMsgDOTAFantasyPlayerStats::get_roshan_kills_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_roshan_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "teamfight_participation",
                    CMsgDOTAFantasyPlayerStats::get_teamfight_participation_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_teamfight_participation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wards_placed",
                    CMsgDOTAFantasyPlayerStats::get_wards_placed_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_wards_placed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "camps_stacked",
                    CMsgDOTAFantasyPlayerStats::get_camps_stacked_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_camps_stacked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "runes_grabbed",
                    CMsgDOTAFantasyPlayerStats::get_runes_grabbed_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_runes_grabbed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood",
                    CMsgDOTAFantasyPlayerStats::get_first_blood_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_first_blood_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stuns",
                    CMsgDOTAFantasyPlayerStats::get_stuns_for_reflect,
                    CMsgDOTAFantasyPlayerStats::mut_stuns_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerStats>(
                    "CMsgDOTAFantasyPlayerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerStats {
    fn clear(&mut self) {
        self.clear_player_account_id();
        self.clear_match_id();
        self.clear_match_completed();
        self.clear_team_id();
        self.clear_league_id();
        self.clear_delay();
        self.clear_series_id();
        self.clear_series_type();
        self.clear_kills();
        self.clear_deaths();
        self.clear_cs();
        self.clear_gpm();
        self.clear_tower_kills();
        self.clear_roshan_kills();
        self.clear_teamfight_participation();
        self.clear_wards_placed();
        self.clear_camps_stacked();
        self.clear_runes_grabbed();
        self.clear_first_blood();
        self.clear_stuns();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerMatchStats {
    // message fields
    matches: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerMatchStats {}

impl CMsgDOTAFantasyPlayerMatchStats {
    pub fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerMatchStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerMatchStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerMatchStats,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerMatchStats::new)
        }
    }

    // repeated .CMsgDOTAFantasyPlayerStats matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[CMsgDOTAFantasyPlayerStats] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStats> {
        &mut self.matches
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerMatchStats {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerMatchStats {
    fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        CMsgDOTAFantasyPlayerMatchStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerMatchStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerStats>>(
                    "matches",
                    CMsgDOTAFantasyPlayerMatchStats::get_matches_for_reflect,
                    CMsgDOTAFantasyPlayerMatchStats::mut_matches_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerMatchStats>(
                    "CMsgDOTAFantasyPlayerMatchStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerMatchStats {
    fn clear(&mut self) {
        self.clear_matches();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerMatchStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerMatchStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTABotDebugInfo {
    // message fields
    bots: ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot>,
    desire_push_lane_top: ::std::option::Option<f32>,
    desire_push_lane_mid: ::std::option::Option<f32>,
    desire_push_lane_bot: ::std::option::Option<f32>,
    desire_defend_lane_top: ::std::option::Option<f32>,
    desire_defend_lane_mid: ::std::option::Option<f32>,
    desire_defend_lane_bot: ::std::option::Option<f32>,
    desire_farm_lane_top: ::std::option::Option<f32>,
    desire_farm_lane_mid: ::std::option::Option<f32>,
    desire_farm_lane_bot: ::std::option::Option<f32>,
    desire_farm_roshan: ::std::option::Option<f32>,
    execution_time: ::std::option::Option<f32>,
    rune_status: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTABotDebugInfo {}

impl CMsgDOTABotDebugInfo {
    pub fn new() -> CMsgDOTABotDebugInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTABotDebugInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTABotDebugInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTABotDebugInfo,
        };
        unsafe {
            instance.get(CMsgDOTABotDebugInfo::new)
        }
    }

    // repeated .CMsgDOTABotDebugInfo.Bot bots = 1;

    pub fn clear_bots(&mut self) {
        self.bots.clear();
    }

    // Param is passed by value, moved
    pub fn set_bots(&mut self, v: ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot>) {
        self.bots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bots(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot> {
        &mut self.bots
    }

    // Take field
    pub fn take_bots(&mut self) -> ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot> {
        ::std::mem::replace(&mut self.bots, ::protobuf::RepeatedField::new())
    }

    pub fn get_bots(&self) -> &[CMsgDOTABotDebugInfo_Bot] {
        &self.bots
    }

    fn get_bots_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot> {
        &self.bots
    }

    fn mut_bots_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot> {
        &mut self.bots
    }

    // optional float desire_push_lane_top = 2;

    pub fn clear_desire_push_lane_top(&mut self) {
        self.desire_push_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_top(&self) -> bool {
        self.desire_push_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_top(&mut self, v: f32) {
        self.desire_push_lane_top = ::std::option::Option::Some(v);
    }

    pub fn get_desire_push_lane_top(&self) -> f32 {
        self.desire_push_lane_top.unwrap_or(0.)
    }

    fn get_desire_push_lane_top_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_push_lane_top
    }

    fn mut_desire_push_lane_top_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_push_lane_top
    }

    // optional float desire_push_lane_mid = 3;

    pub fn clear_desire_push_lane_mid(&mut self) {
        self.desire_push_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_mid(&self) -> bool {
        self.desire_push_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_mid(&mut self, v: f32) {
        self.desire_push_lane_mid = ::std::option::Option::Some(v);
    }

    pub fn get_desire_push_lane_mid(&self) -> f32 {
        self.desire_push_lane_mid.unwrap_or(0.)
    }

    fn get_desire_push_lane_mid_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_push_lane_mid
    }

    fn mut_desire_push_lane_mid_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_push_lane_mid
    }

    // optional float desire_push_lane_bot = 4;

    pub fn clear_desire_push_lane_bot(&mut self) {
        self.desire_push_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_bot(&self) -> bool {
        self.desire_push_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_bot(&mut self, v: f32) {
        self.desire_push_lane_bot = ::std::option::Option::Some(v);
    }

    pub fn get_desire_push_lane_bot(&self) -> f32 {
        self.desire_push_lane_bot.unwrap_or(0.)
    }

    fn get_desire_push_lane_bot_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_push_lane_bot
    }

    fn mut_desire_push_lane_bot_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_push_lane_bot
    }

    // optional float desire_defend_lane_top = 5;

    pub fn clear_desire_defend_lane_top(&mut self) {
        self.desire_defend_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_top(&self) -> bool {
        self.desire_defend_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_top(&mut self, v: f32) {
        self.desire_defend_lane_top = ::std::option::Option::Some(v);
    }

    pub fn get_desire_defend_lane_top(&self) -> f32 {
        self.desire_defend_lane_top.unwrap_or(0.)
    }

    fn get_desire_defend_lane_top_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_defend_lane_top
    }

    fn mut_desire_defend_lane_top_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_defend_lane_top
    }

    // optional float desire_defend_lane_mid = 6;

    pub fn clear_desire_defend_lane_mid(&mut self) {
        self.desire_defend_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_mid(&self) -> bool {
        self.desire_defend_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_mid(&mut self, v: f32) {
        self.desire_defend_lane_mid = ::std::option::Option::Some(v);
    }

    pub fn get_desire_defend_lane_mid(&self) -> f32 {
        self.desire_defend_lane_mid.unwrap_or(0.)
    }

    fn get_desire_defend_lane_mid_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_defend_lane_mid
    }

    fn mut_desire_defend_lane_mid_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_defend_lane_mid
    }

    // optional float desire_defend_lane_bot = 7;

    pub fn clear_desire_defend_lane_bot(&mut self) {
        self.desire_defend_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_bot(&self) -> bool {
        self.desire_defend_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_bot(&mut self, v: f32) {
        self.desire_defend_lane_bot = ::std::option::Option::Some(v);
    }

    pub fn get_desire_defend_lane_bot(&self) -> f32 {
        self.desire_defend_lane_bot.unwrap_or(0.)
    }

    fn get_desire_defend_lane_bot_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_defend_lane_bot
    }

    fn mut_desire_defend_lane_bot_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_defend_lane_bot
    }

    // optional float desire_farm_lane_top = 8;

    pub fn clear_desire_farm_lane_top(&mut self) {
        self.desire_farm_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_top(&self) -> bool {
        self.desire_farm_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_top(&mut self, v: f32) {
        self.desire_farm_lane_top = ::std::option::Option::Some(v);
    }

    pub fn get_desire_farm_lane_top(&self) -> f32 {
        self.desire_farm_lane_top.unwrap_or(0.)
    }

    fn get_desire_farm_lane_top_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_farm_lane_top
    }

    fn mut_desire_farm_lane_top_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_farm_lane_top
    }

    // optional float desire_farm_lane_mid = 9;

    pub fn clear_desire_farm_lane_mid(&mut self) {
        self.desire_farm_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_mid(&self) -> bool {
        self.desire_farm_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_mid(&mut self, v: f32) {
        self.desire_farm_lane_mid = ::std::option::Option::Some(v);
    }

    pub fn get_desire_farm_lane_mid(&self) -> f32 {
        self.desire_farm_lane_mid.unwrap_or(0.)
    }

    fn get_desire_farm_lane_mid_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_farm_lane_mid
    }

    fn mut_desire_farm_lane_mid_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_farm_lane_mid
    }

    // optional float desire_farm_lane_bot = 10;

    pub fn clear_desire_farm_lane_bot(&mut self) {
        self.desire_farm_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_bot(&self) -> bool {
        self.desire_farm_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_bot(&mut self, v: f32) {
        self.desire_farm_lane_bot = ::std::option::Option::Some(v);
    }

    pub fn get_desire_farm_lane_bot(&self) -> f32 {
        self.desire_farm_lane_bot.unwrap_or(0.)
    }

    fn get_desire_farm_lane_bot_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_farm_lane_bot
    }

    fn mut_desire_farm_lane_bot_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_farm_lane_bot
    }

    // optional float desire_farm_roshan = 11;

    pub fn clear_desire_farm_roshan(&mut self) {
        self.desire_farm_roshan = ::std::option::Option::None;
    }

    pub fn has_desire_farm_roshan(&self) -> bool {
        self.desire_farm_roshan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_roshan(&mut self, v: f32) {
        self.desire_farm_roshan = ::std::option::Option::Some(v);
    }

    pub fn get_desire_farm_roshan(&self) -> f32 {
        self.desire_farm_roshan.unwrap_or(0.)
    }

    fn get_desire_farm_roshan_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire_farm_roshan
    }

    fn mut_desire_farm_roshan_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire_farm_roshan
    }

    // optional float execution_time = 12;

    pub fn clear_execution_time(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time(&self) -> bool {
        self.execution_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_time(&mut self, v: f32) {
        self.execution_time = ::std::option::Option::Some(v);
    }

    pub fn get_execution_time(&self) -> f32 {
        self.execution_time.unwrap_or(0.)
    }

    fn get_execution_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.execution_time
    }

    fn mut_execution_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.execution_time
    }

    // repeated uint32 rune_status = 13;

    pub fn clear_rune_status(&mut self) {
        self.rune_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_rune_status(&mut self, v: ::std::vec::Vec<u32>) {
        self.rune_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rune_status(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.rune_status
    }

    // Take field
    pub fn take_rune_status(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.rune_status, ::std::vec::Vec::new())
    }

    pub fn get_rune_status(&self) -> &[u32] {
        &self.rune_status
    }

    fn get_rune_status_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.rune_status
    }

    fn mut_rune_status_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.rune_status
    }
}

impl ::protobuf::Message for CMsgDOTABotDebugInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.bots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bots)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_push_lane_top = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_push_lane_mid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_push_lane_bot = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_defend_lane_top = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_defend_lane_mid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_defend_lane_bot = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_farm_lane_top = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_farm_lane_mid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_farm_lane_bot = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire_farm_roshan = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.execution_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.rune_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.desire_push_lane_top {
            my_size += 5;
        }
        if let Some(v) = self.desire_push_lane_mid {
            my_size += 5;
        }
        if let Some(v) = self.desire_push_lane_bot {
            my_size += 5;
        }
        if let Some(v) = self.desire_defend_lane_top {
            my_size += 5;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            my_size += 5;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            my_size += 5;
        }
        if let Some(v) = self.desire_farm_lane_top {
            my_size += 5;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            my_size += 5;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            my_size += 5;
        }
        if let Some(v) = self.desire_farm_roshan {
            my_size += 5;
        }
        if let Some(v) = self.execution_time {
            my_size += 5;
        }
        for value in &self.rune_status {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bots {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.desire_push_lane_top {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.desire_push_lane_mid {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.desire_push_lane_bot {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.desire_defend_lane_top {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.desire_farm_lane_top {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.desire_farm_roshan {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.execution_time {
            os.write_float(12, v)?;
        }
        for v in &self.rune_status {
            os.write_uint32(13, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTABotDebugInfo {
    fn new() -> CMsgDOTABotDebugInfo {
        CMsgDOTABotDebugInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTABotDebugInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTABotDebugInfo_Bot>>(
                    "bots",
                    CMsgDOTABotDebugInfo::get_bots_for_reflect,
                    CMsgDOTABotDebugInfo::mut_bots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_push_lane_top",
                    CMsgDOTABotDebugInfo::get_desire_push_lane_top_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_push_lane_top_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_push_lane_mid",
                    CMsgDOTABotDebugInfo::get_desire_push_lane_mid_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_push_lane_mid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_push_lane_bot",
                    CMsgDOTABotDebugInfo::get_desire_push_lane_bot_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_push_lane_bot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_defend_lane_top",
                    CMsgDOTABotDebugInfo::get_desire_defend_lane_top_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_defend_lane_top_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_defend_lane_mid",
                    CMsgDOTABotDebugInfo::get_desire_defend_lane_mid_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_defend_lane_mid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_defend_lane_bot",
                    CMsgDOTABotDebugInfo::get_desire_defend_lane_bot_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_defend_lane_bot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_farm_lane_top",
                    CMsgDOTABotDebugInfo::get_desire_farm_lane_top_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_farm_lane_top_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_farm_lane_mid",
                    CMsgDOTABotDebugInfo::get_desire_farm_lane_mid_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_farm_lane_mid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_farm_lane_bot",
                    CMsgDOTABotDebugInfo::get_desire_farm_lane_bot_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_farm_lane_bot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire_farm_roshan",
                    CMsgDOTABotDebugInfo::get_desire_farm_roshan_for_reflect,
                    CMsgDOTABotDebugInfo::mut_desire_farm_roshan_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "execution_time",
                    CMsgDOTABotDebugInfo::get_execution_time_for_reflect,
                    CMsgDOTABotDebugInfo::mut_execution_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rune_status",
                    CMsgDOTABotDebugInfo::get_rune_status_for_reflect,
                    CMsgDOTABotDebugInfo::mut_rune_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTABotDebugInfo>(
                    "CMsgDOTABotDebugInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTABotDebugInfo {
    fn clear(&mut self) {
        self.clear_bots();
        self.clear_desire_push_lane_top();
        self.clear_desire_push_lane_mid();
        self.clear_desire_push_lane_bot();
        self.clear_desire_defend_lane_top();
        self.clear_desire_defend_lane_mid();
        self.clear_desire_defend_lane_bot();
        self.clear_desire_farm_lane_top();
        self.clear_desire_farm_lane_mid();
        self.clear_desire_farm_lane_bot();
        self.clear_desire_farm_roshan();
        self.clear_execution_time();
        self.clear_rune_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTABotDebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABotDebugInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTABotDebugInfo_Bot {
    // message fields
    player_owner_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    difficulty: ::std::option::Option<u32>,
    power_current: ::std::option::Option<u32>,
    power_max: ::std::option::Option<u32>,
    move_target_x: ::std::option::Option<u32>,
    move_target_y: ::std::option::Option<u32>,
    move_target_z: ::std::option::Option<u32>,
    active_mode_id: ::std::option::Option<u32>,
    execution_time: ::std::option::Option<f32>,
    modes: ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode>,
    action: ::protobuf::SingularPtrField<CMsgDOTABotDebugInfo_Bot_Action>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTABotDebugInfo_Bot {}

impl CMsgDOTABotDebugInfo_Bot {
    pub fn new() -> CMsgDOTABotDebugInfo_Bot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTABotDebugInfo_Bot {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTABotDebugInfo_Bot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTABotDebugInfo_Bot,
        };
        unsafe {
            instance.get(CMsgDOTABotDebugInfo_Bot::new)
        }
    }

    // optional uint32 player_owner_id = 1;

    pub fn clear_player_owner_id(&mut self) {
        self.player_owner_id = ::std::option::Option::None;
    }

    pub fn has_player_owner_id(&self) -> bool {
        self.player_owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_owner_id(&mut self, v: u32) {
        self.player_owner_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_owner_id(&self) -> u32 {
        self.player_owner_id.unwrap_or(0)
    }

    fn get_player_owner_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_owner_id
    }

    fn mut_player_owner_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_owner_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 difficulty = 3;

    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: u32) {
        self.difficulty = ::std::option::Option::Some(v);
    }

    pub fn get_difficulty(&self) -> u32 {
        self.difficulty.unwrap_or(0)
    }

    fn get_difficulty_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.difficulty
    }

    fn mut_difficulty_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.difficulty
    }

    // optional uint32 power_current = 4;

    pub fn clear_power_current(&mut self) {
        self.power_current = ::std::option::Option::None;
    }

    pub fn has_power_current(&self) -> bool {
        self.power_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_power_current(&mut self, v: u32) {
        self.power_current = ::std::option::Option::Some(v);
    }

    pub fn get_power_current(&self) -> u32 {
        self.power_current.unwrap_or(0)
    }

    fn get_power_current_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.power_current
    }

    fn mut_power_current_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.power_current
    }

    // optional uint32 power_max = 5;

    pub fn clear_power_max(&mut self) {
        self.power_max = ::std::option::Option::None;
    }

    pub fn has_power_max(&self) -> bool {
        self.power_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_power_max(&mut self, v: u32) {
        self.power_max = ::std::option::Option::Some(v);
    }

    pub fn get_power_max(&self) -> u32 {
        self.power_max.unwrap_or(0)
    }

    fn get_power_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.power_max
    }

    fn mut_power_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.power_max
    }

    // optional uint32 move_target_x = 6;

    pub fn clear_move_target_x(&mut self) {
        self.move_target_x = ::std::option::Option::None;
    }

    pub fn has_move_target_x(&self) -> bool {
        self.move_target_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_target_x(&mut self, v: u32) {
        self.move_target_x = ::std::option::Option::Some(v);
    }

    pub fn get_move_target_x(&self) -> u32 {
        self.move_target_x.unwrap_or(0)
    }

    fn get_move_target_x_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.move_target_x
    }

    fn mut_move_target_x_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.move_target_x
    }

    // optional uint32 move_target_y = 7;

    pub fn clear_move_target_y(&mut self) {
        self.move_target_y = ::std::option::Option::None;
    }

    pub fn has_move_target_y(&self) -> bool {
        self.move_target_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_target_y(&mut self, v: u32) {
        self.move_target_y = ::std::option::Option::Some(v);
    }

    pub fn get_move_target_y(&self) -> u32 {
        self.move_target_y.unwrap_or(0)
    }

    fn get_move_target_y_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.move_target_y
    }

    fn mut_move_target_y_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.move_target_y
    }

    // optional uint32 move_target_z = 8;

    pub fn clear_move_target_z(&mut self) {
        self.move_target_z = ::std::option::Option::None;
    }

    pub fn has_move_target_z(&self) -> bool {
        self.move_target_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_target_z(&mut self, v: u32) {
        self.move_target_z = ::std::option::Option::Some(v);
    }

    pub fn get_move_target_z(&self) -> u32 {
        self.move_target_z.unwrap_or(0)
    }

    fn get_move_target_z_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.move_target_z
    }

    fn mut_move_target_z_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.move_target_z
    }

    // optional uint32 active_mode_id = 9;

    pub fn clear_active_mode_id(&mut self) {
        self.active_mode_id = ::std::option::Option::None;
    }

    pub fn has_active_mode_id(&self) -> bool {
        self.active_mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_mode_id(&mut self, v: u32) {
        self.active_mode_id = ::std::option::Option::Some(v);
    }

    pub fn get_active_mode_id(&self) -> u32 {
        self.active_mode_id.unwrap_or(0)
    }

    fn get_active_mode_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.active_mode_id
    }

    fn mut_active_mode_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.active_mode_id
    }

    // optional float execution_time = 10;

    pub fn clear_execution_time(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time(&self) -> bool {
        self.execution_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_time(&mut self, v: f32) {
        self.execution_time = ::std::option::Option::Some(v);
    }

    pub fn get_execution_time(&self) -> f32 {
        self.execution_time.unwrap_or(0.)
    }

    fn get_execution_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.execution_time
    }

    fn mut_execution_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.execution_time
    }

    // repeated .CMsgDOTABotDebugInfo.Bot.Mode modes = 11;

    pub fn clear_modes(&mut self) {
        self.modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_modes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode>) {
        self.modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode> {
        &mut self.modes
    }

    // Take field
    pub fn take_modes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode> {
        ::std::mem::replace(&mut self.modes, ::protobuf::RepeatedField::new())
    }

    pub fn get_modes(&self) -> &[CMsgDOTABotDebugInfo_Bot_Mode] {
        &self.modes
    }

    fn get_modes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode> {
        &self.modes
    }

    fn mut_modes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTABotDebugInfo_Bot_Mode> {
        &mut self.modes
    }

    // optional .CMsgDOTABotDebugInfo.Bot.Action action = 12;

    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: CMsgDOTABotDebugInfo_Bot_Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut CMsgDOTABotDebugInfo_Bot_Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> CMsgDOTABotDebugInfo_Bot_Action {
        self.action.take().unwrap_or_else(|| CMsgDOTABotDebugInfo_Bot_Action::new())
    }

    pub fn get_action(&self) -> &CMsgDOTABotDebugInfo_Bot_Action {
        self.action.as_ref().unwrap_or_else(|| CMsgDOTABotDebugInfo_Bot_Action::default_instance())
    }

    fn get_action_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTABotDebugInfo_Bot_Action> {
        &self.action
    }

    fn mut_action_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTABotDebugInfo_Bot_Action> {
        &mut self.action
    }
}

impl ::protobuf::Message for CMsgDOTABotDebugInfo_Bot {
    fn is_initialized(&self) -> bool {
        for v in &self.modes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_owner_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.difficulty = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.power_current = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.power_max = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.move_target_x = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.move_target_y = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.move_target_z = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_mode_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.execution_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modes)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_owner_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.difficulty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.power_current {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.power_max {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.move_target_x {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.move_target_y {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.move_target_z {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_mode_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.execution_time {
            my_size += 5;
        }
        for value in &self.modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_owner_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.difficulty {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.power_current {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.power_max {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.move_target_x {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.move_target_y {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.move_target_z {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.active_mode_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.execution_time {
            os.write_float(10, v)?;
        }
        for v in &self.modes {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTABotDebugInfo_Bot {
    fn new() -> CMsgDOTABotDebugInfo_Bot {
        CMsgDOTABotDebugInfo_Bot::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTABotDebugInfo_Bot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_owner_id",
                    CMsgDOTABotDebugInfo_Bot::get_player_owner_id_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_player_owner_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTABotDebugInfo_Bot::get_hero_id_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "difficulty",
                    CMsgDOTABotDebugInfo_Bot::get_difficulty_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_difficulty_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "power_current",
                    CMsgDOTABotDebugInfo_Bot::get_power_current_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_power_current_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "power_max",
                    CMsgDOTABotDebugInfo_Bot::get_power_max_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_power_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "move_target_x",
                    CMsgDOTABotDebugInfo_Bot::get_move_target_x_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_move_target_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "move_target_y",
                    CMsgDOTABotDebugInfo_Bot::get_move_target_y_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_move_target_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "move_target_z",
                    CMsgDOTABotDebugInfo_Bot::get_move_target_z_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_move_target_z_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_mode_id",
                    CMsgDOTABotDebugInfo_Bot::get_active_mode_id_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_active_mode_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "execution_time",
                    CMsgDOTABotDebugInfo_Bot::get_execution_time_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_execution_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTABotDebugInfo_Bot_Mode>>(
                    "modes",
                    CMsgDOTABotDebugInfo_Bot::get_modes_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_modes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTABotDebugInfo_Bot_Action>>(
                    "action",
                    CMsgDOTABotDebugInfo_Bot::get_action_for_reflect,
                    CMsgDOTABotDebugInfo_Bot::mut_action_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTABotDebugInfo_Bot>(
                    "CMsgDOTABotDebugInfo_Bot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTABotDebugInfo_Bot {
    fn clear(&mut self) {
        self.clear_player_owner_id();
        self.clear_hero_id();
        self.clear_difficulty();
        self.clear_power_current();
        self.clear_power_max();
        self.clear_move_target_x();
        self.clear_move_target_y();
        self.clear_move_target_z();
        self.clear_active_mode_id();
        self.clear_execution_time();
        self.clear_modes();
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTABotDebugInfo_Bot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABotDebugInfo_Bot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTABotDebugInfo_Bot_Mode {
    // message fields
    mode_id: ::std::option::Option<u32>,
    desire: ::std::option::Option<f32>,
    target_entity: ::std::option::Option<u32>,
    target_x: ::std::option::Option<u32>,
    target_y: ::std::option::Option<u32>,
    target_z: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTABotDebugInfo_Bot_Mode {}

impl CMsgDOTABotDebugInfo_Bot_Mode {
    pub fn new() -> CMsgDOTABotDebugInfo_Bot_Mode {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTABotDebugInfo_Bot_Mode {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTABotDebugInfo_Bot_Mode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTABotDebugInfo_Bot_Mode,
        };
        unsafe {
            instance.get(CMsgDOTABotDebugInfo_Bot_Mode::new)
        }
    }

    // optional uint32 mode_id = 1;

    pub fn clear_mode_id(&mut self) {
        self.mode_id = ::std::option::Option::None;
    }

    pub fn has_mode_id(&self) -> bool {
        self.mode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_id(&mut self, v: u32) {
        self.mode_id = ::std::option::Option::Some(v);
    }

    pub fn get_mode_id(&self) -> u32 {
        self.mode_id.unwrap_or(0)
    }

    fn get_mode_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode_id
    }

    fn mut_mode_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode_id
    }

    // optional float desire = 2;

    pub fn clear_desire(&mut self) {
        self.desire = ::std::option::Option::None;
    }

    pub fn has_desire(&self) -> bool {
        self.desire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire(&mut self, v: f32) {
        self.desire = ::std::option::Option::Some(v);
    }

    pub fn get_desire(&self) -> f32 {
        self.desire.unwrap_or(0.)
    }

    fn get_desire_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.desire
    }

    fn mut_desire_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.desire
    }

    // optional uint32 target_entity = 3;

    pub fn clear_target_entity(&mut self) {
        self.target_entity = ::std::option::Option::None;
    }

    pub fn has_target_entity(&self) -> bool {
        self.target_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity(&mut self, v: u32) {
        self.target_entity = ::std::option::Option::Some(v);
    }

    pub fn get_target_entity(&self) -> u32 {
        self.target_entity.unwrap_or(0)
    }

    fn get_target_entity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_entity
    }

    fn mut_target_entity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_entity
    }

    // optional uint32 target_x = 4;

    pub fn clear_target_x(&mut self) {
        self.target_x = ::std::option::Option::None;
    }

    pub fn has_target_x(&self) -> bool {
        self.target_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_x(&mut self, v: u32) {
        self.target_x = ::std::option::Option::Some(v);
    }

    pub fn get_target_x(&self) -> u32 {
        self.target_x.unwrap_or(0)
    }

    fn get_target_x_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_x
    }

    fn mut_target_x_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_x
    }

    // optional uint32 target_y = 5;

    pub fn clear_target_y(&mut self) {
        self.target_y = ::std::option::Option::None;
    }

    pub fn has_target_y(&self) -> bool {
        self.target_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_y(&mut self, v: u32) {
        self.target_y = ::std::option::Option::Some(v);
    }

    pub fn get_target_y(&self) -> u32 {
        self.target_y.unwrap_or(0)
    }

    fn get_target_y_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_y
    }

    fn mut_target_y_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_y
    }

    // optional uint32 target_z = 6;

    pub fn clear_target_z(&mut self) {
        self.target_z = ::std::option::Option::None;
    }

    pub fn has_target_z(&self) -> bool {
        self.target_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_z(&mut self, v: u32) {
        self.target_z = ::std::option::Option::Some(v);
    }

    pub fn get_target_z(&self) -> u32 {
        self.target_z.unwrap_or(0)
    }

    fn get_target_z_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_z
    }

    fn mut_target_z_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_z
    }
}

impl ::protobuf::Message for CMsgDOTABotDebugInfo_Bot_Mode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desire = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_entity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desire {
            my_size += 5;
        }
        if let Some(v) = self.target_entity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_z {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.desire {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.target_entity {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_x {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.target_y {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_z {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTABotDebugInfo_Bot_Mode {
    fn new() -> CMsgDOTABotDebugInfo_Bot_Mode {
        CMsgDOTABotDebugInfo_Bot_Mode::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTABotDebugInfo_Bot_Mode>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode_id",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_mode_id_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_mode_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desire",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_desire_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_desire_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_entity",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_target_entity_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_target_entity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_x",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_target_x_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_target_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_y",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_target_y_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_target_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_z",
                    CMsgDOTABotDebugInfo_Bot_Mode::get_target_z_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Mode::mut_target_z_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTABotDebugInfo_Bot_Mode>(
                    "CMsgDOTABotDebugInfo_Bot_Mode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTABotDebugInfo_Bot_Mode {
    fn clear(&mut self) {
        self.clear_mode_id();
        self.clear_desire();
        self.clear_target_entity();
        self.clear_target_x();
        self.clear_target_y();
        self.clear_target_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTABotDebugInfo_Bot_Mode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABotDebugInfo_Bot_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTABotDebugInfo_Bot_Action {
    // message fields
    action_id: ::std::option::Option<u32>,
    action_target: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTABotDebugInfo_Bot_Action {}

impl CMsgDOTABotDebugInfo_Bot_Action {
    pub fn new() -> CMsgDOTABotDebugInfo_Bot_Action {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTABotDebugInfo_Bot_Action {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTABotDebugInfo_Bot_Action> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTABotDebugInfo_Bot_Action,
        };
        unsafe {
            instance.get(CMsgDOTABotDebugInfo_Bot_Action::new)
        }
    }

    // optional uint32 action_id = 1;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional string action_target = 2;

    pub fn clear_action_target(&mut self) {
        self.action_target.clear();
    }

    pub fn has_action_target(&self) -> bool {
        self.action_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_target(&mut self, v: ::std::string::String) {
        self.action_target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_target(&mut self) -> &mut ::std::string::String {
        if self.action_target.is_none() {
            self.action_target.set_default();
        }
        self.action_target.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_target(&mut self) -> ::std::string::String {
        self.action_target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_action_target(&self) -> &str {
        match self.action_target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_action_target_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.action_target
    }

    fn mut_action_target_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.action_target
    }
}

impl ::protobuf::Message for CMsgDOTABotDebugInfo_Bot_Action {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action_target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.action_target.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.action_target.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTABotDebugInfo_Bot_Action {
    fn new() -> CMsgDOTABotDebugInfo_Bot_Action {
        CMsgDOTABotDebugInfo_Bot_Action::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTABotDebugInfo_Bot_Action>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgDOTABotDebugInfo_Bot_Action::get_action_id_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Action::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "action_target",
                    CMsgDOTABotDebugInfo_Bot_Action::get_action_target_for_reflect,
                    CMsgDOTABotDebugInfo_Bot_Action::mut_action_target_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTABotDebugInfo_Bot_Action>(
                    "CMsgDOTABotDebugInfo_Bot_Action",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTABotDebugInfo_Bot_Action {
    fn clear(&mut self) {
        self.clear_action_id();
        self.clear_action_target();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTABotDebugInfo_Bot_Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTABotDebugInfo_Bot_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESpecialPingValue {
    k_ESpecialPingValue_NoData = 16382,
    k_ESpecialPingValue_Failed = 16383,
}

impl ::protobuf::ProtobufEnum for ESpecialPingValue {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESpecialPingValue> {
        match value {
            16382 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_NoData),
            16383 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESpecialPingValue] = &[
            ESpecialPingValue::k_ESpecialPingValue_NoData,
            ESpecialPingValue::k_ESpecialPingValue_Failed,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ESpecialPingValue>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ESpecialPingValue", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ESpecialPingValue {
}

impl ::protobuf::reflect::ProtobufValue for ESpecialPingValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDOTAGCSessionNeed {
    k_EDOTAGCSessionNeed_Unknown = 0,
    k_EDOTAGCSessionNeed_UserNoSessionNeeded = 100,
    k_EDOTAGCSessionNeed_UserInOnlineGame = 101,
    k_EDOTAGCSessionNeed_UserInLocalGame = 102,
    k_EDOTAGCSessionNeed_UserInUIWasConnected = 103,
    k_EDOTAGCSessionNeed_UserInUINeverConnected = 104,
    k_EDOTAGCSessionNeed_UserTutorials = 105,
    k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle = 106,
    k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle = 107,
    k_EDOTAGCSessionNeed_GameServerOnline = 200,
    k_EDOTAGCSessionNeed_GameServerLocal = 201,
    k_EDOTAGCSessionNeed_GameServerIdle = 202,
    k_EDOTAGCSessionNeed_GameServerRelay = 203,
    k_EDOTAGCSessionNeed_GameServerLocalUpload = 204,
}

impl ::protobuf::ProtobufEnum for EDOTAGCSessionNeed {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAGCSessionNeed> {
        match value {
            0 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown),
            100 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded),
            101 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame),
            102 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame),
            103 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected),
            104 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected),
            105 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials),
            106 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle),
            107 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle),
            200 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline),
            201 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal),
            202 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle),
            203 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay),
            204 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDOTAGCSessionNeed] = &[
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay,
            EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDOTAGCSessionNeed>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDOTAGCSessionNeed", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDOTAGCSessionNeed {
}

impl ::protobuf::reflect::ProtobufValue for EDOTAGCSessionNeed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_TournamentEvents {
    TE_FIRST_BLOOD = 0,
    TE_GAME_END = 1,
    TE_MULTI_KILL = 2,
    TE_HERO_DENY = 3,
    TE_AEGIS_DENY = 4,
    TE_AEGIS_STOLEN = 5,
    TE_GODLIKE = 6,
    TE_COURIER_KILL = 7,
    TE_ECHOSLAM = 8,
    TE_RAPIER = 9,
    TE_EARLY_ROSHAN = 10,
    TE_BLACK_HOLE = 11,
}

impl ::protobuf::ProtobufEnum for DOTA_TournamentEvents {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_TournamentEvents> {
        match value {
            0 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_FIRST_BLOOD),
            1 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GAME_END),
            2 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_MULTI_KILL),
            3 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_HERO_DENY),
            4 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_DENY),
            5 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_STOLEN),
            6 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GODLIKE),
            7 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_COURIER_KILL),
            8 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_ECHOSLAM),
            9 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_RAPIER),
            10 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_EARLY_ROSHAN),
            11 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_BLACK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_TournamentEvents] = &[
            DOTA_TournamentEvents::TE_FIRST_BLOOD,
            DOTA_TournamentEvents::TE_GAME_END,
            DOTA_TournamentEvents::TE_MULTI_KILL,
            DOTA_TournamentEvents::TE_HERO_DENY,
            DOTA_TournamentEvents::TE_AEGIS_DENY,
            DOTA_TournamentEvents::TE_AEGIS_STOLEN,
            DOTA_TournamentEvents::TE_GODLIKE,
            DOTA_TournamentEvents::TE_COURIER_KILL,
            DOTA_TournamentEvents::TE_ECHOSLAM,
            DOTA_TournamentEvents::TE_RAPIER,
            DOTA_TournamentEvents::TE_EARLY_ROSHAN,
            DOTA_TournamentEvents::TE_BLACK_HOLE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_TournamentEvents>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_TournamentEvents", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_TournamentEvents {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_TournamentEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_COMBATLOG_TYPES {
    DOTA_COMBATLOG_INVALID = -1,
    DOTA_COMBATLOG_DAMAGE = 0,
    DOTA_COMBATLOG_HEAL = 1,
    DOTA_COMBATLOG_MODIFIER_ADD = 2,
    DOTA_COMBATLOG_MODIFIER_REMOVE = 3,
    DOTA_COMBATLOG_DEATH = 4,
    DOTA_COMBATLOG_ABILITY = 5,
    DOTA_COMBATLOG_ITEM = 6,
    DOTA_COMBATLOG_LOCATION = 7,
    DOTA_COMBATLOG_GOLD = 8,
    DOTA_COMBATLOG_GAME_STATE = 9,
    DOTA_COMBATLOG_XP = 10,
    DOTA_COMBATLOG_PURCHASE = 11,
    DOTA_COMBATLOG_BUYBACK = 12,
    DOTA_COMBATLOG_ABILITY_TRIGGER = 13,
    DOTA_COMBATLOG_PLAYERSTATS = 14,
    DOTA_COMBATLOG_MULTIKILL = 15,
    DOTA_COMBATLOG_KILLSTREAK = 16,
    DOTA_COMBATLOG_TEAM_BUILDING_KILL = 17,
    DOTA_COMBATLOG_FIRST_BLOOD = 18,
    DOTA_COMBATLOG_MODIFIER_REFRESH = 19,
    DOTA_COMBATLOG_NEUTRAL_CAMP_STACK = 20,
    DOTA_COMBATLOG_PICKUP_RUNE = 21,
    DOTA_COMBATLOG_REVEALED_INVISIBLE = 22,
    DOTA_COMBATLOG_HERO_SAVED = 23,
    DOTA_COMBATLOG_MANA_RESTORED = 24,
    DOTA_COMBATLOG_HERO_LEVELUP = 25,
    DOTA_COMBATLOG_BOTTLE_HEAL_ALLY = 26,
    DOTA_COMBATLOG_ENDGAME_STATS = 27,
    DOTA_COMBATLOG_INTERRUPT_CHANNEL = 28,
    DOTA_COMBATLOG_ALLIED_GOLD = 29,
    DOTA_COMBATLOG_AEGIS_TAKEN = 30,
    DOTA_COMBATLOG_MANA_DAMAGE = 31,
    DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED = 32,
    DOTA_COMBATLOG_UNIT_SUMMONED = 33,
    DOTA_COMBATLOG_ATTACK_EVADE = 34,
    DOTA_COMBATLOG_TREE_CUT = 35,
    DOTA_COMBATLOG_SUCCESSFUL_SCAN = 36,
    DOTA_COMBATLOG_END_KILLSTREAK = 37,
    DOTA_COMBATLOG_BLOODSTONE_CHARGE = 38,
    DOTA_COMBATLOG_CRITICAL_DAMAGE = 39,
    DOTA_COMBATLOG_SPELL_ABSORB = 40,
}

impl ::protobuf::ProtobufEnum for DOTA_COMBATLOG_TYPES {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_COMBATLOG_TYPES> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID),
            0 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE),
            1 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL),
            2 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD),
            3 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE),
            4 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH),
            5 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY),
            6 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM),
            7 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION),
            8 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD),
            9 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE),
            10 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP),
            11 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE),
            12 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK),
            13 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER),
            14 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS),
            15 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL),
            16 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK),
            17 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL),
            18 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD),
            19 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REFRESH),
            20 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK),
            21 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE),
            22 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE),
            23 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED),
            24 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED),
            25 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP),
            26 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY),
            27 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS),
            28 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL),
            29 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD),
            30 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN),
            31 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE),
            32 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED),
            33 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED),
            34 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE),
            35 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT),
            36 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN),
            37 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK),
            38 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE),
            39 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE),
            40 => ::std::option::Option::Some(DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_COMBATLOG_TYPES] = &[
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INVALID,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DAMAGE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HEAL,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_ADD,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REMOVE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_DEATH,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ITEM,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_LOCATION,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GOLD,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_GAME_STATE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_XP,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PURCHASE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BUYBACK,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ABILITY_TRIGGER,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PLAYERSTATS,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MULTIKILL,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_KILLSTREAK,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TEAM_BUILDING_KILL,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_FIRST_BLOOD,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MODIFIER_REFRESH,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_NEUTRAL_CAMP_STACK,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PICKUP_RUNE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_REVEALED_INVISIBLE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_SAVED,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_RESTORED,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_HERO_LEVELUP,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BOTTLE_HEAL_ALLY,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ENDGAME_STATS,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_INTERRUPT_CHANNEL,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ALLIED_GOLD,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_AEGIS_TAKEN,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_MANA_DAMAGE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_UNIT_SUMMONED,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_ATTACK_EVADE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_TREE_CUT,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SUCCESSFUL_SCAN,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_END_KILLSTREAK,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_BLOODSTONE_CHARGE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_CRITICAL_DAMAGE,
            DOTA_COMBATLOG_TYPES::DOTA_COMBATLOG_SPELL_ABSORB,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_COMBATLOG_TYPES>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_COMBATLOG_TYPES", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_COMBATLOG_TYPES {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_COMBATLOG_TYPES {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_common.proto\x1a\x13steammessages.proto\x1a\x16gcs\
    dk_gcmessages.proto\x1a\x17dota_shared_enums.proto\"\xce\x1d\n\x18CSODOT\
    AGameAccountClient\x12#\n\naccount_id\x18\x01\x20\x01(\rR\taccountIdB\
    \x04\x80\xa6\x1d\x01\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04wins\x12\
    \x16\n\x06losses\x18\x04\x20\x01(\rR\x06losses\x12\x0e\n\x02xp\x18\x0c\
    \x20\x01(\rR\x02xp\x12\x14\n\x05level\x18\r\x20\x01(\rR\x05level\x12#\n\
    \rinitial_skill\x18\x0e\x20\x01(\rR\x0cinitialSkill\x12!\n\x0cleaver_cou\
    nt\x18\x0f\x20\x01(\rR\x0bleaverCount\x124\n\x16secondary_leaver_count\
    \x18:\x20\x01(\rR\x14secondaryLeaverCount\x125\n\x17low_priority_until_d\
    ate\x18\x12\x20\x01(\rR\x14lowPriorityUntilDate\x12>\n\x1cprevent_text_c\
    hat_until_date\x18\x14\x20\x01(\rR\x18preventTextChatUntilDate\x127\n\
    \x18prevent_voice_until_date\x18\x15\x20\x01(\rR\x15preventVoiceUntilDat\
    e\x12K\n#prevent_public_text_chat_until_date\x18V\x20\x01(\rR\x1eprevent\
    PublicTextChatUntilDate\x127\n\x18last_abandoned_game_date\x18\x16\x20\
    \x01(\rR\x15lastAbandonedGameDate\x12J\n\"last_secondary_abandoned_game_\
    date\x18;\x20\x01(\rR\x1elastSecondaryAbandonedGameDate\x120\n\x14leaver\
    _penalty_count\x18\x17\x20\x01(\rR\x12leaverPenaltyCount\x122\n\x15compl\
    eted_game_streak\x18\x18\x20\x01(\rR\x13completedGameStreak\x12\x1a\n\
    \x08teaching\x18\x1c\x20\x01(\rR\x08teaching\x12\x1e\n\nleadership\x18\
    \x1d\x20\x01(\rR\nleadership\x12\x1a\n\x08friendly\x18\x1e\x20\x01(\rR\
    \x08friendly\x12\x1c\n\tforgiving\x18\x1f\x20\x01(\rR\tforgiving\x12=\n\
    \x1baccount_disabled_until_date\x18&\x20\x01(\rR\x18accountDisabledUntil\
    Date\x124\n\x16account_disabled_count\x18'\x20\x01(\rR\x14accountDisable\
    dCount\x12(\n\x10showcase_hero_id\x18(\x20\x01(\rR\x0eshowcaseHeroId\x12\
    9\n\x19match_disabled_until_date\x18)\x20\x01(\rR\x16matchDisabledUntilD\
    ate\x120\n\x14match_disabled_count\x18*\x20\x01(\rR\x12matchDisabledCoun\
    t\x12S\n\x14partner_account_type\x18,\x20\x01(\x0e2\x13.PartnerAccountTy\
    pe:\x0cPARTNER_NONER\x12partnerAccountType\x122\n\x15partner_account_sta\
    te\x18-\x20\x01(\rR\x13partnerAccountState\x12D\n\x1dshutdownlawterminat\
    etimestamp\x18/\x20\x01(\rR\x1dshutdownlawterminatetimestamp\x12?\n\x1cl\
    ow_priority_games_remaining\x180\x20\x01(\rR\x19lowPriorityGamesRemainin\
    g\x12)\n\x10competitive_rank\x181\x20\x01(\rR\x0fcompetitiveRank\x12>\n\
    \x1bcalibration_games_remaining\x183\x20\x01(\rR\x19calibrationGamesRema\
    ining\x122\n\x15solo_competitive_rank\x184\x20\x01(\rR\x13soloCompetitiv\
    eRank\x12G\n\x20solo_calibration_games_remaining\x186\x20\x01(\rR\x1dsol\
    oCalibrationGamesRemaining\x12+\n\x11recruitment_level\x187\x20\x01(\rR\
    \x10recruitmentLevel\x122\n\x15has_new_notifications\x188\x20\x01(\x08R\
    \x13hasNewNotifications\x12&\n\x0fis_league_admin\x189\x20\x01(\x08R\ris\
    LeagueAdmin\x12.\n\x13casual_games_played\x18<\x20\x01(\rR\x11casualGame\
    sPlayed\x12A\n\x1dsolo_competitive_games_played\x18=\x20\x01(\rR\x1asolo\
    CompetitiveGamesPlayed\x12C\n\x1eparty_competitive_games_played\x18>\x20\
    \x01(\rR\x1bpartyCompetitiveGamesPlayed\x125\n\x17casual_1v1_games_playe\
    d\x18A\x20\x01(\rR\x14casual1v1GamesPlayed\x12A\n\x1dcompetitive_team_ga\
    mes_played\x18B\x20\x01(\rR\x1acompetitiveTeamGamesPlayed\x12:\n\x1acurr\
    _all_hero_challenge_id\x18C\x20\x01(\rR\x16currAllHeroChallengeId\x12(\n\
    \x10play_time_points\x18D\x20\x01(\rR\x0eplayTimePoints\x12#\n\raccount_\
    flags\x18E\x20\x01(\rR\x0caccountFlags\x12&\n\x0fplay_time_level\x18F\
    \x20\x01(\rR\rplayTimeLevel\x12K\n#player_behavior_seq_num_last_report\
    \x18G\x20\x01(\rR\x1eplayerBehaviorSeqNumLastReport\x12H\n!player_behavi\
    or_score_last_report\x18H\x20\x01(\rR\x1dplayerBehaviorScoreLastReport\
    \x12D\n\x1fplayer_behavior_report_old_data\x18I\x20\x01(\x08R\x1bplayerB\
    ehaviorReportOldData\x12.\n\x13tourney_skill_level\x18J\x20\x01(\rR\x11t\
    ourneySkillLevel\x12I\n!tourney_recent_participation_date\x18U\x20\x01(\
    \rR\x1etourneyRecentParticipationDate\x12#\n\rfavorite_team\x18W\x20\x01\
    (\rR\x0cfavoriteTeam\x127\n\x18anchored_phone_number_id\x18X\x20\x01(\
    \x04R\x15anchoredPhoneNumberId\x12H\n!ranked_matchmaking_ban_until_date\
    \x18Y\x20\x01(\rR\x1drankedMatchmakingBanUntilDate\x12+\n\x12recent_game\
    _time_1\x18Z\x20\x01(\rR\x0frecentGameTime1\x12+\n\x12recent_game_time_2\
    \x18[\x20\x01(\rR\x0frecentGameTime2\x12+\n\x12recent_game_time_3\x18\\\
    \x20\x01(\rR\x0frecentGameTime3\x12?\n\x1cgeneral_seasonal_ranked_rank\
    \x18]\x20\x01(\rR\x19generalSeasonalRankedRank\x12k\n3general_seasonal_r\
    anked_calibration_games_remaining\x18^\x20\x01(\rR.generalSeasonalRanked\
    CalibrationGamesRemaining\x12N\n$general_seasonal_ranked_games_played\
    \x18_\x20\x01(\rR\x20generalSeasonalRankedGamesPlayed\x12H\n!general_sea\
    sonal_ranked_rank_peak\x18`\x20\x01(\rR\x1dgeneralSeasonalRankedRankPeak\
    \x12I\n!general_seasonal_rank_transferred\x18a\x20\x01(\x08R\x1egeneralS\
    easonalRankTransferred\x129\n\x19solo_seasonal_ranked_rank\x18b\x20\x01(\
    \rR\x16soloSeasonalRankedRank\x12e\n0solo_seasonal_ranked_calibration_ga\
    mes_remaining\x18c\x20\x01(\rR+soloSeasonalRankedCalibrationGamesRemaini\
    ng\x12H\n!solo_seasonal_ranked_games_played\x18d\x20\x01(\rR\x1dsoloSeas\
    onalRankedGamesPlayed\x12B\n\x1esolo_seasonal_ranked_rank_peak\x18e\x20\
    \x01(\rR\x1asoloSeasonalRankedRankPeak\x12C\n\x1esolo_seasonal_rank_tran\
    sferred\x18f\x20\x01(\x08R\x1bsoloSeasonalRankTransferred\x120\n\x14favo\
    rite_team_packed\x18g\x20\x01(\x04R\x12favoriteTeamPacked\x12,\n\x12rece\
    nt_report_time\x18h\x20\x01(\rR\x10recentReportTime\"\xd3\x07\n\x14CMsgL\
    obbyEventPoints\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12\
    J\n\x0eaccount_points\x18\x02\x20\x03(\x0b2#.CMsgLobbyEventPoints.Accoun\
    tPointsR\raccountPoints\x1ag\n\x15ChatWheelMessageRange\x12(\n\x10messag\
    e_id_start\x18\x01\x20\x01(\rR\x0emessageIdStart\x12$\n\x0emessage_id_en\
    d\x18\x02\x20\x01(\rR\x0cmessageIdEnd\x1a\xea\x05\n\rAccountPoints\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12#\n\rnormal_points\
    \x18\x02\x20\x01(\rR\x0cnormalPoints\x12%\n\x0epremium_points\x18\x03\
    \x20\x01(\rR\rpremiumPoints\x12\x14\n\x05owned\x18\x04\x20\x01(\x08R\x05\
    owned\x12#\n\rfavorite_team\x18\x05\x20\x01(\rR\x0cfavoriteTeam\x12.\n\
    \x13favorite_team_level\x18\x06\x20\x01(\rR\x11favoriteTeamLevel\x12\x1f\
    \n\x0bpoints_held\x18\x07\x20\x01(\rR\npointsHeld\x12.\n\x13premium_poin\
    ts_held\x18\x08\x20\x01(\rR\x11premiumPointsHeld\x127\n\x18favorite_team\
    _foil_level\x18\t\x20\x01(\rR\x15favoriteTeamFoilLevel\x124\n\x16wager_t\
    okens_remaining\x18\n\x20\x01(\rR\x14wagerTokensRemaining\x12(\n\x10wage\
    r_tokens_max\x18\x0b\x20\x01(\rR\x0ewagerTokensMax\x12.\n\x13active_effe\
    cts_mask\x18\x0c\x20\x01(\x04R\x11activeEffectsMask\x12w\n\"unlocked_cha\
    t_wheel_message_ranges\x18\r\x20\x03(\x0b2+.CMsgLobbyEventPoints.ChatWhe\
    elMessageRangeR\x1eunlockedChatWheelMessageRanges\x12=\n\x1brank_wager_t\
    okens_remaining\x18\x0e\x20\x01(\rR\x18rankWagerTokensRemaining\x121\n\
    \x15rank_wager_tokens_max\x18\x0f\x20\x01(\rR\x12rankWagerTokensMax\"\
    \xa6\x02\n\x14CMsgBattleCupVictory\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12\x19\n\x08win_date\x18\x02\x20\x01(\rR\x07winDate\x12\
    \x1f\n\x0bvalid_until\x18\x03\x20\x01(\rR\nvalidUntil\x12\x1f\n\x0bskill\
    _level\x18\x04\x20\x01(\rR\nskillLevel\x12#\n\rtournament_id\x18\x05\x20\
    \x01(\rR\x0ctournamentId\x12\x1f\n\x0bdivision_id\x18\x06\x20\x01(\rR\nd\
    ivisionId\x12\x17\n\x07team_id\x18\x07\x20\x01(\rR\x06teamId\x12\x16\n\
    \x06streak\x18\x08\x20\x01(\rR\x06streak\x12\x1b\n\ttrophy_id\x18\t\x20\
    \x01(\rR\x08trophyId\"P\n\x1dCMsgLobbyBattleCupVictoryList\x12/\n\x07win\
    ners\x18\x01\x20\x03(\x0b2\x15.CMsgBattleCupVictoryR\x07winners\"9\n\x1d\
    CMsgDOTABroadcastNotification\x12\x18\n\x07message\x18\x01\x20\x01(\tR\
    \x07message\"\x97\x02\n\x14CProtoItemHeroStatue\x12\x17\n\x07hero_id\x18\
    \x01\x20\x01(\rR\x06heroId\x12.\n\x13status_effect_index\x18\x02\x20\x01\
    (\rR\x11statusEffectIndex\x12#\n\rsequence_name\x18\x03\x20\x01(\tR\x0cs\
    equenceName\x12\x14\n\x05cycle\x18\x04\x20\x01(\x02R\x05cycle\x12\x1a\n\
    \x08wearable\x18\x05\x20\x03(\rR\x08wearable\x12\x20\n\x0binscription\
    \x18\x06\x20\x01(\tR\x0binscription\x12\x14\n\x05style\x18\x07\x20\x03(\
    \rR\x05style\x12'\n\x0ftournament_drop\x18\x08\x20\x01(\x08R\x0etourname\
    ntDrop\"\xf0\x01\n\x16CProtoItemTeamShowcase\x12\x17\n\x07hero_id\x18\
    \x01\x20\x01(\rR\x06heroId\x12.\n\x13status_effect_index\x18\x02\x20\x01\
    (\rR\x11statusEffectIndex\x12#\n\rsequence_name\x18\x03\x20\x01(\tR\x0cs\
    equenceName\x12\x14\n\x05cycle\x18\x04\x20\x01(\x02R\x05cycle\x12\x1a\n\
    \x08wearable\x18\x05\x20\x03(\rR\x08wearable\x12\x20\n\x0binscription\
    \x18\x06\x20\x01(\tR\x0binscription\x12\x14\n\x05style\x18\x07\x20\x03(\
    \rR\x05style\"J\n\x1aCMatchPlayerAbilityUpgrade\x12\x18\n\x07ability\x18\
    \x01\x20\x01(\rR\x07ability\x12\x12\n\x04time\x18\x02\x20\x01(\rR\x04tim\
    e\"R\n\x1dCMatchAdditionalUnitInventory\x12\x1b\n\tunit_name\x18\x01\x20\
    \x01(\tR\x08unitName\x12\x14\n\x05items\x18\x02\x20\x03(\rR\x05items\"c\
    \n\x19CMatchPlayerPermanentBuff\x12%\n\x0epermanent_buff\x18\x01\x20\x01\
    (\rR\rpermanentBuff\x12\x1f\n\x0bstack_count\x18\x02\x20\x01(\rR\nstackC\
    ount\"]\n\x15CMatchHeroSelectEvent\x12\x17\n\x07is_pick\x18\x01\x20\x01(\
    \x08R\x06isPick\x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04team\x12\x17\n\
    \x07hero_id\x18\x03\x20\x01(\rR\x06heroId\"\xc5\x01\n$CMsgDOTAProcessFan\
    tasyScheduledEvent\x12\x14\n\x05event\x18\x01\x20\x01(\rR\x05event\x12\
    \x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12*\n\x11fantasy_leagu\
    e_id\x18\x03\x20\x01(\rR\x0ffantasyLeagueId\x12\x16\n\x06season\x18\x04\
    \x20\x01(\rR\x06season\x12%\n\x0ereference_data\x18\x05\x20\x01(\rR\rref\
    erenceData\"N\n\x14CMsgDOTAHasItemQuery\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06it\
    emId\"4\n\x17CMsgDOTAHasItemResponse\x12\x19\n\x08has_item\x18\x01\x20\
    \x01(\x08R\x07hasItem\"1\n\x10CMsgGCIsProQuery\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\",\n\x13CMsgGCIsProResponse\x12\x15\n\x06is_\
    pro\x18\x01\x20\x01(\x08R\x05isPro\"Z\n\x18CMsgDOTAHasItemDefsQuery\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bitemdef_i\
    ds\x18\x02\x20\x03(\rR\nitemdefIds\":\n\x1bCMsgDOTAHasItemDefsResponse\
    \x12\x1b\n\thas_items\x18\x01\x20\x01(\x08R\x08hasItems\"m\n\x1bCMsgGCGe\
    tPlayerCardItemInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12/\n\x14player_card_item_ids\x18\x02\x20\x03(\x04R\x11playerCardItemI\
    ds\"\x8e\x02\n#CMsgGCGetPlayerCardItemInfoResponse\x12_\n\x11player_card\
    _infos\x18\x01\x20\x03(\x0b23.CMsgGCGetPlayerCardItemInfoResponse.Player\
    CardInfoR\x0fplayerCardInfos\x1a\x85\x01\n\x0ePlayerCardInfo\x12-\n\x13p\
    layer_card_item_id\x18\x01\x20\x01(\x04R\x10playerCardItemId\x12\x1d\n\n\
    account_id\x18\x02\x20\x01(\rR\taccountId\x12%\n\x0epacked_bonuses\x18\
    \x03\x20\x01(\x04R\rpackedBonuses\"Y\n\x1fCMsgGCToGCFantasySetMatchLeagu\
    e\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\tleag\
    ue_id\x18\x02\x20\x01(\rR\x08leagueId\"\x83\x01\n\x17CSODOTAMapLocationS\
    tate\x12#\n\naccount_id\x18\x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\
    \x01\x12%\n\x0blocation_id\x18\x02\x20\x01(\x05R\nlocationIdB\x04\x80\
    \xa6\x1d\x01\x12\x1c\n\tcompleted\x18\x03\x20\x01(\x08R\tcompleted\"6\n\
    \x13CMsgLeagueAdminList\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\nac\
    countIds\"\xb2\x01\n\x1aCCompendiumTimestampedData\x12\x1b\n\tgame_time\
    \x18\x01\x20\x01(\rR\x08gameTime\x12\x10\n\x03gpm\x18\x02\x20\x01(\rR\
    \x03gpm\x12\x10\n\x03xpm\x18\x03\x20\x01(\rR\x03xpm\x12\x14\n\x05kills\
    \x18\x04\x20\x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x05\x20\x01(\rR\
    \x06deaths\x12%\n\x0eitem_purchases\x18\x06\x20\x03(\rR\ritemPurchases\"\
    ^\n\x17CCompendiumGameTimeline\x12/\n\x04data\x18\x01\x20\x03(\x0b2\x1b.\
    CCompendiumTimestampedDataR\x04data\x12\x12\n\x04tags\x18\x02\x20\x03(\t\
    R\x04tags\"E\n\x13CCompendiumGameList\x12.\n\x05games\x18\x01\x20\x03(\
    \x0b2\x18.CCompendiumGameTimelineR\x05games\"g\n\x14CAdditionalEquipSlot\
    \x12\x19\n\x08class_id\x18\x01\x20\x01(\rR\x07classId\x12\x17\n\x07slot_\
    id\x18\x02\x20\x01(\rR\x06slotId\x12\x1b\n\tdef_index\x18\x03\x20\x01(\r\
    R\x08defIndex\"\xa6\x15\n\x16CMsgDOTACombatLogEntry\x12A\n\x04type\x18\
    \x01\x20\x01(\x0e2\x15.DOTA_COMBATLOG_TYPES:\x16DOTA_COMBATLOG_INVALIDR\
    \x04type\x12\x1f\n\x0btarget_name\x18\x02\x20\x01(\rR\ntargetName\x12,\n\
    \x12target_source_name\x18\x03\x20\x01(\rR\x10targetSourceName\x12#\n\ra\
    ttacker_name\x18\x04\x20\x01(\rR\x0cattackerName\x12,\n\x12damage_source\
    _name\x18\x05\x20\x01(\rR\x10damageSourceName\x12%\n\x0einflictor_name\
    \x18\x06\x20\x01(\rR\rinflictorName\x120\n\x14is_attacker_illusion\x18\
    \x07\x20\x01(\x08R\x12isAttackerIllusion\x12(\n\x10is_attacker_hero\x18\
    \x08\x20\x01(\x08R\x0eisAttackerHero\x12,\n\x12is_target_illusion\x18\t\
    \x20\x01(\x08R\x10isTargetIllusion\x12$\n\x0eis_target_hero\x18\n\x20\
    \x01(\x08R\x0cisTargetHero\x12,\n\x12is_visible_radiant\x18\x0b\x20\x01(\
    \x08R\x10isVisibleRadiant\x12&\n\x0fis_visible_dire\x18\x0c\x20\x01(\x08\
    R\risVisibleDire\x12\x14\n\x05value\x18\r\x20\x01(\rR\x05value\x12\x16\n\
    \x06health\x18\x0e\x20\x01(\x05R\x06health\x12\x1c\n\ttimestamp\x18\x0f\
    \x20\x01(\x02R\ttimestamp\x12#\n\rstun_duration\x18\x10\x20\x01(\x02R\
    \x0cstunDuration\x12#\n\rslow_duration\x18\x11\x20\x01(\x02R\x0cslowDura\
    tion\x12/\n\x14is_ability_toggle_on\x18\x12\x20\x01(\x08R\x11isAbilityTo\
    ggleOn\x121\n\x15is_ability_toggle_off\x18\x13\x20\x01(\x08R\x12isAbilit\
    yToggleOff\x12#\n\rability_level\x18\x14\x20\x01(\rR\x0cabilityLevel\x12\
    \x1d\n\nlocation_x\x18\x15\x20\x01(\x02R\tlocationX\x12\x1d\n\nlocation_\
    y\x18\x16\x20\x01(\x02R\tlocationY\x12\x1f\n\x0bgold_reason\x18\x17\x20\
    \x01(\rR\ngoldReason\x12#\n\rtimestamp_raw\x18\x18\x20\x01(\x02R\x0ctime\
    stampRaw\x12+\n\x11modifier_duration\x18\x19\x20\x01(\x02R\x10modifierDu\
    ration\x12\x1b\n\txp_reason\x18\x1a\x20\x01(\rR\x08xpReason\x12\x1b\n\tl\
    ast_hits\x18\x1b\x20\x01(\rR\x08lastHits\x12#\n\rattacker_team\x18\x1c\
    \x20\x01(\rR\x0cattackerTeam\x12\x1f\n\x0btarget_team\x18\x1d\x20\x01(\r\
    R\ntargetTeam\x12(\n\x10obs_wards_placed\x18\x1e\x20\x01(\rR\x0eobsWards\
    Placed\x12%\n\x0eassist_player0\x18\x1f\x20\x01(\rR\rassistPlayer0\x12%\
    \n\x0eassist_player1\x18\x20\x20\x01(\rR\rassistPlayer1\x12%\n\x0eassist\
    _player2\x18!\x20\x01(\rR\rassistPlayer2\x12%\n\x0eassist_player3\x18\"\
    \x20\x01(\rR\rassistPlayer3\x12\x1f\n\x0bstack_count\x18#\x20\x01(\rR\ns\
    tackCount\x12'\n\x0fhidden_modifier\x18$\x20\x01(\x08R\x0ehiddenModifier\
    \x12,\n\x12is_target_building\x18%\x20\x01(\x08R\x10isTargetBuilding\x12\
    *\n\x11neutral_camp_type\x18&\x20\x01(\rR\x0fneutralCampType\x12\x1b\n\t\
    rune_type\x18'\x20\x01(\rR\x08runeType\x12%\n\x0eassist_players\x18(\x20\
    \x03(\rR\rassistPlayers\x12\x20\n\x0cis_heal_save\x18)\x20\x01(\x08R\nis\
    HealSave\x12.\n\x13is_ultimate_ability\x18*\x20\x01(\x08R\x11isUltimateA\
    bility\x12.\n\x13attacker_hero_level\x18+\x20\x01(\rR\x11attackerHeroLev\
    el\x12*\n\x11target_hero_level\x18,\x20\x01(\rR\x0ftargetHeroLevel\x12\
    \x10\n\x03xpm\x18-\x20\x01(\rR\x03xpm\x12\x10\n\x03gpm\x18.\x20\x01(\rR\
    \x03gpm\x12%\n\x0eevent_location\x18/\x20\x01(\rR\reventLocation\x12$\n\
    \x0etarget_is_self\x180\x20\x01(\x08R\x0ctargetIsSelf\x12\x1f\n\x0bdamag\
    e_type\x181\x20\x01(\rR\ndamageType\x123\n\x15invisibility_modifier\x182\
    \x20\x01(\x08R\x14invisibilityModifier\x12'\n\x0fdamage_category\x183\
    \x20\x01(\rR\x0edamageCategory\x12\x1a\n\x08networth\x184\x20\x01(\rR\
    \x08networth\x12#\n\rbuilding_type\x185\x20\x01(\rR\x0cbuildingType\x12:\
    \n\x19modifier_elapsed_duration\x186\x20\x01(\x02R\x17modifierElapsedDur\
    ation\x12)\n\x10silence_modifier\x187\x20\x01(\x08R\x0fsilenceModifier\
    \x12.\n\x13heal_from_lifesteal\x188\x20\x01(\x08R\x11healFromLifesteal\
    \x12'\n\x0fmodifier_purged\x189\x20\x01(\x08R\x0emodifierPurged\x12!\n\
    \x0cspell_evaded\x18:\x20\x01(\x08R\x0bspellEvaded\x12<\n\x1amotion_cont\
    roller_modifier\x18;\x20\x01(\x08R\x18motionControllerModifier\x12&\n\
    \x0flong_range_kill\x18<\x20\x01(\x08R\rlongRangeKill\x124\n\x16modifier\
    _purge_ability\x18=\x20\x01(\rR\x14modifierPurgeAbility\x12,\n\x12modifi\
    er_purge_npc\x18>\x20\x01(\rR\x10modifierPurgeNpc\x12#\n\rroot_modifier\
    \x18?\x20\x01(\x08R\x0crootModifier\x123\n\x16total_unit_death_count\x18\
    @\x20\x01(\rR\x13totalUnitDeathCount\x12#\n\raura_modifier\x18A\x20\x01(\
    \x08R\x0cauraModifier\x122\n\x15armor_debuff_modifier\x18B\x20\x01(\x08R\
    \x13armorDebuffModifier\x12=\n\x1bno_physical_damage_modifier\x18C\x20\
    \x01(\x08R\x18noPhysicalDamageModifier\"\xfd\t\n\x13CMsgDOTAProfileCard\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x120\n\x14backgrou\
    nd_def_index\x18\x02\x20\x01(\rR\x12backgroundDefIndex\x12/\n\x05slots\
    \x18\x03\x20\x03(\x0b2\x19.CMsgDOTAProfileCard.SlotR\x05slots\x12!\n\x0c\
    badge_points\x18\x04\x20\x01(\rR\x0bbadgePoints\x12!\n\x0cevent_points\
    \x18\x05\x20\x01(\rR\x0beventPoints\x12\x19\n\x08event_id\x18\x06\x20\
    \x01(\rR\x07eventId\x12P\n\x19recent_battle_cup_victory\x18\x07\x20\x01(\
    \x0b2\x15.CMsgBattleCupVictoryR\x16recentBattleCupVictory\x1a\x9a\x06\n\
    \x04Slot\x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x128\n\x06tr\
    ophy\x18\x02\x20\x01(\x0b2\x20.CMsgDOTAProfileCard.Slot.TrophyR\x06troph\
    y\x122\n\x04stat\x18\x03\x20\x01(\x0b2\x1e.CMsgDOTAProfileCard.Slot.Stat\
    R\x04stat\x122\n\x04item\x18\x04\x20\x01(\x0b2\x1e.CMsgDOTAProfileCard.S\
    lot.ItemR\x04item\x122\n\x04hero\x18\x05\x20\x01(\x0b2\x1e.CMsgDOTAProfi\
    leCard.Slot.HeroR\x04hero\x12>\n\x08emoticon\x18\x06\x20\x01(\x0b2\".CMs\
    gDOTAProfileCard.Slot.EmoticonR\x08emoticon\x122\n\x04team\x18\x07\x20\
    \x01(\x0b2\x1e.CMsgDOTAProfileCard.Slot.TeamR\x04team\x1aH\n\x06Trophy\
    \x12\x1b\n\ttrophy_id\x18\x01\x20\x01(\rR\x08trophyId\x12!\n\x0ctrophy_s\
    core\x18\x02\x20\x01(\rR\x0btrophyScore\x1an\n\x04Stat\x12G\n\x07stat_id\
    \x18\x01\x20\x01(\x0e2\x1c.CMsgDOTAProfileCard.EStatID:\x10k_eStat_SoloR\
    ankR\x06statId\x12\x1d\n\nstat_score\x18\x02\x20\x01(\rR\tstatScore\x1aH\
    \n\x04Item\x12'\n\x0fserialized_item\x18\x01\x20\x01(\x0cR\x0eserialized\
    Item\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\x1a]\n\x04Hero\
    \x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x1b\n\thero_wins\
    \x18\x02\x20\x01(\rR\x08heroWins\x12\x1f\n\x0bhero_losses\x18\x03\x20\
    \x01(\rR\nheroLosses\x1a+\n\x08Emoticon\x12\x1f\n\x0bemoticon_id\x18\x01\
    \x20\x01(\rR\nemoticonId\x1a\x1f\n\x04Team\x12\x17\n\x07team_id\x18\x01\
    \x20\x01(\rR\x06teamId\"\x93\x01\n\x07EStatID\x12\x14\n\x10k_eStat_SoloR\
    ank\x10\x01\x12\x15\n\x11k_eStat_PartyRank\x10\x02\x12\x10\n\x0ck_eStat_\
    Wins\x10\x03\x12\x14\n\x10k_eStat_Commends\x10\x04\x12\x17\n\x13k_eStat_\
    GamesPlayed\x10\x05\x12\x1a\n\x16k_eStat_FirstMatchDate\x10\x06\"\xad\
    \x04\n\x16CSODOTAPlayerChallenge\x12#\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountIdB\x04\x80\xa6\x1d\x01\x12\x1f\n\x08event_id\x18\x02\x20\x01(\
    \rR\x07eventIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07slot_id\x18\x03\x20\x01\
    (\rR\x06slotIdB\x04\x80\xa6\x1d\x01\x12%\n\x0echallenge_type\x18\x04\x20\
    \x01(\rR\rchallengeType\x12\x1e\n\x0bint_param_0\x18\x05\x20\x01(\rR\tin\
    tParam0\x12\x1e\n\x0bint_param_1\x18\x06\x20\x01(\rR\tintParam1\x12!\n\
    \x0ccreated_time\x18\x07\x20\x01(\rR\x0bcreatedTime\x12\x1c\n\tcompleted\
    \x18\x08\x20\x01(\rR\tcompleted\x12\x1f\n\x0bsequence_id\x18\t\x20\x01(\
    \rR\nsequenceId\x12%\n\x0echallenge_tier\x18\n\x20\x01(\rR\rchallengeTie\
    r\x12\x14\n\x05flags\x18\x0b\x20\x01(\rR\x05flags\x12\x1a\n\x08attempts\
    \x18\x0c\x20\x01(\rR\x08attempts\x12%\n\x0ecomplete_limit\x18\r\x20\x01(\
    \rR\rcompleteLimit\x12\x1d\n\nquest_rank\x18\x0e\x20\x01(\rR\tquestRank\
    \"F\n\x06EFlags\x12\"\n\x1eeFlag_InstantRerollUncompleted\x10\x01\x12\
    \x18\n\x14eFlag_QuestChallenge\x10\x02\"a\n#CMsgClientToGCRerollPlayerCh\
    allenge\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12\x1f\n\
    \x0bsequence_id\x18\x03\x20\x01(\rR\nsequenceId\"\xf8\x01\n#CMsgGCReroll\
    PlayerChallengeResponse\x12U\n\x06result\x18\x01\x20\x01(\x0e2,.CMsgGCRe\
    rollPlayerChallengeResponse.EResult:\x0feResult_SuccessR\x06result\"z\n\
    \x07EResult\x12\x13\n\x0feResult_Success\x10\0\x12\x13\n\x0feResult_Drop\
    ped\x10\x01\x12\x14\n\x10eResult_NotFound\x10\x02\x12\x16\n\x12eResult_C\
    antReroll\x10\x03\x12\x17\n\x13eResult_ServerError\x10\x04\"k\n\x18CMsgG\
    CTopCustomGamesList\x12(\n\x10top_custom_games\x18\x01\x20\x03(\x04R\x0e\
    topCustomGames\x12%\n\x0fgame_of_the_day\x18\x02\x20\x01(\x04R\x0cgameOf\
    TheDay\"\xe6#\n\x19CMsgDOTARealtimeGameStats\x12=\n\x05match\x18\x01\x20\
    \x01(\x0b2'.CMsgDOTARealtimeGameStats.MatchDetailsR\x05match\x12<\n\x05t\
    eams\x18\x02\x20\x03(\x0b2&.CMsgDOTARealtimeGameStats.TeamDetailsR\x05te\
    ams\x12H\n\tbuildings\x18\x03\x20\x03(\x0b2*.CMsgDOTARealtimeGameStats.B\
    uildingDetailsR\tbuildings\x12C\n\ngraph_data\x18\x04\x20\x01(\x0b2$.CMs\
    gDOTARealtimeGameStats.GraphDataR\tgraphData\x12\x1f\n\x0bdelta_frame\
    \x18\x05\x20\x01(\x08R\ndeltaFrame\x1a\x90\x02\n\x0bTeamDetails\x12\x1f\
    \n\x0bteam_number\x18\x01\x20\x01(\rR\nteamNumber\x12\x17\n\x07team_id\
    \x18\x02\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\
    \x08teamName\x12\x1b\n\tteam_logo\x18\x04\x20\x01(\x06R\x08teamLogo\x12\
    \x14\n\x05score\x18\x05\x20\x01(\rR\x05score\x12B\n\x07players\x18\x06\
    \x20\x03(\x0b2(.CMsgDOTARealtimeGameStats.PlayerDetailsR\x07players\x12\
    \x1b\n\tonly_team\x18\x07\x20\x01(\x08R\x08onlyTeam\x12\x16\n\x06cheers\
    \x18\x08\x20\x01(\rR\x06cheers\x1ay\n\x0bItemDetails\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x12\n\x04time\x18\x03\x20\x01(\x05R\x04time\x12\x12\n\x04sold\x18\x04\
    \x20\x01(\x08R\x04sold\x12\x1e\n\nstackcount\x18\x05\x20\x01(\rR\nstackc\
    ount\x1a\x89\x01\n\x0eAbilityDetails\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05level\
    \x18\x03\x20\x01(\rR\x05level\x12\x1a\n\x08cooldown\x18\x04\x20\x01(\x02\
    R\x08cooldown\x12!\n\x0ccooldown_max\x18\x05\x20\x01(\x02R\x0bcooldownMa\
    x\x1a]\n\x0fHeroToHeroStats\x12\x1a\n\x08victimid\x18\x01\x20\x01(\rR\
    \x08victimid\x12\x14\n\x05kills\x18\x02\x20\x01(\rR\x05kills\x12\x18\n\
    \x07assists\x18\x03\x20\x01(\rR\x07assists\x1a\x1d\n\x0bAbilityList\x12\
    \x0e\n\x02id\x18\x01\x20\x03(\rR\x02id\x1a\xa0\x0e\n\rPlayerDetails\x12\
    \x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1a\n\x08playerid\
    \x18\x02\x20\x01(\rR\x08playerid\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x12\x12\n\x04team\x18\x04\x20\x01(\rR\x04team\x12\x16\n\x06hero\
    id\x18\x05\x20\x01(\rR\x06heroid\x12\"\n\x0chealthpoints\x18\x06\x20\x01\
    (\rR\x0chealthpoints\x12(\n\x0fmaxhealthpoints\x18\x07\x20\x01(\rR\x0fma\
    xhealthpoints\x12(\n\x0fhealthregenrate\x18\x08\x20\x01(\x02R\x0fhealthr\
    egenrate\x12\x1e\n\nmanapoints\x18\t\x20\x01(\rR\nmanapoints\x12$\n\rmax\
    manapoints\x18\n\x20\x01(\rR\rmaxmanapoints\x12$\n\rmanaregenrate\x18\
    \x0b\x20\x01(\x02R\rmanaregenrate\x12#\n\rbase_strength\x18\x0c\x20\x01(\
    \rR\x0cbaseStrength\x12!\n\x0cbase_agility\x18\r\x20\x01(\rR\x0bbaseAgil\
    ity\x12+\n\x11base_intelligence\x18\x0e\x20\x01(\rR\x10baseIntelligence\
    \x12\x1d\n\nbase_armor\x18\x0f\x20\x01(\x05R\tbaseArmor\x12%\n\x0ebase_m\
    ovespeed\x18\x10\x20\x01(\rR\rbaseMovespeed\x12\x1f\n\x0bbase_damage\x18\
    \x11\x20\x01(\rR\nbaseDamage\x12\x1a\n\x08strength\x18\x12\x20\x01(\rR\
    \x08strength\x12\x18\n\x07agility\x18\x13\x20\x01(\rR\x07agility\x12\"\n\
    \x0cintelligence\x18\x14\x20\x01(\rR\x0cintelligence\x12\x14\n\x05armor\
    \x18\x15\x20\x01(\x05R\x05armor\x12\x1c\n\tmovespeed\x18\x16\x20\x01(\rR\
    \tmovespeed\x12\x16\n\x06damage\x18\x17\x20\x01(\rR\x06damage\x12\x1f\n\
    \x0bhero_damage\x18\x18\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\
    \x18\x19\x20\x01(\rR\x0btowerDamage\x12G\n\tabilities\x18\x1a\x20\x03(\
    \x0b2).CMsgDOTARealtimeGameStats.AbilityDetailsR\tabilities\x12\x14\n\
    \x05level\x18\x1b\x20\x01(\rR\x05level\x12\x1d\n\nkill_count\x18\x1c\x20\
    \x01(\rR\tkillCount\x12\x1f\n\x0bdeath_count\x18\x1d\x20\x01(\rR\ndeathC\
    ount\x12#\n\rassists_count\x18\x1e\x20\x01(\rR\x0cassistsCount\x12!\n\
    \x0cdenies_count\x18\x1f\x20\x01(\rR\x0bdeniesCount\x12\x19\n\x08lh_coun\
    t\x18\x20\x20\x01(\rR\x07lhCount\x12!\n\x0chero_healing\x18!\x20\x01(\rR\
    \x0bheroHealing\x12\x20\n\x0cgold_per_min\x18\"\x20\x01(\rR\ngoldPerMin\
    \x12\x1c\n\nxp_per_min\x18#\x20\x01(\rR\x08xpPerMin\x12\x19\n\x08net_gol\
    d\x18$\x20\x01(\rR\x07netGold\x12\x12\n\x04gold\x18%\x20\x01(\rR\x04gold\
    \x12\x0c\n\x01x\x18&\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18'\x20\x01(\x02\
    R\x01y\x12!\n\x0crespawn_time\x18(\x20\x01(\x05R\x0brespawnTime\x12+\n\
    \x11ultimate_cooldown\x18)\x20\x01(\rR\x10ultimateCooldown\x12\x1f\n\x0b\
    has_buyback\x18*\x20\x01(\x08R\nhasBuyback\x12<\n\x05items\x18+\x20\x03(\
    \x0b2&.CMsgDOTARealtimeGameStats.ItemDetailsR\x05items\x12F\n\nstashitem\
    s\x18,\x20\x03(\x0b2&.CMsgDOTARealtimeGameStats.ItemDetailsR\nstashitems\
    \x12R\n\x10itemshoppinglist\x18-\x20\x03(\x0b2&.CMsgDOTARealtimeGameStat\
    s.ItemDetailsR\x10itemshoppinglist\x12H\n\x0blevelpoints\x18.\x20\x03(\
    \x0b2&.CMsgDOTARealtimeGameStats.AbilityListR\x0blevelpoints\x12W\n\x12h\
    ero_to_hero_stats\x18/\x20\x03(\x0b2*.CMsgDOTARealtimeGameStats.HeroToHe\
    roStatsR\x0fheroToHeroStats\x12!\n\x0chas_ultimate\x180\x20\x01(\x08R\
    \x0bhasUltimate\x12*\n\x11has_ultimate_mana\x181\x20\x01(\x08R\x0fhasUlt\
    imateMana\x1a\xb5\x01\n\x0fBuildingDetails\x12\x12\n\x04team\x18\x02\x20\
    \x01(\rR\x04team\x12\x18\n\x07heading\x18\x03\x20\x01(\x02R\x07heading\
    \x12\x12\n\x04lane\x18\x04\x20\x01(\rR\x04lane\x12\x12\n\x04tier\x18\x05\
    \x20\x01(\rR\x04tier\x12\x12\n\x04type\x18\x06\x20\x01(\rR\x04type\x12\
    \x0c\n\x01x\x18\x07\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x08\x20\x01(\
    \x02R\x01y\x12\x1c\n\tdestroyed\x18\t\x20\x01(\x08R\tdestroyed\x1as\n\
    \x0bKillDetails\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\
    \x1d\n\ndeath_time\x18\x02\x20\x01(\x05R\tdeathTime\x12(\n\x10killer_pla\
    yer_id\x18\x03\x20\x01(\rR\x0ekillerPlayerId\x1a}\n\x12BroadcasterDetail\
    s\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12#\n\rselected_\
    hero\x18\x02\x20\x01(\rR\x0cselectedHero\x12%\n\x0eselected_graph\x18\
    \x03\x20\x01(\rR\rselectedGraph\x1a8\n\x0ePickBanDetails\x12\x12\n\x04he\
    ro\x18\x01\x20\x01(\rR\x04hero\x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04\
    team\x1a\xb4\x05\n\x0cMatchDetails\x12&\n\x0fserver_steam_id\x18\x01\x20\
    \x01(\x06R\rserverSteamId\x12\x18\n\x07matchid\x18\x02\x20\x01(\x04R\x07\
    matchid\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\x12\x1e\n\
    \x0btime_of_day\x18\x04\x20\x01(\x02R\ttimeOfDay\x122\n\x15is_nightstalk\
    er_night\x18\x05\x20\x01(\x08R\x13isNightstalkerNight\x12\x1b\n\tgame_ti\
    me\x18\x06\x20\x01(\x05R\x08gameTime\x12%\n\x0eteamid_radiant\x18\x08\
    \x20\x01(\rR\rteamidRadiant\x12\x1f\n\x0bteamid_dire\x18\t\x20\x01(\rR\n\
    teamidDire\x12?\n\x05picks\x18\n\x20\x03(\x0b2).CMsgDOTARealtimeGameStat\
    s.PickBanDetailsR\x05picks\x12=\n\x04bans\x18\x0b\x20\x03(\x0b2).CMsgDOT\
    ARealtimeGameStats.PickBanDetailsR\x04bans\x12<\n\x05kills\x18\x0c\x20\
    \x03(\x0b2&.CMsgDOTARealtimeGameStats.KillDetailsR\x05kills\x12Q\n\x0cbr\
    oadcasters\x18\r\x20\x03(\x0b2-.CMsgDOTARealtimeGameStats.BroadcasterDet\
    ailsR\x0cbroadcasters\x12\x1b\n\tgame_mode\x18\x0e\x20\x01(\rR\x08gameMo\
    de\x12\x1b\n\tleague_id\x18\x0f\x20\x01(\rR\x08leagueId\x12\x1f\n\x0bsin\
    gle_team\x18\x10\x20\x01(\x08R\nsingleTeam\x12\x1f\n\x0bcheers_peak\x18\
    \x11\x20\x01(\rR\ncheersPeak\x1a\xc3\x04\n\tGraphData\x12\x1d\n\ngraph_g\
    old\x18\x01\x20\x03(\x05R\tgraphGold\x12\x19\n\x08graph_xp\x18\x02\x20\
    \x03(\x05R\x07graphXp\x12\x1d\n\ngraph_kill\x18\x03\x20\x03(\x05R\tgraph\
    Kill\x12\x1f\n\x0bgraph_tower\x18\x04\x20\x03(\x05R\ngraphTower\x12\x1b\
    \n\tgraph_rax\x18\x05\x20\x03(\x05R\x08graphRax\x12\\\n\x0eteam_loc_stat\
    s\x18\x06\x20\x03(\x0b26.CMsgDOTARealtimeGameStats.GraphData.TeamLocatio\
    nStatsR\x0cteamLocStats\x1a%\n\rLocationStats\x12\x14\n\x05stats\x18\x01\
    \x20\x03(\x05R\x05stats\x1ad\n\x11TeamLocationStats\x12O\n\tloc_stats\
    \x18\x01\x20\x03(\x0b22.CMsgDOTARealtimeGameStats.GraphData.LocationStat\
    sR\x08locStats\"[\n\x05eStat\x12\x13\n\x0fCreepGoldEarned\x10\0\x12\x12\
    \n\x0eKillGoldEarned\x10\x01\x12\x1b\n\x17DeathAndBuybackGoldLost\x10\
    \x02\x12\x0c\n\x08XPEarned\x10\x03\"W\n\teLocation\x12\x0b\n\x07BotLane\
    \x10\0\x12\x0b\n\x07MidLane\x10\x01\x12\x0b\n\x07TopLane\x10\x02\x12\n\n\
    \x06Jungle\x10\x03\x12\x0c\n\x08Ancients\x10\x04\x12\t\n\x05Other\x10\
    \x05\"\xa8\x0b\n\x1eCMsgDOTARealtimeGameStatsTerse\x12B\n\x05match\x18\
    \x01\x20\x01(\x0b2,.CMsgDOTARealtimeGameStatsTerse.MatchDetailsR\x05matc\
    h\x12A\n\x05teams\x18\x02\x20\x03(\x0b2+.CMsgDOTARealtimeGameStatsTerse.\
    TeamDetailsR\x05teams\x12M\n\tbuildings\x18\x03\x20\x03(\x0b2/.CMsgDOTAR\
    ealtimeGameStatsTerse.BuildingDetailsR\tbuildings\x12H\n\ngraph_data\x18\
    \x04\x20\x01(\x0b2).CMsgDOTARealtimeGameStatsTerse.GraphDataR\tgraphData\
    \x12\x1f\n\x0bdelta_frame\x18\x05\x20\x01(\x08R\ndeltaFrame\x1a\xe0\x01\
    \n\x0bTeamDetails\x12\x1f\n\x0bteam_number\x18\x01\x20\x01(\rR\nteamNumb\
    er\x12\x17\n\x07team_id\x18\x02\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_na\
    me\x18\x03\x20\x01(\tR\x08teamName\x12\x1b\n\tteam_logo\x18\x04\x20\x01(\
    \x06R\x08teamLogo\x12\x14\n\x05score\x18\x05\x20\x01(\rR\x05score\x12G\n\
    \x07players\x18\x06\x20\x03(\x0b2-.CMsgDOTARealtimeGameStatsTerse.Player\
    DetailsR\x07players\x1a\xf2\x02\n\rPlayerDetails\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x1a\n\x08playerid\x18\x02\x20\x01(\r\
    R\x08playerid\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x12\n\
    \x04team\x18\x04\x20\x01(\rR\x04team\x12\x16\n\x06heroid\x18\x05\x20\x01\
    (\rR\x06heroid\x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05level\x12\x1d\n\
    \nkill_count\x18\x07\x20\x01(\rR\tkillCount\x12\x1f\n\x0bdeath_count\x18\
    \x08\x20\x01(\rR\ndeathCount\x12#\n\rassists_count\x18\t\x20\x01(\rR\x0c\
    assistsCount\x12!\n\x0cdenies_count\x18\n\x20\x01(\rR\x0bdeniesCount\x12\
    \x19\n\x08lh_count\x18\x0b\x20\x01(\rR\x07lhCount\x12\x12\n\x04gold\x18\
    \x0c\x20\x01(\rR\x04gold\x12\x0c\n\x01x\x18\r\x20\x01(\x02R\x01x\x12\x0c\
    \n\x01y\x18\x0e\x20\x01(\x02R\x01y\x1a\xb5\x01\n\x0fBuildingDetails\x12\
    \x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12\x18\n\x07heading\x18\x02\
    \x20\x01(\x02R\x07heading\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04type\
    \x12\x12\n\x04lane\x18\x04\x20\x01(\rR\x04lane\x12\x12\n\x04tier\x18\x05\
    \x20\x01(\rR\x04tier\x12\x0c\n\x01x\x18\x06\x20\x01(\x02R\x01x\x12\x0c\n\
    \x01y\x18\x07\x20\x01(\x02R\x01y\x12\x1c\n\tdestroyed\x18\x08\x20\x01(\
    \x08R\tdestroyed\x1a\x88\x02\n\x0cMatchDetails\x12&\n\x0fserver_steam_id\
    \x18\x01\x20\x01(\x06R\rserverSteamId\x12\x18\n\x07matchid\x18\x02\x20\
    \x01(\x04R\x07matchid\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestam\
    p\x12\x1b\n\tgame_time\x18\x04\x20\x01(\x05R\x08gameTime\x12A\n\x1dsteam\
    _broadcaster_account_ids\x18\x06\x20\x03(\rR\x1asteamBroadcasterAccountI\
    ds\x12\x1b\n\tgame_mode\x18\x07\x20\x01(\rR\x08gameMode\x12\x1b\n\tleagu\
    e_id\x18\x08\x20\x01(\rR\x08leagueId\x1a*\n\tGraphData\x12\x1d\n\ngraph_\
    gold\x18\x01\x20\x03(\x05R\tgraphGold\"S\n\x20CMsgGCToClientMatchGroupsV\
    ersion\x12/\n\x13matchgroups_version\x18\x01\x20\x01(\rR\x12matchgroupsV\
    ersion\"\x91\x02\n\x1bCMsgDOTASDOHeroStatsHistory\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\tgame_mode\x18\x02\x20\x01(\
    \rR\x08gameMode\x12\x1d\n\nlobby_type\x18\x03\x20\x01(\rR\tlobbyType\x12\
    \x1d\n\nstart_time\x18\x04\x20\x01(\rR\tstartTime\x12\x10\n\x03won\x18\
    \x05\x20\x01(\x08R\x03won\x12\x10\n\x03gpm\x18\x06\x20\x01(\rR\x03gpm\
    \x12\x10\n\x03xpm\x18\x07\x20\x01(\rR\x03xpm\x12\x14\n\x05kills\x18\x08\
    \x20\x01(\rR\x05kills\x12\x16\n\x06deaths\x18\t\x20\x01(\rR\x06deaths\
    \x12\x18\n\x07assists\x18\n\x20\x01(\rR\x07assists\"\xfa\x03\n\x15CMsgDO\
    TASeasonRewards\x127\n\x07rewards\x18\x01\x20\x03(\x0b2\x1d.CMsgDOTASeas\
    onRewards.RewardR\x07rewards\x1a\xbd\x02\n\x06Reward\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07itemdef\x18\x02\x20\x01(\rR\
    \x07itemdef\x12\x1e\n\nimportance\x18\x03\x20\x01(\rR\nimportance\x12\
    \x1d\n\nbase_level\x18\x04\x20\x01(\rR\tbaseLevel\x12!\n\x0crepeat_level\
    \x18\x05\x20\x01(\rR\x0brepeatLevel\x12M\n\x0breward_type\x18\x06\x20\
    \x01(\x0e2\".CMsgDOTASeasonRewards.ERewardType:\x08EconItemR\nrewardType\
    \x12\x14\n\x05image\x18\x07\x20\x01(\tR\x05image\x12\x1b\n\taction_id\
    \x18\x08\x20\x01(\rR\x08actionId\x12!\n\x0ceffect_index\x18\t\x20\x01(\r\
    R\x0beffectIndex\"h\n\x0bERewardType\x12\x0c\n\x08EconItem\x10\0\x12\x10\
    \n\x0cMysteryWheel\x10\x01\x12\x11\n\rAbilityEffect\x10\x02\x12\t\n\x05O\
    ther\x10\x03\x12\x1b\n\x17MysteryWheelPointsBased\x10\x04\"\xb1\x03\n\
    \x1aCMsgDOTASeasonAchievements\x12K\n\x0cachievements\x18\x01\x20\x03(\
    \x0b2'.CMsgDOTASeasonAchievements.AchievementR\x0cachievements\x1a\xc5\
    \x02\n\x0bAchievement\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x14\n\x05im\
    age\x18\x03\x20\x01(\tR\x05image\x12\x1b\n\taction_id\x18\x04\x20\x01(\r\
    R\x08actionId\x12\x1d\n\nmax_grants\x18\x05\x20\x01(\rR\tmaxGrants\x12#\
    \n\rnormal_points\x18\x06\x20\x01(\rR\x0cnormalPoints\x121\n\x14tracking\
    _achievement\x18\x07\x20\x01(\rR\x13trackingAchievement\x12)\n\x10achiev\
    ement_goal\x18\x08\x20\x01(\rR\x0fachievementGoal\x12+\n\x11achievement_\
    level\x18\t\x20\x01(\rR\x10achievementLevel\"\x84\x15\n\x19CMsgDOTASeaso\
    nPredictions\x12G\n\x0bpredictions\x18\x01\x20\x03(\x0b2%.CMsgDOTASeason\
    Predictions.PredictionR\x0bpredictions\x12[\n\x13in_game_predictions\x18\
    \x02\x20\x03(\x0b2+.CMsgDOTASeasonPredictions.InGamePredictionR\x11inGam\
    ePredictions\x12G\n!in_game_prediction_count_per_game\x18\x03\x20\x01(\r\
    R\x1cinGamePredictionCountPerGame\x12U\n(in_game_prediction_voting_perio\
    d_minutes\x18\x04\x20\x01(\rR#inGamePredictionVotingPeriodMinutes\x1az\n\
    \x06Choice\x12\x14\n\x05value\x18\x01\x20\x01(\rR\x05value\x12\x12\n\x04\
    name\x18\x02\x20\x01(\tR\x04name\x12\"\n\rmin_raw_value\x18\x03\x20\x01(\
    \rR\x0bminRawValue\x12\"\n\rmax_raw_value\x18\x04\x20\x01(\rR\x0bmaxRawV\
    alue\x1a&\n\x07Answers\x12\x1b\n\tanswer_id\x18\x01\x20\x01(\rR\x08answe\
    rId\x1a:\n\x0eQueryKeyValues\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x1a\xf1\x05\n\nPredic\
    tion\x12G\n\x04type\x18\x01\x20\x01(\x0e2*.CMsgDOTASeasonPredictions.ePr\
    edictionType:\x07GenericR\x04type\x12\x1a\n\x08question\x18\x02\x20\x01(\
    \tR\x08question\x12;\n\x07choices\x18\x03\x20\x03(\x0b2!.CMsgDOTASeasonP\
    redictions.ChoiceR\x07choices\x12!\n\x0cselection_id\x18\x04\x20\x01(\rR\
    \x0bselectionId\x12\x1d\n\nstart_date\x18\x05\x20\x01(\rR\tstartDate\x12\
    \x1b\n\tlock_date\x18\x06\x20\x01(\rR\x08lockDate\x12\x16\n\x06reward\
    \x18\x07\x20\x01(\rR\x06reward\x12R\n\x0banswer_type\x18\x08\x20\x01(\
    \x0e2&.CMsgDOTASeasonPredictions.eAnswerType:\tSingleIntR\nanswerType\
    \x12\x1b\n\tanswer_id\x18\t\x20\x01(\rR\x08answerId\x12<\n\x07answers\
    \x18\n\x20\x03(\x0b2\".CMsgDOTASeasonPredictions.AnswersR\x07answers\x12\
    \x1d\n\nquery_name\x18\x0b\x20\x01(\tR\tqueryName\x12*\n\x11query_bind_p\
    arams\x18\x0c\x20\x03(\rR\x0fqueryBindParams\x12/\n\x14lock_on_selection\
    _id\x18\r\x20\x01(\rR\x11lockOnSelectionId\x125\n\x17lock_on_selection_v\
    alue\x18\x0e\x20\x01(\rR\x14lockOnSelectionValue\x121\n\x15lock_on_selec\
    tion_set\x18\x0f\x20\x01(\x08R\x12lockOnSelectionSet\x125\n\x17use_answe\
    r_value_ranges\x18\x10\x20\x01(\x08R\x14useAnswerValueRanges\x1a\x90\x06\
    \n\x10InGamePrediction\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x12G\n\x04type\x18\x03\x20\x01(\
    \x0e2*.CMsgDOTASeasonPredictions.ePredictionType:\x07GenericR\x04type\
    \x12S\n\x05group\x18\x04\x20\x01(\x0e22.CMsgDOTASeasonPredictions.eRando\
    mSelectionGroup_t:\tEarlyGameR\x05group\x12\x1a\n\x08question\x18\x05\
    \x20\x01(\tR\x08question\x12;\n\x07choices\x18\x06\x20\x03(\x0b2!.CMsgDO\
    TASeasonPredictions.ChoiceR\x07choices\x12'\n\x0frequired_heroes\x18\x07\
    \x20\x03(\tR\x0erequiredHeroes\x12\x1d\n\nquery_name\x18\x08\x20\x01(\tR\
    \tqueryName\x12L\n\x0cquery_values\x18\t\x20\x03(\x0b2).CMsgDOTASeasonPr\
    edictions.QueryKeyValuesR\x0bqueryValues\x12p\n\x16answer_resolution_typ\
    e\x18\n\x20\x01(\x0e2,.CMsgDOTASeasonPredictions.eResolutionType_t:\x0cI\
    nvalidQueryR\x14answerResolutionType\x12&\n\x0fpoints_to_grant\x18\x0b\
    \x20\x01(\rR\rpointsToGrant\x12#\n\rreward_action\x18\x0c\x20\x01(\rR\
    \x0crewardAction\x122\n\x15debug_force_selection\x18\r\x20\x01(\rR\x13de\
    bugForceSelection\x12X\n\x0eraw_value_type\x18\x0e\x20\x01(\x0e2*.CMsgDO\
    TASeasonPredictions.eRawValueType_t:\x06NumberR\x0crawValueType\"V\n\x0f\
    ePredictionType\x12\x0b\n\x07Generic\x10\0\x12\x08\n\x04Hero\x10\x01\x12\
    \x08\n\x04Team\x10\x02\x12\n\n\x06Player\x10\x03\x12\x0b\n\x07Special\
    \x10\x04\x12\t\n\x05YesNo\x10\x05\"\x91\x01\n\x0beAnswerType\x12\r\n\tSi\
    ngleInt\x10\0\x12\x0f\n\x0bSingleFloat\x10\x01\x12\x0f\n\x0bMultipleInt\
    \x10\x02\x12\x11\n\rMultipleFloat\x10\x03\x12\x0e\n\nAnswerTeam\x10\x04\
    \x12\x0e\n\nSingleTime\x10\x05\x12\x10\n\x0cMultipleTime\x10\x06\x12\x0c\
    \n\x08NoAnswer\x10\x07\"\xd4\x01\n\x11eResolutionType_t\x12\x10\n\x0cInv\
    alidQuery\x10\0\x12\x14\n\x10FirstToPassQuery\x10\x01\x12\x13\n\x0fLastT\
    oPassQuery\x10\x02\x12\x16\n\x12LastRemainingQuery\x10\x03\x12\x12\n\x0e\
    MaxToPassQuery\x10\x04\x12\x12\n\x0eMinToPassQuery\x10\x05\x12\x0c\n\x08\
    SumQuery\x10\x06\x12\x19\n\x15MaxTeamSumToPassQuery\x10\x07\x12\x19\n\
    \x15MinTeamSumToPassQuery\x10\x08\"N\n\x17eRandomSelectionGroup_t\x12\r\
    \n\tEarlyGame\x10\0\x12\x0b\n\x07MidGame\x10\x01\x12\x0c\n\x08LateGame\
    \x10\x02\x12\t\n\x05Count\x10\x03\"'\n\x0feRawValueType_t\x12\n\n\x06Num\
    ber\x10\0\x12\x08\n\x04Time\x10\x01\"\xc4$\n\rCMsgDOTAMatch\x12\x1a\n\
    \x08duration\x18\x03\x20\x01(\rR\x08duration\x12\x1c\n\tstartTime\x18\
    \x04\x20\x01(\x07R\tstartTime\x12/\n\x07players\x18\x05\x20\x03(\x0b2\
    \x15.CMsgDOTAMatch.PlayerR\x07players\x12\x19\n\x08match_id\x18\x06\x20\
    \x01(\x04R\x07matchId\x12!\n\x0ctower_status\x18\x08\x20\x03(\rR\x0btowe\
    rStatus\x12'\n\x0fbarracks_status\x18\t\x20\x03(\rR\x0ebarracksStatus\
    \x12\x18\n\x07cluster\x18\n\x20\x01(\rR\x07cluster\x12(\n\x10first_blood\
    _time\x18\x0c\x20\x01(\rR\x0efirstBloodTime\x12\x1f\n\x0breplay_salt\x18\
    \r\x20\x01(\x07R\nreplaySalt\x12\x1b\n\tserver_ip\x18\x0e\x20\x01(\x07R\
    \x08serverIp\x12\x1f\n\x0bserver_port\x18\x0f\x20\x01(\rR\nserverPort\
    \x12\x1d\n\nlobby_type\x18\x10\x20\x01(\rR\tlobbyType\x12#\n\rhuman_play\
    ers\x18\x11\x20\x01(\rR\x0chumanPlayers\x12#\n\raverage_skill\x18\x12\
    \x20\x01(\rR\x0caverageSkill\x12!\n\x0cgame_balance\x18\x13\x20\x01(\x02\
    R\x0bgameBalance\x12&\n\x0fradiant_team_id\x18\x14\x20\x01(\rR\rradiantT\
    eamId\x12\x20\n\x0cdire_team_id\x18\x15\x20\x01(\rR\ndireTeamId\x12\x1a\
    \n\x08leagueid\x18\x16\x20\x01(\rR\x08leagueid\x12*\n\x11radiant_team_na\
    me\x18\x17\x20\x01(\tR\x0fradiantTeamName\x12$\n\x0edire_team_name\x18\
    \x18\x20\x01(\tR\x0cdireTeamName\x12*\n\x11radiant_team_logo\x18\x19\x20\
    \x01(\x04R\x0fradiantTeamLogo\x12$\n\x0edire_team_logo\x18\x1a\x20\x01(\
    \x04R\x0cdireTeamLogo\x122\n\x15radiant_team_complete\x18\x1b\x20\x01(\r\
    R\x13radiantTeamComplete\x12,\n\x12dire_team_complete\x18\x1c\x20\x01(\r\
    R\x10direTeamComplete\x12%\n\x0epositive_votes\x18\x1d\x20\x01(\rR\rposi\
    tiveVotes\x12%\n\x0enegative_votes\x18\x1e\x20\x01(\rR\rnegativeVotes\
    \x12?\n\tgame_mode\x18\x1f\x20\x01(\x0e2\x0e.DOTA_GameMode:\x12DOTA_GAME\
    MODE_NONER\x08gameMode\x125\n\npicks_bans\x18\x20\x20\x03(\x0b2\x16.CMat\
    chHeroSelectEventR\tpicksBans\x12\"\n\rmatch_seq_num\x18!\x20\x01(\x04R\
    \x0bmatchSeqNum\x12O\n\x0creplay_state\x18\"\x20\x01(\x0e2\x1a.CMsgDOTAM\
    atch.ReplayState:\x10REPLAY_AVAILABLER\x0breplayState\x12(\n\x10radiant_\
    guild_id\x18#\x20\x01(\rR\x0eradiantGuildId\x12\"\n\rdire_guild_id\x18$\
    \x20\x01(\rR\x0bdireGuildId\x12(\n\x10radiant_team_tag\x18%\x20\x01(\tR\
    \x0eradiantTeamTag\x12\"\n\rdire_team_tag\x18&\x20\x01(\tR\x0bdireTeamTa\
    g\x12\x1b\n\tseries_id\x18'\x20\x01(\rR\x08seriesId\x12\x1f\n\x0bseries_\
    type\x18(\x20\x01(\rR\nseriesType\x12T\n\x14broadcaster_channels\x18+\
    \x20\x03(\x0b2!.CMsgDOTAMatch.BroadcasterChannelR\x13broadcasterChannels\
    \x12\x16\n\x06engine\x18,\x20\x01(\rR\x06engine\x12G\n\x10custom_game_da\
    ta\x18-\x20\x01(\x0b2\x1d.CMsgDOTAMatch.CustomGameDataR\x0ecustomGameDat\
    a\x12\x1f\n\x0bmatch_flags\x18.\x20\x01(\rR\nmatchFlags\x120\n\x14privat\
    e_metadata_key\x18/\x20\x01(\x07R\x12privateMetadataKey\x12,\n\x12radian\
    t_team_score\x180\x20\x01(\rR\x10radiantTeamScore\x12&\n\x0fdire_team_sc\
    ore\x181\x20\x01(\rR\rdireTeamScore\x12L\n\rmatch_outcome\x182\x20\x01(\
    \x0e2\x0e.EMatchOutcome:\x17k_EMatchOutcome_UnknownR\x0cmatchOutcome\x12\
    #\n\rtournament_id\x183\x20\x01(\rR\x0ctournamentId\x12)\n\x10tournament\
    _round\x184\x20\x01(\rR\x0ftournamentRound\x12*\n\x11pre_game_duration\
    \x185\x20\x01(\rR\x0fpreGameDuration\x1a\xcd\x11\n\x06Player\x12\x1d\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bplayer_slot\x18\
    \x02\x20\x01(\rR\nplayerSlot\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\
    \x06heroId\x12\x15\n\x06item_0\x18\x04\x20\x01(\rR\x05item0\x12\x15\n\
    \x06item_1\x18\x05\x20\x01(\rR\x05item1\x12\x15\n\x06item_2\x18\x06\x20\
    \x01(\rR\x05item2\x12\x15\n\x06item_3\x18\x07\x20\x01(\rR\x05item3\x12\
    \x15\n\x06item_4\x18\x08\x20\x01(\rR\x05item4\x12\x15\n\x06item_5\x18\t\
    \x20\x01(\rR\x05item5\x12\x15\n\x06item_6\x18;\x20\x01(\rR\x05item6\x12\
    \x15\n\x06item_7\x18<\x20\x01(\rR\x05item7\x12\x15\n\x06item_8\x18=\x20\
    \x01(\rR\x05item8\x12<\n\x1aexpected_team_contribution\x18\n\x20\x01(\
    \x02R\x18expectedTeamContribution\x12#\n\rscaled_metric\x18\x0b\x20\x01(\
    \x02R\x0cscaledMetric\x12#\n\rprevious_rank\x18\x0c\x20\x01(\rR\x0cprevi\
    ousRank\x12\x1f\n\x0brank_change\x18\r\x20\x01(\x11R\nrankChange\x12\x1b\
    \n\tsolo_rank\x181\x20\x01(\x08R\x08soloRank\x12#\n\rseasonal_rank\x185\
    \x20\x01(\x08R\x0cseasonalRank\x12\x14\n\x05kills\x18\x0e\x20\x01(\rR\
    \x05kills\x12\x16\n\x06deaths\x18\x0f\x20\x01(\rR\x06deaths\x12\x18\n\
    \x07assists\x18\x10\x20\x01(\rR\x07assists\x12#\n\rleaver_status\x18\x11\
    \x20\x01(\rR\x0cleaverStatus\x12\x12\n\x04gold\x18\x12\x20\x01(\rR\x04go\
    ld\x12\x1b\n\tlast_hits\x18\x13\x20\x01(\rR\x08lastHits\x12\x16\n\x06den\
    ies\x18\x14\x20\x01(\rR\x06denies\x12\x20\n\x0cgold_per_min\x18\x15\x20\
    \x01(\rR\ngoldPerMin\x12\x1c\n\nXP_per_min\x18\x16\x20\x01(\rR\x08XPPerM\
    in\x12\x1d\n\ngold_spent\x18\x17\x20\x01(\rR\tgoldSpent\x12\x1f\n\x0bher\
    o_damage\x18\x18\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\x18\x19\
    \x20\x01(\rR\x0btowerDamage\x12!\n\x0chero_healing\x18\x1a\x20\x01(\rR\
    \x0bheroHealing\x12\x14\n\x05level\x18\x1b\x20\x01(\rR\x05level\x12$\n\
    \x0etime_last_seen\x18\x1c\x20\x01(\rR\x0ctimeLastSeen\x12\x1f\n\x0bplay\
    er_name\x18\x1d\x20\x01(\tR\nplayerName\x122\n\x15support_ability_value\
    \x18\x1e\x20\x01(\rR\x13supportAbilityValue\x12)\n\x10feeding_detected\
    \x18\x20\x20\x01(\x08R\x0ffeedingDetected\x12\x1f\n\x0bsearch_rank\x18\"\
    \x20\x01(\rR\nsearchRank\x126\n\x17search_rank_uncertainty\x18#\x20\x01(\
    \rR\x15searchRankUncertainty\x126\n\x17rank_uncertainty_change\x18$\x20\
    \x01(\x05R\x15rankUncertaintyChange\x12&\n\x0fhero_play_count\x18%\x20\
    \x01(\rR\rheroPlayCount\x12\x19\n\x08party_id\x18&\x20\x01(\x06R\x07part\
    yId\x12,\n\x12scaled_hero_damage\x186\x20\x01(\rR\x10scaledHeroDamage\
    \x12.\n\x13scaled_tower_damage\x187\x20\x01(\rR\x11scaledTowerDamage\x12\
    .\n\x13scaled_hero_healing\x188\x20\x01(\rR\x11scaledHeroHealing\x12!\n\
    \x0cscaled_kills\x18'\x20\x01(\x02R\x0bscaledKills\x12#\n\rscaled_deaths\
    \x18(\x20\x01(\x02R\x0cscaledDeaths\x12%\n\x0escaled_assists\x18)\x20\
    \x01(\x02R\rscaledAssists\x12*\n\x11claimed_farm_gold\x18*\x20\x01(\rR\
    \x0fclaimedFarmGold\x12!\n\x0csupport_gold\x18+\x20\x01(\rR\x0bsupportGo\
    ld\x12%\n\x0eclaimed_denies\x18,\x20\x01(\rR\rclaimedDenies\x12%\n\x0ecl\
    aimed_misses\x18-\x20\x01(\rR\rclaimedMisses\x12\x16\n\x06misses\x18.\
    \x20\x01(\rR\x06misses\x12F\n\x10ability_upgrades\x18/\x20\x03(\x0b2\x1b\
    .CMatchPlayerAbilityUpgradeR\x0fabilityUpgrades\x12\\\n\x1aadditional_un\
    its_inventory\x180\x20\x03(\x0b2\x1e.CMatchAdditionalUnitInventoryR\x18a\
    dditionalUnitsInventory\x12C\n\x0fpermanent_buffs\x189\x20\x03(\x0b2\x1a\
    .CMatchPlayerPermanentBuffR\x0epermanentBuffs\x12N\n\x10custom_game_data\
    \x182\x20\x01(\x0b2$.CMsgDOTAMatch.Player.CustomGameDataR\x0ecustomGameD\
    ata\x12,\n\x12active_battle_pass\x183\x20\x01(\x08R\x10activeBattlePass\
    \x12\x1b\n\tnet_worth\x184\x20\x01(\rR\x08netWorth\x12%\n\x0ebot_difficu\
    lty\x18:\x20\x01(\rR\rbotDifficulty\x1aE\n\x0eCustomGameData\x12\x1b\n\t\
    dota_team\x18\x01\x20\x01(\rR\x08dotaTeam\x12\x16\n\x06winner\x18\x02\
    \x20\x01(\x08R\x06winner\x1aD\n\x0fBroadcasterInfo\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x1a\xcb\x01\n\x12BroadcasterChannel\x12!\n\x0ccountry_code\x18\
    \x01\x20\x01(\tR\x0bcountryCode\x12\x20\n\x0bdescription\x18\x02\x20\x01\
    (\tR\x0bdescription\x12K\n\x11broadcaster_infos\x18\x03\x20\x03(\x0b2\
    \x1e.CMsgDOTAMatch.BroadcasterInfoR\x10broadcasterInfos\x12#\n\rlanguage\
    _code\x18\x04\x20\x01(\tR\x0clanguageCode\x1aQ\n\x0eCustomGameData\x12$\
    \n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\x19\n\x08\
    map_name\x18\x02\x20\x01(\tR\x07mapName\"P\n\x0bReplayState\x12\x14\n\
    \x10REPLAY_AVAILABLE\x10\0\x12\x17\n\x13REPLAY_NOT_RECORDED\x10\x01\x12\
    \x12\n\x0eREPLAY_EXPIRED\x10\x02\"\xac\x01\n\x0eCMsgPlayerCard\x12\x1d\n\
    \naccount_id\x18\x01\x20\x01(\rR\taccountId\x12A\n\rstat_modifier\x18\
    \x02\x20\x03(\x0b2\x1c.CMsgPlayerCard.StatModifierR\x0cstatModifier\x1a8\
    \n\x0cStatModifier\x12\x12\n\x04stat\x18\x01\x20\x01(\rR\x04stat\x12\x14\
    \n\x05value\x18\x02\x20\x01(\rR\x05value\"\x87\x05\n\x1aCMsgDOTAFantasyP\
    layerStats\x12*\n\x11player_account_id\x18\x01\x20\x01(\rR\x0fplayerAcco\
    untId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12'\n\x0fm\
    atch_completed\x18\x03\x20\x01(\x08R\x0ematchCompleted\x12\x17\n\x07team\
    _id\x18\x04\x20\x01(\rR\x06teamId\x12\x1b\n\tleague_id\x18\x05\x20\x01(\
    \rR\x08leagueId\x12\x14\n\x05delay\x18\x06\x20\x01(\rR\x05delay\x12\x1b\
    \n\tseries_id\x18\x07\x20\x01(\rR\x08seriesId\x12\x1f\n\x0bseries_type\
    \x18\x08\x20\x01(\rR\nseriesType\x12\x14\n\x05kills\x18\n\x20\x01(\rR\
    \x05kills\x12\x16\n\x06deaths\x18\x0b\x20\x01(\rR\x06deaths\x12\x0e\n\
    \x02cs\x18\x0c\x20\x01(\rR\x02cs\x12\x10\n\x03gpm\x18\r\x20\x01(\x02R\
    \x03gpm\x12\x1f\n\x0btower_kills\x18\x0e\x20\x01(\rR\ntowerKills\x12!\n\
    \x0croshan_kills\x18\x0f\x20\x01(\rR\x0broshanKills\x127\n\x17teamfight_\
    participation\x18\x10\x20\x01(\x02R\x16teamfightParticipation\x12!\n\x0c\
    wards_placed\x18\x11\x20\x01(\rR\x0bwardsPlaced\x12#\n\rcamps_stacked\
    \x18\x12\x20\x01(\rR\x0ccampsStacked\x12#\n\rrunes_grabbed\x18\x13\x20\
    \x01(\rR\x0crunesGrabbed\x12\x1f\n\x0bfirst_blood\x18\x14\x20\x01(\rR\nf\
    irstBlood\x12\x14\n\x05stuns\x18\x15\x20\x01(\x02R\x05stuns\"X\n\x1fCMsg\
    DOTAFantasyPlayerMatchStats\x125\n\x07matches\x18\x01\x20\x03(\x0b2\x1b.\
    CMsgDOTAFantasyPlayerStatsR\x07matches\"\xd0\n\n\x14CMsgDOTABotDebugInfo\
    \x12-\n\x04bots\x18\x01\x20\x03(\x0b2\x19.CMsgDOTABotDebugInfo.BotR\x04b\
    ots\x12/\n\x14desire_push_lane_top\x18\x02\x20\x01(\x02R\x11desirePushLa\
    neTop\x12/\n\x14desire_push_lane_mid\x18\x03\x20\x01(\x02R\x11desirePush\
    LaneMid\x12/\n\x14desire_push_lane_bot\x18\x04\x20\x01(\x02R\x11desirePu\
    shLaneBot\x123\n\x16desire_defend_lane_top\x18\x05\x20\x01(\x02R\x13desi\
    reDefendLaneTop\x123\n\x16desire_defend_lane_mid\x18\x06\x20\x01(\x02R\
    \x13desireDefendLaneMid\x123\n\x16desire_defend_lane_bot\x18\x07\x20\x01\
    (\x02R\x13desireDefendLaneBot\x12/\n\x14desire_farm_lane_top\x18\x08\x20\
    \x01(\x02R\x11desireFarmLaneTop\x12/\n\x14desire_farm_lane_mid\x18\t\x20\
    \x01(\x02R\x11desireFarmLaneMid\x12/\n\x14desire_farm_lane_bot\x18\n\x20\
    \x01(\x02R\x11desireFarmLaneBot\x12,\n\x12desire_farm_roshan\x18\x0b\x20\
    \x01(\x02R\x10desireFarmRoshan\x12%\n\x0eexecution_time\x18\x0c\x20\x01(\
    \x02R\rexecutionTime\x12\x1f\n\x0brune_status\x18\r\x20\x03(\rR\nruneSta\
    tus\x1a\xcd\x05\n\x03Bot\x12&\n\x0fplayer_owner_id\x18\x01\x20\x01(\rR\r\
    playerOwnerId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x12\x1e\
    \n\ndifficulty\x18\x03\x20\x01(\rR\ndifficulty\x12#\n\rpower_current\x18\
    \x04\x20\x01(\rR\x0cpowerCurrent\x12\x1b\n\tpower_max\x18\x05\x20\x01(\r\
    R\x08powerMax\x12\"\n\rmove_target_x\x18\x06\x20\x01(\rR\x0bmoveTargetX\
    \x12\"\n\rmove_target_y\x18\x07\x20\x01(\rR\x0bmoveTargetY\x12\"\n\rmove\
    _target_z\x18\x08\x20\x01(\rR\x0bmoveTargetZ\x12$\n\x0eactive_mode_id\
    \x18\t\x20\x01(\rR\x0cactiveModeId\x12%\n\x0eexecution_time\x18\n\x20\
    \x01(\x02R\rexecutionTime\x124\n\x05modes\x18\x0b\x20\x03(\x0b2\x1e.CMsg\
    DOTABotDebugInfo.Bot.ModeR\x05modes\x128\n\x06action\x18\x0c\x20\x01(\
    \x0b2\x20.CMsgDOTABotDebugInfo.Bot.ActionR\x06action\x1a\xad\x01\n\x04Mo\
    de\x12\x17\n\x07mode_id\x18\x01\x20\x01(\rR\x06modeId\x12\x16\n\x06desir\
    e\x18\x02\x20\x01(\x02R\x06desire\x12#\n\rtarget_entity\x18\x03\x20\x01(\
    \rR\x0ctargetEntity\x12\x19\n\x08target_x\x18\x04\x20\x01(\rR\x07targetX\
    \x12\x19\n\x08target_y\x18\x05\x20\x01(\rR\x07targetY\x12\x19\n\x08targe\
    t_z\x18\x06\x20\x01(\rR\x07targetZ\x1aJ\n\x06Action\x12\x1b\n\taction_id\
    \x18\x01\x20\x01(\rR\x08actionId\x12#\n\raction_target\x18\x02\x20\x01(\
    \tR\x0cactionTarget*U\n\x11ESpecialPingValue\x12\x1f\n\x1ak_ESpecialPing\
    Value_NoData\x10\xfe\x7f\x12\x1f\n\x1ak_ESpecialPingValue_Failed\x10\xff\
    \x7f*\x86\x05\n\x12EDOTAGCSessionNeed\x12\x20\n\x1ck_EDOTAGCSessionNeed_\
    Unknown\x10\0\x12,\n(k_EDOTAGCSessionNeed_UserNoSessionNeeded\x10d\x12)\
    \n%k_EDOTAGCSessionNeed_UserInOnlineGame\x10e\x12(\n$k_EDOTAGCSessionNee\
    d_UserInLocalGame\x10f\x12-\n)k_EDOTAGCSessionNeed_UserInUIWasConnected\
    \x10g\x12/\n+k_EDOTAGCSessionNeed_UserInUINeverConnected\x10h\x12&\n\"k_\
    EDOTAGCSessionNeed_UserTutorials\x10i\x121\n-k_EDOTAGCSessionNeed_UserIn\
    UIWasConnectedIdle\x10j\x123\n/k_EDOTAGCSessionNeed_UserInUINeverConnect\
    edIdle\x10k\x12*\n%k_EDOTAGCSessionNeed_GameServerOnline\x10\xc8\x01\x12\
    )\n$k_EDOTAGCSessionNeed_GameServerLocal\x10\xc9\x01\x12(\n#k_EDOTAGCSes\
    sionNeed_GameServerIdle\x10\xca\x01\x12)\n$k_EDOTAGCSessionNeed_GameServ\
    erRelay\x10\xcb\x01\x12/\n*k_EDOTAGCSessionNeed_GameServerLocalUpload\
    \x10\xcc\x01*\xf6\x01\n\x15DOTA_TournamentEvents\x12\x12\n\x0eTE_FIRST_B\
    LOOD\x10\0\x12\x0f\n\x0bTE_GAME_END\x10\x01\x12\x11\n\rTE_MULTI_KILL\x10\
    \x02\x12\x10\n\x0cTE_HERO_DENY\x10\x03\x12\x11\n\rTE_AEGIS_DENY\x10\x04\
    \x12\x13\n\x0fTE_AEGIS_STOLEN\x10\x05\x12\x0e\n\nTE_GODLIKE\x10\x06\x12\
    \x13\n\x0fTE_COURIER_KILL\x10\x07\x12\x0f\n\x0bTE_ECHOSLAM\x10\x08\x12\r\
    \n\tTE_RAPIER\x10\t\x12\x13\n\x0fTE_EARLY_ROSHAN\x10\n\x12\x11\n\rTE_BLA\
    CK_HOLE\x10\x0b*\xf2\n\n\x14DOTA_COMBATLOG_TYPES\x12#\n\x16DOTA_COMBATLO\
    G_INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x19\n\x15DOTA_\
    COMBATLOG_DAMAGE\x10\0\x12\x17\n\x13DOTA_COMBATLOG_HEAL\x10\x01\x12\x1f\
    \n\x1bDOTA_COMBATLOG_MODIFIER_ADD\x10\x02\x12\"\n\x1eDOTA_COMBATLOG_MODI\
    FIER_REMOVE\x10\x03\x12\x18\n\x14DOTA_COMBATLOG_DEATH\x10\x04\x12\x1a\n\
    \x16DOTA_COMBATLOG_ABILITY\x10\x05\x12\x17\n\x13DOTA_COMBATLOG_ITEM\x10\
    \x06\x12\x1b\n\x17DOTA_COMBATLOG_LOCATION\x10\x07\x12\x17\n\x13DOTA_COMB\
    ATLOG_GOLD\x10\x08\x12\x1d\n\x19DOTA_COMBATLOG_GAME_STATE\x10\t\x12\x15\
    \n\x11DOTA_COMBATLOG_XP\x10\n\x12\x1b\n\x17DOTA_COMBATLOG_PURCHASE\x10\
    \x0b\x12\x1a\n\x16DOTA_COMBATLOG_BUYBACK\x10\x0c\x12\"\n\x1eDOTA_COMBATL\
    OG_ABILITY_TRIGGER\x10\r\x12\x1e\n\x1aDOTA_COMBATLOG_PLAYERSTATS\x10\x0e\
    \x12\x1c\n\x18DOTA_COMBATLOG_MULTIKILL\x10\x0f\x12\x1d\n\x19DOTA_COMBATL\
    OG_KILLSTREAK\x10\x10\x12%\n!DOTA_COMBATLOG_TEAM_BUILDING_KILL\x10\x11\
    \x12\x1e\n\x1aDOTA_COMBATLOG_FIRST_BLOOD\x10\x12\x12#\n\x1fDOTA_COMBATLO\
    G_MODIFIER_REFRESH\x10\x13\x12%\n!DOTA_COMBATLOG_NEUTRAL_CAMP_STACK\x10\
    \x14\x12\x1e\n\x1aDOTA_COMBATLOG_PICKUP_RUNE\x10\x15\x12%\n!DOTA_COMBATL\
    OG_REVEALED_INVISIBLE\x10\x16\x12\x1d\n\x19DOTA_COMBATLOG_HERO_SAVED\x10\
    \x17\x12\x20\n\x1cDOTA_COMBATLOG_MANA_RESTORED\x10\x18\x12\x1f\n\x1bDOTA\
    _COMBATLOG_HERO_LEVELUP\x10\x19\x12#\n\x1fDOTA_COMBATLOG_BOTTLE_HEAL_ALL\
    Y\x10\x1a\x12\x20\n\x1cDOTA_COMBATLOG_ENDGAME_STATS\x10\x1b\x12$\n\x20DO\
    TA_COMBATLOG_INTERRUPT_CHANNEL\x10\x1c\x12\x1e\n\x1aDOTA_COMBATLOG_ALLIE\
    D_GOLD\x10\x1d\x12\x1e\n\x1aDOTA_COMBATLOG_AEGIS_TAKEN\x10\x1e\x12\x1e\n\
    \x1aDOTA_COMBATLOG_MANA_DAMAGE\x10\x1f\x12,\n(DOTA_COMBATLOG_PHYSICAL_DA\
    MAGE_PREVENTED\x10\x20\x12\x20\n\x1cDOTA_COMBATLOG_UNIT_SUMMONED\x10!\
    \x12\x1f\n\x1bDOTA_COMBATLOG_ATTACK_EVADE\x10\"\x12\x1b\n\x17DOTA_COMBAT\
    LOG_TREE_CUT\x10#\x12\"\n\x1eDOTA_COMBATLOG_SUCCESSFUL_SCAN\x10$\x12!\n\
    \x1dDOTA_COMBATLOG_END_KILLSTREAK\x10%\x12$\n\x20DOTA_COMBATLOG_BLOODSTO\
    NE_CHARGE\x10&\x12\"\n\x1eDOTA_COMBATLOG_CRITICAL_DAMAGE\x10'\x12\x1f\n\
    \x1bDOTA_COMBATLOG_SPELL_ABSORB\x10(B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
